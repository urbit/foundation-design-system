'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React$2 = require('react');
var Link = require('next/link');
var reactDom = require('react-dom');
var router = require('next/router');
var path = require('path');
var fs$1 = require('fs');
var require$$0 = require('stream');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__default = /*#__PURE__*/_interopDefaultLegacy(React$2);
var React__namespace = /*#__PURE__*/_interopNamespace(React$2);
var Link__default = /*#__PURE__*/_interopDefaultLegacy(Link);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs$1);
var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);

function BackgroundImage(props) {
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: `bg-img bg-cover ${props.className || ""}`,
    style: {
      backgroundImage: `url(${props.src})`,
      ...props.style
    }
  });
}

function Container({
  children
}) {
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: "flex flex-col min-h-screen w-screen max-w-full items-center bg-white"
  }, children);
}

function SingleColumn({
  children
}) {
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: "flex flex-col w-full items-center max-w-screen-2xl"
  }, children);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var classnames = {exports: {}};

/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/

(function (module) {
	/* global define */

	(function () {

	  var hasOwn = {}.hasOwnProperty;
	  function classNames() {
	    var classes = [];
	    for (var i = 0; i < arguments.length; i++) {
	      var arg = arguments[i];
	      if (!arg) continue;
	      var argType = typeof arg;
	      if (argType === 'string' || argType === 'number') {
	        classes.push(arg);
	      } else if (Array.isArray(arg)) {
	        if (arg.length) {
	          var inner = classNames.apply(null, arg);
	          if (inner) {
	            classes.push(inner);
	          }
	        }
	      } else if (argType === 'object') {
	        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
	          classes.push(arg.toString());
	          continue;
	        }
	        for (var key in arg) {
	          if (hasOwn.call(arg, key) && arg[key]) {
	            classes.push(key);
	          }
	        }
	      }
	    }
	    return classes.join(' ');
	  }
	  if (module.exports) {
	    classNames.default = classNames;
	    module.exports = classNames;
	  } else {
	    window.classNames = classNames;
	  }
	})();
} (classnames));

var classNames = classnames.exports;

function Section({
  children,
  className = "",
  short = false,
  narrow = false
}) {
  const spacing = classNames({
    "py-8": short,
    "py-20": !short,
    "layout-narrow": narrow,
    layout: !narrow
  });
  return /*#__PURE__*/React__default["default"].createElement("section", {
    className: `w-full px-4 md:px-8 ${spacing} ${className}`
  }, children);
}

function Footer$1({
  title = "",
  data = [[{}], [{}]]
}) {
  return /*#__PURE__*/React__default["default"].createElement("footer", {
    className: "bg-wall-100 mt-20 w-full flex justify-center z-10"
  }, /*#__PURE__*/React__default["default"].createElement(SingleColumn, null, /*#__PURE__*/React__default["default"].createElement(Section, {
    short: true,
    className: "flex flex-row flex-wrap"
  }, data?.[0]?.map((section, i) => {
    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, {
      key: i
    }, i === 0 && /*#__PURE__*/React__default["default"].createElement("p", {
      className: "mt-12 text-2xl font-semibold w-full"
    }, "~"), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "w-1/2 md:w-1/3 flex flex-col shrink"
    }, section?.title && /*#__PURE__*/React__default["default"].createElement("h4", {
      className: "mt-10 h-8 font-bold text-base"
    }, section.title), section.links.map(link => {
      return /*#__PURE__*/React__default["default"].createElement(Link__default["default"], {
        key: link.href,
        href: link.href,
        passHref: true
      }, /*#__PURE__*/React__default["default"].createElement("a", {
        className: "type-medium text-wall-600 pb-1"
      }, link.title));
    })));
  })), /*#__PURE__*/React__default["default"].createElement(Section, {
    className: "flex flex-col md:flex-row"
  }, data?.[1]?.map(link => {
    return /*#__PURE__*/React__default["default"].createElement("div", {
      key: link.href,
      className: "md:w-1/3"
    }, /*#__PURE__*/React__default["default"].createElement(Link__default["default"], {
      href: link.href,
      passHref: true
    }, /*#__PURE__*/React__default["default"].createElement("a", {
      className: "type-medium text-wall-600"
    }, link.title)));
  }))));
}

function ControlKeyIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "15",
    height: "15",
    className: "DocSearch-Control-Key-Icon"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M4.505 4.496h2M5.505 5.496v5M8.216 4.496l.055 5.993M10 7.5c.333.333.5.667.5 1v2M12.326 4.5v5.996M8.384 4.496c1.674 0 2.116 0 2.116 1.5s-.442 1.5-2.116 1.5M3.205 9.303c-.09.448-.277 1.21-1.241 1.203C1 10.5.5 9.513.5 8V7c0-1.57.5-2.5 1.464-2.494.964.006 1.134.598 1.24 1.342M12.553 10.5h1.953",
    strokeWidth: "1.2",
    stroke: "currentColor",
    fill: "none",
    strokeLinecap: "square"
  }));
}

function SearchIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "20",
    height: "20",
    className: "DocSearch-Search-Icon",
    viewBox: "0 0 20 20"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z",
    stroke: "currentColor",
    fill: "none",
    fillRule: "evenodd",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
}

var _excluded$b = ["translations"];
function _extends$e() {
  _extends$e = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$e.apply(this, arguments);
}
function _slicedToArray$6(arr, i) {
  return _arrayWithHoles$6(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$b(arr, i) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$b(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$b(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen);
}
function _arrayLikeToArray$b(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$6(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$6(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$b(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$b(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$b(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ACTION_KEY_DEFAULT = 'Ctrl';
var ACTION_KEY_APPLE = '⌘';
function isAppleDevice() {
  return /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
}
var DocSearchButton = /*#__PURE__*/React__default["default"].forwardRef(function (_ref, ref) {
  var _ref$translations = _ref.translations,
    translations = _ref$translations === void 0 ? {} : _ref$translations,
    props = _objectWithoutProperties$b(_ref, _excluded$b);
  var _translations$buttonT = translations.buttonText,
    buttonText = _translations$buttonT === void 0 ? 'Search' : _translations$buttonT,
    _translations$buttonA = translations.buttonAriaLabel,
    buttonAriaLabel = _translations$buttonA === void 0 ? 'Search' : _translations$buttonA;
  var _useState = React$2.useState(null),
    _useState2 = _slicedToArray$6(_useState, 2),
    key = _useState2[0],
    setKey = _useState2[1];
  React$2.useEffect(function () {
    if (typeof navigator !== 'undefined') {
      isAppleDevice() ? setKey(ACTION_KEY_APPLE) : setKey(ACTION_KEY_DEFAULT);
    }
  }, []);
  return /*#__PURE__*/React__default["default"].createElement("button", _extends$e({
    type: "button",
    className: "DocSearch DocSearch-Button",
    "aria-label": buttonAriaLabel
  }, props, {
    ref: ref
  }), /*#__PURE__*/React__default["default"].createElement("span", {
    className: "DocSearch-Button-Container"
  }, /*#__PURE__*/React__default["default"].createElement(SearchIcon, null), /*#__PURE__*/React__default["default"].createElement("span", {
    className: "DocSearch-Button-Placeholder"
  }, buttonText)), /*#__PURE__*/React__default["default"].createElement("span", {
    className: "DocSearch-Button-Keys"
  }, key !== null && /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("kbd", {
    className: "DocSearch-Button-Key"
  }, key === ACTION_KEY_DEFAULT ? /*#__PURE__*/React__default["default"].createElement(ControlKeyIcon, null) : key), /*#__PURE__*/React__default["default"].createElement("kbd", {
    className: "DocSearch-Button-Key"
  }, "K"))));
});

function createRef(initialValue) {
  return {
    current: initialValue
  };
}

function debounce$2(fn, time) {
  var timerId = undefined;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (timerId) {
      clearTimeout(timerId);
    }
    timerId = setTimeout(function () {
      return fn.apply(void 0, args);
    }, time);
  };
}

function _slicedToArray$5(arr, i) {
  return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$a(arr, i) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$a(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$a(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen);
}
function _arrayLikeToArray$a(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$5(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s,
      _e,
      _x,
      _r,
      _arr = [],
      _n = !0,
      _d = !1;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = !1;
      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$5(arr) {
  if (Array.isArray(arr)) return arr;
}
function _typeof$e(obj) {
  "@babel/helpers - typeof";

  return _typeof$e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$e(obj);
}
/**
 * Decycles objects with circular references.
 * This is used to print cyclic structures in development environment only.
 */
function decycle(obj) {
  var seen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
  if (!(process.env.NODE_ENV !== 'production') || !obj || _typeof$e(obj) !== 'object') {
    return obj;
  }
  if (seen.has(obj)) {
    return '[Circular]';
  }
  var newSeen = seen.add(obj);
  if (Array.isArray(obj)) {
    return obj.map(function (x) {
      return decycle(x, newSeen);
    });
  }
  return Object.fromEntries(Object.entries(obj).map(function (_ref) {
    var _ref2 = _slicedToArray$5(_ref, 2),
      key = _ref2[0],
      value = _ref2[1];
    return [key, decycle(value, newSeen)];
  }));
}

function flatten(values) {
  return values.reduce(function (a, b) {
    return a.concat(b);
  }, []);
}

var autocompleteId = 0;
function generateAutocompleteId() {
  return "autocomplete-".concat(autocompleteId++);
}

function getItemsCount(state) {
  if (state.collections.length === 0) {
    return 0;
  }
  return state.collections.reduce(function (sum, collection) {
    return sum + collection.items.length;
  }, 0);
}

/**
 * Throws an error if the condition is not met in development mode.
 * This is used to make development a better experience to provide guidance as
 * to where the error comes from.
 */
function invariant$1(condition, message) {
  if (!(process.env.NODE_ENV !== 'production')) {
    return;
  }
  if (!condition) {
    throw new Error("[Autocomplete] ".concat(typeof message === 'function' ? message() : message));
  }
}

function isPrimitive(obj) {
  return obj !== Object(obj);
}
function isEqual$1(first, second) {
  if (first === second) {
    return true;
  }
  if (isPrimitive(first) || isPrimitive(second) || typeof first === 'function' || typeof second === 'function') {
    return first === second;
  }
  if (Object.keys(first).length !== Object.keys(second).length) {
    return false;
  }
  for (var _i = 0, _Object$keys = Object.keys(first); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    if (!(key in second)) {
      return false;
    }
    if (!isEqual$1(first[key], second[key])) {
      return false;
    }
  }
  return true;
}

var noop$2 = function noop() {};

/**
 * Safely runs code meant for browser environments only.
 */
function safelyRunOnBrowser(callback) {
  if (typeof window !== 'undefined') {
    return callback({
      window: window
    });
  }
  return undefined;
}

var version$2 = '1.9.3';

var userAgents = [{
  segment: 'autocomplete-core',
  version: version$2
}];

var warnCache = {
  current: {}
};

/**
 * Logs a warning if the condition is not met.
 * This is used to log issues in development environment only.
 */
function warn(condition, message) {
  if (!(process.env.NODE_ENV !== 'production')) {
    return;
  }
  if (condition) {
    return;
  }
  var sanitizedMessage = message.trim();
  var hasAlreadyPrinted = warnCache.current[sanitizedMessage];
  if (!hasAlreadyPrinted) {
    warnCache.current[sanitizedMessage] = true;

    // eslint-disable-next-line no-console
    console.warn("[Autocomplete] ".concat(sanitizedMessage));
  }
}

function createClickedEvent(_ref) {
  var item = _ref.item,
    items = _ref.items;
  return {
    index: item.__autocomplete_indexName,
    items: [item],
    positions: [1 + items.findIndex(function (x) {
      return x.objectID === item.objectID;
    })],
    queryID: item.__autocomplete_queryID,
    algoliaSource: ['autocomplete']
  };
}

function _slicedToArray$4(arr, i) {
  return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$9(arr, i) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen);
}
function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$4(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s,
      _e,
      _x,
      _r,
      _arr = [],
      _n = !0,
      _d = !1;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = !1;
      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$4(arr) {
  if (Array.isArray(arr)) return arr;
}
/**
 * Determines if a given insights `client` supports the optional call to `init`
 * and the ability to set credentials via extra parameters when sending events.
 */
function isModernInsightsClient(client) {
  var _split$map = (client.version || '').split('.').map(Number),
    _split$map2 = _slicedToArray$4(_split$map, 2),
    major = _split$map2[0],
    minor = _split$map2[1];

  /* eslint-disable @typescript-eslint/camelcase */
  var v3 = major >= 3;
  var v2_4 = major === 2 && minor >= 4;
  var v1_10 = major === 1 && minor >= 10;
  return v3 || v2_4 || v1_10;
  /* eslint-enable @typescript-eslint/camelcase */
}

var _excluded$a = ["items"],
  _excluded2$1 = ["items"];
function _typeof$d(obj) {
  "@babel/helpers - typeof";

  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$d(obj);
}
function _toConsumableArray$4(arr) {
  return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$8(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen);
}
function _iterableToArray$4(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$4(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$8(arr);
}
function _arrayLikeToArray$8(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _objectWithoutProperties$a(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$a(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$a(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function ownKeys$f(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$f(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$f(Object(source), !0).forEach(function (key) {
      _defineProperty$g(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$g(obj, key, value) {
  key = _toPropertyKey$d(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$d(arg) {
  var key = _toPrimitive$d(arg, "string");
  return _typeof$d(key) === "symbol" ? key : String(key);
}
function _toPrimitive$d(input, hint) {
  if (_typeof$d(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$d(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function chunk$2(item) {
  var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
  var chunks = [];
  for (var i = 0; i < item.objectIDs.length; i += chunkSize) {
    chunks.push(_objectSpread$f(_objectSpread$f({}, item), {}, {
      objectIDs: item.objectIDs.slice(i, i + chunkSize)
    }));
  }
  return chunks;
}
function mapToInsightsParamsApi(params) {
  return params.map(function (_ref) {
    var items = _ref.items,
      param = _objectWithoutProperties$a(_ref, _excluded$a);
    return _objectSpread$f(_objectSpread$f({}, param), {}, {
      objectIDs: (items === null || items === void 0 ? void 0 : items.map(function (_ref2) {
        var objectID = _ref2.objectID;
        return objectID;
      })) || param.objectIDs
    });
  });
}
function createSearchInsightsApi(searchInsights) {
  var canSendHeaders = isModernInsightsClient(searchInsights);
  function sendToInsights(method, payloads, items) {
    if (canSendHeaders && typeof items !== 'undefined') {
      var _items$0$__autocomple = items[0].__autocomplete_algoliaCredentials,
        appId = _items$0$__autocomple.appId,
        apiKey = _items$0$__autocomple.apiKey;
      var headers = {
        'X-Algolia-Application-Id': appId,
        'X-Algolia-API-Key': apiKey
      };
      searchInsights.apply(void 0, [method].concat(_toConsumableArray$4(payloads), [{
        headers: headers
      }]));
    } else {
      searchInsights.apply(void 0, [method].concat(_toConsumableArray$4(payloads)));
    }
  }
  return {
    /**
     * Initializes Insights with Algolia credentials.
     */
    init: function init(appId, apiKey) {
      searchInsights('init', {
        appId: appId,
        apiKey: apiKey
      });
    },
    /**
     * Sets the user token to attach to events.
     */
    setUserToken: function setUserToken(userToken) {
      searchInsights('setUserToken', userToken);
    },
    /**
     * Sends click events to capture a query and its clicked items and positions.
     *
     * @link https://www.algolia.com/doc/api-reference/api-methods/clicked-object-ids-after-search/
     */
    clickedObjectIDsAfterSearch: function clickedObjectIDsAfterSearch() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      if (params.length > 0) {
        sendToInsights('clickedObjectIDsAfterSearch', mapToInsightsParamsApi(params), params[0].items);
      }
    },
    /**
     * Sends click events to capture clicked items.
     *
     * @link https://www.algolia.com/doc/api-reference/api-methods/clicked-object-ids/
     */
    clickedObjectIDs: function clickedObjectIDs() {
      for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        params[_key2] = arguments[_key2];
      }
      if (params.length > 0) {
        sendToInsights('clickedObjectIDs', mapToInsightsParamsApi(params), params[0].items);
      }
    },
    /**
     * Sends click events to capture the filters a user clicks on.
     *
     * @link https://www.algolia.com/doc/api-reference/api-methods/clicked-filters/
     */
    clickedFilters: function clickedFilters() {
      for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        params[_key3] = arguments[_key3];
      }
      if (params.length > 0) {
        searchInsights.apply(void 0, ['clickedFilters'].concat(params));
      }
    },
    /**
     * Sends conversion events to capture a query and its clicked items.
     *
     * @link https://www.algolia.com/doc/api-reference/api-methods/converted-object-ids-after-search/
     */
    convertedObjectIDsAfterSearch: function convertedObjectIDsAfterSearch() {
      for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        params[_key4] = arguments[_key4];
      }
      if (params.length > 0) {
        sendToInsights('convertedObjectIDsAfterSearch', mapToInsightsParamsApi(params), params[0].items);
      }
    },
    /**
     * Sends conversion events to capture clicked items.
     *
     * @link https://www.algolia.com/doc/api-reference/api-methods/converted-object-ids/
     */
    convertedObjectIDs: function convertedObjectIDs() {
      for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        params[_key5] = arguments[_key5];
      }
      if (params.length > 0) {
        sendToInsights('convertedObjectIDs', mapToInsightsParamsApi(params), params[0].items);
      }
    },
    /**
     * Sends conversion events to capture the filters a user uses when converting.
     *
     * @link https://www.algolia.com/doc/api-reference/api-methods/converted-filters/
     */
    convertedFilters: function convertedFilters() {
      for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        params[_key6] = arguments[_key6];
      }
      if (params.length > 0) {
        searchInsights.apply(void 0, ['convertedFilters'].concat(params));
      }
    },
    /**
     * Sends view events to capture clicked items.
     *
     * @link https://www.algolia.com/doc/api-reference/api-methods/viewed-object-ids/
     */
    viewedObjectIDs: function viewedObjectIDs() {
      for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        params[_key7] = arguments[_key7];
      }
      if (params.length > 0) {
        params.reduce(function (acc, _ref3) {
          var items = _ref3.items,
            param = _objectWithoutProperties$a(_ref3, _excluded2$1);
          return [].concat(_toConsumableArray$4(acc), _toConsumableArray$4(chunk$2(_objectSpread$f(_objectSpread$f({}, param), {}, {
            objectIDs: (items === null || items === void 0 ? void 0 : items.map(function (_ref4) {
              var objectID = _ref4.objectID;
              return objectID;
            })) || param.objectIDs
          })).map(function (payload) {
            return {
              items: items,
              payload: payload
            };
          })));
        }, []).forEach(function (_ref5) {
          var items = _ref5.items,
            payload = _ref5.payload;
          return sendToInsights('viewedObjectIDs', [payload], items);
        });
      }
    },
    /**
     * Sends view events to capture the filters a user uses when viewing.
     *
     * @link https://www.algolia.com/doc/api-reference/api-methods/viewed-filters/
     */
    viewedFilters: function viewedFilters() {
      for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        params[_key8] = arguments[_key8];
      }
      if (params.length > 0) {
        searchInsights.apply(void 0, ['viewedFilters'].concat(params));
      }
    }
  };
}

function createViewedEvents(_ref) {
  var items = _ref.items;
  var itemsByIndexName = items.reduce(function (acc, current) {
    var _acc$current$__autoco;
    acc[current.__autocomplete_indexName] = ((_acc$current$__autoco = acc[current.__autocomplete_indexName]) !== null && _acc$current$__autoco !== void 0 ? _acc$current$__autoco : []).concat(current);
    return acc;
  }, {});
  return Object.keys(itemsByIndexName).map(function (indexName) {
    var items = itemsByIndexName[indexName];
    return {
      index: indexName,
      items: items,
      algoliaSource: ['autocomplete']
    };
  });
}

function isAlgoliaInsightsHit(hit) {
  return hit.objectID && hit.__autocomplete_indexName && hit.__autocomplete_queryID;
}

function _typeof$c(obj) {
  "@babel/helpers - typeof";

  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$c(obj);
}
function _toConsumableArray$3(arr) {
  return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
}
function _iterableToArray$3(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$3(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$7(arr);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys$e(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$e(Object(source), !0).forEach(function (key) {
      _defineProperty$f(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$f(obj, key, value) {
  key = _toPropertyKey$c(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$c(arg) {
  var key = _toPrimitive$c(arg, "string");
  return _typeof$c(key) === "symbol" ? key : String(key);
}
function _toPrimitive$c(input, hint) {
  if (_typeof$c(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$c(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var VIEW_EVENT_DELAY = 400;
var ALGOLIA_INSIGHTS_VERSION = '2.6.0';
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights@".concat(ALGOLIA_INSIGHTS_VERSION, "/dist/search-insights.min.js");
var sendViewedObjectIDs = debounce$2(function (_ref) {
  var onItemsChange = _ref.onItemsChange,
    items = _ref.items,
    insights = _ref.insights,
    state = _ref.state;
  onItemsChange({
    insights: insights,
    insightsEvents: createViewedEvents({
      items: items
    }).map(function (event) {
      return _objectSpread$e({
        eventName: 'Items Viewed'
      }, event);
    }),
    state: state
  });
}, VIEW_EVENT_DELAY);
function createAlgoliaInsightsPlugin(options) {
  var _getOptions = getOptions(options),
    providedInsightsClient = _getOptions.insightsClient,
    onItemsChange = _getOptions.onItemsChange,
    onSelectEvent = _getOptions.onSelect,
    onActiveEvent = _getOptions.onActive;
  var insightsClient = providedInsightsClient;
  if (!providedInsightsClient) {
    safelyRunOnBrowser(function (_ref2) {
      var window = _ref2.window;
      var pointer = window.AlgoliaAnalyticsObject || 'aa';
      if (typeof pointer === 'string') {
        insightsClient = window[pointer];
      }
      if (!insightsClient) {
        window.AlgoliaAnalyticsObject = pointer;
        if (!window[pointer]) {
          window[pointer] = function () {
            if (!window[pointer].queue) {
              window[pointer].queue = [];
            }
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            window[pointer].queue.push(args);
          };
        }
        window[pointer].version = ALGOLIA_INSIGHTS_VERSION;
        insightsClient = window[pointer];
        loadInsights(window);
      }
    });
  }
  var insights = createSearchInsightsApi(insightsClient);
  var previousItems = createRef([]);
  var debouncedOnStateChange = debounce$2(function (_ref3) {
    var state = _ref3.state;
    if (!state.isOpen) {
      return;
    }
    var items = state.collections.reduce(function (acc, current) {
      return [].concat(_toConsumableArray$3(acc), _toConsumableArray$3(current.items));
    }, []).filter(isAlgoliaInsightsHit);
    if (!isEqual$1(previousItems.current.map(function (x) {
      return x.objectID;
    }), items.map(function (x) {
      return x.objectID;
    }))) {
      previousItems.current = items;
      if (items.length > 0) {
        sendViewedObjectIDs({
          onItemsChange: onItemsChange,
          items: items,
          insights: insights,
          state: state
        });
      }
    }
  }, 0);
  return {
    name: 'aa.algoliaInsightsPlugin',
    subscribe: function subscribe(_ref4) {
      var setContext = _ref4.setContext,
        onSelect = _ref4.onSelect,
        onActive = _ref4.onActive;
      insightsClient('addAlgoliaAgent', 'insights-plugin');
      setContext({
        algoliaInsightsPlugin: {
          __algoliaSearchParameters: {
            clickAnalytics: true
          },
          insights: insights
        }
      });
      onSelect(function (_ref5) {
        var item = _ref5.item,
          state = _ref5.state,
          event = _ref5.event;
        if (!isAlgoliaInsightsHit(item)) {
          return;
        }
        onSelectEvent({
          state: state,
          event: event,
          insights: insights,
          item: item,
          insightsEvents: [_objectSpread$e({
            eventName: 'Item Selected'
          }, createClickedEvent({
            item: item,
            items: previousItems.current
          }))]
        });
      });
      onActive(function (_ref6) {
        var item = _ref6.item,
          state = _ref6.state,
          event = _ref6.event;
        if (!isAlgoliaInsightsHit(item)) {
          return;
        }
        onActiveEvent({
          state: state,
          event: event,
          insights: insights,
          item: item,
          insightsEvents: [_objectSpread$e({
            eventName: 'Item Active'
          }, createClickedEvent({
            item: item,
            items: previousItems.current
          }))]
        });
      });
    },
    onStateChange: function onStateChange(_ref7) {
      var state = _ref7.state;
      debouncedOnStateChange({
        state: state
      });
    },
    __autocomplete_pluginOptions: options
  };
}
function getOptions(options) {
  return _objectSpread$e({
    onItemsChange: function onItemsChange(_ref8) {
      var insights = _ref8.insights,
        insightsEvents = _ref8.insightsEvents;
      insights.viewedObjectIDs.apply(insights, _toConsumableArray$3(insightsEvents.map(function (event) {
        return _objectSpread$e(_objectSpread$e({}, event), {}, {
          algoliaSource: [].concat(_toConsumableArray$3(event.algoliaSource || []), ['autocomplete-internal'])
        });
      })));
    },
    onSelect: function onSelect(_ref9) {
      var insights = _ref9.insights,
        insightsEvents = _ref9.insightsEvents;
      insights.clickedObjectIDsAfterSearch.apply(insights, _toConsumableArray$3(insightsEvents.map(function (event) {
        return _objectSpread$e(_objectSpread$e({}, event), {}, {
          algoliaSource: [].concat(_toConsumableArray$3(event.algoliaSource || []), ['autocomplete-internal'])
        });
      })));
    },
    onActive: noop$2
  }, options);
}
function loadInsights(environment) {
  var errorMessage = "[Autocomplete]: Could not load search-insights.js. Please load it manually following https://alg.li/insights-autocomplete";
  try {
    var script = environment.document.createElement('script');
    script.async = true;
    script.src = ALGOLIA_INSIGHTS_SRC;
    script.onerror = function () {
      // eslint-disable-next-line no-console
      console.error(errorMessage);
    };
    document.body.appendChild(script);
  } catch (cause) {
    // eslint-disable-next-line no-console
    console.error(errorMessage);
  }
}

function checkOptions(options) {
  process.env.NODE_ENV !== 'production' ? warn(!options.debug, 'The `debug` option is meant for development debugging and should not be used in production.') : void 0;
}

function createInternalCancelablePromise(promise, initialState) {
  var state = initialState;
  return {
    then: function then(onfulfilled, onrejected) {
      return createInternalCancelablePromise(promise.then(createCallback(onfulfilled, state, promise), createCallback(onrejected, state, promise)), state);
    },
    catch: function _catch(onrejected) {
      return createInternalCancelablePromise(promise.catch(createCallback(onrejected, state, promise)), state);
    },
    finally: function _finally(onfinally) {
      if (onfinally) {
        state.onCancelList.push(onfinally);
      }
      return createInternalCancelablePromise(promise.finally(createCallback(onfinally && function () {
        state.onCancelList = [];
        return onfinally();
      }, state, promise)), state);
    },
    cancel: function cancel() {
      state.isCanceled = true;
      var callbacks = state.onCancelList;
      state.onCancelList = [];
      callbacks.forEach(function (callback) {
        callback();
      });
    },
    isCanceled: function isCanceled() {
      return state.isCanceled === true;
    }
  };
}
function cancelable(promise) {
  return createInternalCancelablePromise(promise, {
    isCanceled: false,
    onCancelList: []
  });
}
function createCallback(onResult, state, fallback) {
  if (!onResult) {
    return fallback;
  }
  return function callback(arg) {
    if (state.isCanceled) {
      return arg;
    }
    return onResult(arg);
  };
}

function createCancelablePromiseList() {
  var list = [];
  return {
    add: function add(cancelablePromise) {
      list.push(cancelablePromise);
      return cancelablePromise.finally(function () {
        list = list.filter(function (item) {
          return item !== cancelablePromise;
        });
      });
    },
    cancelAll: function cancelAll() {
      list.forEach(function (promise) {
        return promise.cancel();
      });
    },
    isEmpty: function isEmpty() {
      return list.length === 0;
    }
  };
}

/**
 * Creates a runner that executes promises in a concurrent-safe way.
 *
 * This is useful to prevent older promises to resolve after a newer promise,
 * otherwise resulting in stale resolved values.
 */
function createConcurrentSafePromise() {
  var basePromiseId = -1;
  var latestResolvedId = -1;
  var latestResolvedValue = undefined;
  return function runConcurrentSafePromise(promise) {
    basePromiseId++;
    var currentPromiseId = basePromiseId;
    return Promise.resolve(promise).then(function (x) {
      // The promise might take too long to resolve and get outdated. This would
      // result in resolving stale values.
      // When this happens, we ignore the promise value and return the one
      // coming from the latest resolved value.
      //
      // +----------------------------------+
      // |        100ms                     |
      // | run(1) +--->  R1                 |
      // |        300ms                     |
      // | run(2) +-------------> R2 (SKIP) |
      // |        200ms                     |
      // | run(3) +--------> R3             |
      // +----------------------------------+
      if (latestResolvedValue && currentPromiseId < latestResolvedId) {
        return latestResolvedValue;
      }
      latestResolvedId = currentPromiseId;
      latestResolvedValue = x;
      return x;
    });
  };
}

/**
 * Returns the next active item ID from the current state.
 *
 * We allow circular keyboard navigation from the base index.
 * The base index can either be `null` (nothing is highlighted) or `0`
 * (the first item is highlighted).
 * The base index is allowed to get assigned `null` only if
 * `props.defaultActiveItemId` is `null`. This pattern allows to "stop"
 * by the actual query before navigating to other suggestions as seen on
 * Google or Amazon.
 *
 * @param moveAmount The offset to increment (or decrement) the last index
 * @param baseIndex The current index to compute the next index from
 * @param itemCount The number of items
 * @param defaultActiveItemId The default active index to fallback to
 */
function getNextActiveItemId(moveAmount, baseIndex, itemCount, defaultActiveItemId) {
  if (!itemCount) {
    return null;
  }
  if (moveAmount < 0 && (baseIndex === null || defaultActiveItemId !== null && baseIndex === 0)) {
    return itemCount + moveAmount;
  }
  var numericIndex = (baseIndex === null ? -1 : baseIndex) + moveAmount;
  if (numericIndex <= -1 || numericIndex >= itemCount) {
    return defaultActiveItemId === null ? null : 0;
  }
  return numericIndex;
}

function ownKeys$d(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$d(Object(source), !0).forEach(function (key) {
      _defineProperty$e(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$e(obj, key, value) {
  key = _toPropertyKey$b(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$b(arg) {
  var key = _toPrimitive$b(arg, "string");
  return _typeof$b(key) === "symbol" ? key : String(key);
}
function _toPrimitive$b(input, hint) {
  if (_typeof$b(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$b(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _typeof$b(obj) {
  "@babel/helpers - typeof";

  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$b(obj);
}
function getNormalizedSources(getSources, params) {
  var seenSourceIds = [];
  return Promise.resolve(getSources(params)).then(function (sources) {
    invariant$1(Array.isArray(sources), function () {
      return "The `getSources` function must return an array of sources but returned type ".concat(JSON.stringify(_typeof$b(sources)), ":\n\n").concat(JSON.stringify(decycle(sources), null, 2));
    });
    return Promise.all(sources
    // We allow `undefined` and `false` sources to allow users to use
    // `Boolean(query) && source` (=> `false`).
    // We need to remove these values at this point.
    .filter(function (maybeSource) {
      return Boolean(maybeSource);
    }).map(function (source) {
      invariant$1(typeof source.sourceId === 'string', 'A source must provide a `sourceId` string.');
      if (seenSourceIds.includes(source.sourceId)) {
        throw new Error("[Autocomplete] The `sourceId` ".concat(JSON.stringify(source.sourceId), " is not unique."));
      }
      seenSourceIds.push(source.sourceId);
      var defaultSource = {
        getItemInputValue: function getItemInputValue(_ref) {
          var state = _ref.state;
          return state.query;
        },
        getItemUrl: function getItemUrl() {
          return undefined;
        },
        onSelect: function onSelect(_ref2) {
          var setIsOpen = _ref2.setIsOpen;
          setIsOpen(false);
        },
        onActive: noop$2,
        onResolve: noop$2
      };
      Object.keys(defaultSource).forEach(function (key) {
        defaultSource[key].__default = true;
      });
      var normalizedSource = _objectSpread$d(_objectSpread$d({}, defaultSource), source);
      return Promise.resolve(normalizedSource);
    }));
  });
}

// We don't have access to the autocomplete source when we call `onKeyDown`
// or `onClick` because those are native browser events.
// However, we can get the source from the suggestion index.
function getCollectionFromActiveItemId(state) {
  // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]
  // We want to get the accumulated counts:
  // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]
  var accumulatedCollectionsCount = state.collections.map(function (collections) {
    return collections.items.length;
  }).reduce(function (acc, collectionsCount, index) {
    var previousValue = acc[index - 1] || 0;
    var nextValue = previousValue + collectionsCount;
    acc.push(nextValue);
    return acc;
  }, []);

  // Based on the accumulated counts, we can infer the index of the suggestion.
  var collectionIndex = accumulatedCollectionsCount.reduce(function (acc, current) {
    if (current <= state.activeItemId) {
      return acc + 1;
    }
    return acc;
  }, 0);
  return state.collections[collectionIndex];
}

/**
 * Gets the highlighted index relative to a suggestion object (not the absolute
 * highlighted index).
 *
 * Example:
 *  [['a', 'b'], ['c', 'd', 'e'], ['f']]
 *                      ↑
 *         (absolute: 3, relative: 1)
 */
function getRelativeActiveItemId(_ref) {
  var state = _ref.state,
    collection = _ref.collection;
  var isOffsetFound = false;
  var counter = 0;
  var previousItemsOffset = 0;
  while (isOffsetFound === false) {
    var currentCollection = state.collections[counter];
    if (currentCollection === collection) {
      isOffsetFound = true;
      break;
    }
    previousItemsOffset += currentCollection.items.length;
    counter++;
  }
  return state.activeItemId - previousItemsOffset;
}
function getActiveItem(state) {
  var collection = getCollectionFromActiveItemId(state);
  if (!collection) {
    return null;
  }
  var item = collection.items[getRelativeActiveItemId({
    state: state,
    collection: collection
  })];
  var source = collection.source;
  var itemInputValue = source.getItemInputValue({
    item: item,
    state: state
  });
  var itemUrl = source.getItemUrl({
    item: item,
    state: state
  });
  return {
    item: item,
    itemInputValue: itemInputValue,
    itemUrl: itemUrl,
    source: source
  };
}

function isOrContainsNode$1(parent, child) {
  return parent === child || parent.contains(child);
}

var regex = /((gt|sm)-|galaxy nexus)|samsung[- ]|samsungbrowser/i;
function isSamsung(userAgent) {
  return Boolean(userAgent && userAgent.match(regex));
}

function mapToAlgoliaResponse(rawResults) {
  return {
    results: rawResults,
    hits: rawResults.map(function (result) {
      return result.hits;
    }).filter(Boolean),
    facetHits: rawResults.map(function (result) {
      var _facetHits;
      return (_facetHits = result.facetHits) === null || _facetHits === void 0 ? void 0 : _facetHits.map(function (facetHit) {
        // Bring support for the highlighting components.
        return {
          label: facetHit.value,
          count: facetHit.count,
          _highlightResult: {
            label: {
              value: facetHit.highlighted
            }
          }
        };
      });
    }).filter(Boolean)
  };
}

function _typeof$a(obj) {
  "@babel/helpers - typeof";

  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$a(obj);
}
function ownKeys$c(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$c(Object(source), !0).forEach(function (key) {
      _defineProperty$d(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$d(obj, key, value) {
  key = _toPropertyKey$a(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$a(arg) {
  var key = _toPrimitive$a(arg, "string");
  return _typeof$a(key) === "symbol" ? key : String(key);
}
function _toPrimitive$a(input, hint) {
  if (_typeof$a(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$a(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function createStore(reducer, props, onStoreStateChange) {
  var state = props.initialState;
  return {
    getState: function getState() {
      return state;
    },
    dispatch: function dispatch(action, payload) {
      var prevState = _objectSpread$c({}, state);
      state = reducer(state, {
        type: action,
        props: props,
        payload: payload
      });
      onStoreStateChange({
        state: state,
        prevState: prevState
      });
    },
    pendingRequests: createCancelablePromiseList()
  };
}

function _typeof$9(obj) {
  "@babel/helpers - typeof";

  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$9(obj);
}
function ownKeys$b(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$b(Object(source), !0).forEach(function (key) {
      _defineProperty$c(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$c(obj, key, value) {
  key = _toPropertyKey$9(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$9(arg) {
  var key = _toPrimitive$9(arg, "string");
  return _typeof$9(key) === "symbol" ? key : String(key);
}
function _toPrimitive$9(input, hint) {
  if (_typeof$9(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$9(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function getAutocompleteSetters(_ref) {
  var store = _ref.store;
  var setActiveItemId = function setActiveItemId(value) {
    store.dispatch('setActiveItemId', value);
  };
  var setQuery = function setQuery(value) {
    store.dispatch('setQuery', value);
  };
  var setCollections = function setCollections(rawValue) {
    var baseItemId = 0;
    var value = rawValue.map(function (collection) {
      return _objectSpread$b(_objectSpread$b({}, collection), {}, {
        // We flatten the stored items to support calling `getAlgoliaResults`
        // from the source itself.
        items: flatten(collection.items).map(function (item) {
          return _objectSpread$b(_objectSpread$b({}, item), {}, {
            __autocomplete_id: baseItemId++
          });
        })
      });
    });
    store.dispatch('setCollections', value);
  };
  var setIsOpen = function setIsOpen(value) {
    store.dispatch('setIsOpen', value);
  };
  var setStatus = function setStatus(value) {
    store.dispatch('setStatus', value);
  };
  var setContext = function setContext(value) {
    store.dispatch('setContext', value);
  };
  return {
    setActiveItemId: setActiveItemId,
    setQuery: setQuery,
    setCollections: setCollections,
    setIsOpen: setIsOpen,
    setStatus: setStatus,
    setContext: setContext
  };
}

function _typeof$8(obj) {
  "@babel/helpers - typeof";

  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$8(obj);
}
function _toConsumableArray$2(arr) {
  return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$6(arr) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
}
function _iterableToArray$2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$2(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$6(arr);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys$a(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$a(Object(source), !0).forEach(function (key) {
      _defineProperty$b(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$b(obj, key, value) {
  key = _toPropertyKey$8(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$8(arg) {
  var key = _toPrimitive$8(arg, "string");
  return _typeof$8(key) === "symbol" ? key : String(key);
}
function _toPrimitive$8(input, hint) {
  if (_typeof$8(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$8(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function getDefaultProps(props, pluginSubscribers) {
  var _props$id;
  /* eslint-disable no-restricted-globals */
  var environment = typeof window !== 'undefined' ? window : {};
  /* eslint-enable no-restricted-globals */
  var plugins = props.plugins || [];
  return _objectSpread$a(_objectSpread$a({
    debug: false,
    openOnFocus: false,
    placeholder: '',
    autoFocus: false,
    defaultActiveItemId: null,
    stallThreshold: 300,
    insights: false,
    environment: environment,
    shouldPanelOpen: function shouldPanelOpen(_ref) {
      var state = _ref.state;
      return getItemsCount(state) > 0;
    },
    reshape: function reshape(_ref2) {
      var sources = _ref2.sources;
      return sources;
    }
  }, props), {}, {
    // Since `generateAutocompleteId` triggers a side effect (it increments
    // an internal counter), we don't want to execute it if unnecessary.
    id: (_props$id = props.id) !== null && _props$id !== void 0 ? _props$id : generateAutocompleteId(),
    plugins: plugins,
    // The following props need to be deeply defaulted.
    initialState: _objectSpread$a({
      activeItemId: null,
      query: '',
      completion: null,
      collections: [],
      isOpen: false,
      status: 'idle',
      context: {}
    }, props.initialState),
    onStateChange: function onStateChange(params) {
      var _props$onStateChange;
      (_props$onStateChange = props.onStateChange) === null || _props$onStateChange === void 0 ? void 0 : _props$onStateChange.call(props, params);
      plugins.forEach(function (x) {
        var _x$onStateChange;
        return (_x$onStateChange = x.onStateChange) === null || _x$onStateChange === void 0 ? void 0 : _x$onStateChange.call(x, params);
      });
    },
    onSubmit: function onSubmit(params) {
      var _props$onSubmit;
      (_props$onSubmit = props.onSubmit) === null || _props$onSubmit === void 0 ? void 0 : _props$onSubmit.call(props, params);
      plugins.forEach(function (x) {
        var _x$onSubmit;
        return (_x$onSubmit = x.onSubmit) === null || _x$onSubmit === void 0 ? void 0 : _x$onSubmit.call(x, params);
      });
    },
    onReset: function onReset(params) {
      var _props$onReset;
      (_props$onReset = props.onReset) === null || _props$onReset === void 0 ? void 0 : _props$onReset.call(props, params);
      plugins.forEach(function (x) {
        var _x$onReset;
        return (_x$onReset = x.onReset) === null || _x$onReset === void 0 ? void 0 : _x$onReset.call(x, params);
      });
    },
    getSources: function getSources(params) {
      return Promise.all([].concat(_toConsumableArray$2(plugins.map(function (plugin) {
        return plugin.getSources;
      })), [props.getSources]).filter(Boolean).map(function (getSources) {
        return getNormalizedSources(getSources, params);
      })).then(function (nested) {
        return flatten(nested);
      }).then(function (sources) {
        return sources.map(function (source) {
          return _objectSpread$a(_objectSpread$a({}, source), {}, {
            onSelect: function onSelect(params) {
              source.onSelect(params);
              pluginSubscribers.forEach(function (x) {
                var _x$onSelect;
                return (_x$onSelect = x.onSelect) === null || _x$onSelect === void 0 ? void 0 : _x$onSelect.call(x, params);
              });
            },
            onActive: function onActive(params) {
              source.onActive(params);
              pluginSubscribers.forEach(function (x) {
                var _x$onActive;
                return (_x$onActive = x.onActive) === null || _x$onActive === void 0 ? void 0 : _x$onActive.call(x, params);
              });
            },
            onResolve: function onResolve(params) {
              source.onResolve(params);
              pluginSubscribers.forEach(function (x) {
                var _x$onResolve;
                return (_x$onResolve = x.onResolve) === null || _x$onResolve === void 0 ? void 0 : _x$onResolve.call(x, params);
              });
            }
          });
        });
      });
    },
    navigator: _objectSpread$a({
      navigate: function navigate(_ref3) {
        var itemUrl = _ref3.itemUrl;
        environment.location.assign(itemUrl);
      },
      navigateNewTab: function navigateNewTab(_ref4) {
        var itemUrl = _ref4.itemUrl;
        var windowReference = environment.open(itemUrl, '_blank', 'noopener');
        windowReference === null || windowReference === void 0 ? void 0 : windowReference.focus();
      },
      navigateNewWindow: function navigateNewWindow(_ref5) {
        var itemUrl = _ref5.itemUrl;
        environment.open(itemUrl, '_blank', 'noopener');
      }
    }, props.navigator)
  });
}

function _typeof$7(obj) {
  "@babel/helpers - typeof";

  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$7(obj);
}
function ownKeys$9(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$9(Object(source), !0).forEach(function (key) {
      _defineProperty$a(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$a(obj, key, value) {
  key = _toPropertyKey$7(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$7(arg) {
  var key = _toPrimitive$7(arg, "string");
  return _typeof$7(key) === "symbol" ? key : String(key);
}
function _toPrimitive$7(input, hint) {
  if (_typeof$7(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$7(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function reshape(_ref) {
  var collections = _ref.collections,
    props = _ref.props,
    state = _ref.state;
  // Sources are grouped by `sourceId` to conveniently pick them via destructuring.
  // Example: `const { recentSearchesPlugin } = sourcesBySourceId`
  var originalSourcesBySourceId = collections.reduce(function (acc, collection) {
    return _objectSpread$9(_objectSpread$9({}, acc), {}, _defineProperty$a({}, collection.source.sourceId, _objectSpread$9(_objectSpread$9({}, collection.source), {}, {
      getItems: function getItems() {
        // We provide the resolved items from the collection to the `reshape` prop.
        return flatten(collection.items);
      }
    })));
  }, {});
  var _props$plugins$reduce = props.plugins.reduce(function (acc, plugin) {
      if (plugin.reshape) {
        return plugin.reshape(acc);
      }
      return acc;
    }, {
      sourcesBySourceId: originalSourcesBySourceId,
      state: state
    }),
    sourcesBySourceId = _props$plugins$reduce.sourcesBySourceId;
  var reshapeSources = props.reshape({
    sourcesBySourceId: sourcesBySourceId,
    sources: Object.values(sourcesBySourceId),
    state: state
  });

  // We reconstruct the collections with the items modified by the `reshape` prop.
  return flatten(reshapeSources).filter(Boolean).map(function (source) {
    return {
      source: source,
      items: source.getItems()
    };
  });
}

function _typeof$6(obj) {
  "@babel/helpers - typeof";

  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$6(obj);
}
function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$8(Object(source), !0).forEach(function (key) {
      _defineProperty$9(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$9(obj, key, value) {
  key = _toPropertyKey$6(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$6(arg) {
  var key = _toPrimitive$6(arg, "string");
  return _typeof$6(key) === "symbol" ? key : String(key);
}
function _toPrimitive$6(input, hint) {
  if (_typeof$6(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$6(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$5(arr);
}
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function isDescription(item) {
  return Boolean(item.execute);
}
function isRequesterDescription(description) {
  return Boolean(description === null || description === void 0 ? void 0 : description.execute);
}
function preResolve(itemsOrDescription, sourceId, state) {
  if (isRequesterDescription(itemsOrDescription)) {
    var contextParameters = itemsOrDescription.requesterId === 'algolia' ? Object.assign.apply(Object, [{}].concat(_toConsumableArray$1(Object.keys(state.context).map(function (key) {
      var _state$context$key;
      return (_state$context$key = state.context[key]) === null || _state$context$key === void 0 ? void 0 : _state$context$key.__algoliaSearchParameters;
    })))) : {};
    return _objectSpread$8(_objectSpread$8({}, itemsOrDescription), {}, {
      requests: itemsOrDescription.queries.map(function (query) {
        return {
          query: itemsOrDescription.requesterId === 'algolia' ? _objectSpread$8(_objectSpread$8({}, query), {}, {
            params: _objectSpread$8(_objectSpread$8({}, contextParameters), query.params)
          }) : query,
          sourceId: sourceId,
          transformResponse: itemsOrDescription.transformResponse
        };
      })
    });
  }
  return {
    items: itemsOrDescription,
    sourceId: sourceId
  };
}
function resolve$2(items) {
  var packed = items.reduce(function (acc, current) {
    if (!isDescription(current)) {
      acc.push(current);
      return acc;
    }
    var searchClient = current.searchClient,
      execute = current.execute,
      requesterId = current.requesterId,
      requests = current.requests;
    var container = acc.find(function (item) {
      return isDescription(current) && isDescription(item) && item.searchClient === searchClient && Boolean(requesterId) && item.requesterId === requesterId;
    });
    if (container) {
      var _container$items;
      (_container$items = container.items).push.apply(_container$items, _toConsumableArray$1(requests));
    } else {
      var request = {
        execute: execute,
        requesterId: requesterId,
        items: requests,
        searchClient: searchClient
      };
      acc.push(request);
    }
    return acc;
  }, []);
  var values = packed.map(function (maybeDescription) {
    if (!isDescription(maybeDescription)) {
      return Promise.resolve(maybeDescription);
    }
    var _ref = maybeDescription,
      execute = _ref.execute,
      items = _ref.items,
      searchClient = _ref.searchClient;
    return execute({
      searchClient: searchClient,
      requests: items
    });
  });
  return Promise.all(values).then(function (responses) {
    return flatten(responses);
  });
}
function postResolve(responses, sources, store) {
  return sources.map(function (source) {
    var matches = responses.filter(function (response) {
      return response.sourceId === source.sourceId;
    });
    var results = matches.map(function (_ref2) {
      var items = _ref2.items;
      return items;
    });
    var transform = matches[0].transformResponse;
    var items = transform ? transform(mapToAlgoliaResponse(results)) : results;
    source.onResolve({
      source: source,
      results: results,
      items: items,
      state: store.getState()
    });
    invariant$1(Array.isArray(items), function () {
      return "The `getItems` function from source \"".concat(source.sourceId, "\" must return an array of items but returned type ").concat(JSON.stringify(_typeof$6(items)), ":\n\n").concat(JSON.stringify(decycle(items), null, 2), ".\n\nSee: https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/sources/#param-getitems");
    });
    invariant$1(items.every(Boolean), "The `getItems` function from source \"".concat(source.sourceId, "\" must return an array of items but returned ").concat(JSON.stringify(undefined), ".\n\nDid you forget to return items?\n\nSee: https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/sources/#param-getitems"));
    return {
      source: source,
      items: items
    };
  });
}

function _typeof$5(obj) {
  "@babel/helpers - typeof";

  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$5(obj);
}
var _excluded$9 = ["event", "nextState", "props", "query", "refresh", "store"];
function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), !0).forEach(function (key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$8(obj, key, value) {
  key = _toPropertyKey$5(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$5(arg) {
  var key = _toPrimitive$5(arg, "string");
  return _typeof$5(key) === "symbol" ? key : String(key);
}
function _toPrimitive$5(input, hint) {
  if (_typeof$5(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$5(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _objectWithoutProperties$9(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$9(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$9(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var lastStalledId = null;
var runConcurrentSafePromise = createConcurrentSafePromise();
function onInput(_ref) {
  var event = _ref.event,
    _ref$nextState = _ref.nextState,
    nextState = _ref$nextState === void 0 ? {} : _ref$nextState,
    props = _ref.props,
    query = _ref.query,
    refresh = _ref.refresh,
    store = _ref.store,
    setters = _objectWithoutProperties$9(_ref, _excluded$9);
  if (lastStalledId) {
    props.environment.clearTimeout(lastStalledId);
  }
  var setCollections = setters.setCollections,
    setIsOpen = setters.setIsOpen,
    setQuery = setters.setQuery,
    setActiveItemId = setters.setActiveItemId,
    setStatus = setters.setStatus;
  setQuery(query);
  setActiveItemId(props.defaultActiveItemId);
  if (!query && props.openOnFocus === false) {
    var _nextState$isOpen;
    var collections = store.getState().collections.map(function (collection) {
      return _objectSpread$7(_objectSpread$7({}, collection), {}, {
        items: []
      });
    });
    setStatus('idle');
    setCollections(collections);
    setIsOpen((_nextState$isOpen = nextState.isOpen) !== null && _nextState$isOpen !== void 0 ? _nextState$isOpen : props.shouldPanelOpen({
      state: store.getState()
    }));

    // We make sure to update the latest resolved value of the tracked
    // promises to keep late resolving promises from "cancelling" the state
    // updates performed in this code path.
    // We chain with a void promise to respect `onInput`'s expected return type.
    var _request = cancelable(runConcurrentSafePromise(collections).then(function () {
      return Promise.resolve();
    }));
    return store.pendingRequests.add(_request);
  }
  setStatus('loading');
  lastStalledId = props.environment.setTimeout(function () {
    setStatus('stalled');
  }, props.stallThreshold);

  // We track the entire promise chain triggered by `onInput` before mutating
  // the Autocomplete state to make sure that any state manipulation is based on
  // fresh data regardless of when promises individually resolve.
  // We don't track nested promises and only rely on the full chain resolution,
  // meaning we should only ever manipulate the state once this concurrent-safe
  // promise is resolved.
  var request = cancelable(runConcurrentSafePromise(props.getSources(_objectSpread$7({
    query: query,
    refresh: refresh,
    state: store.getState()
  }, setters)).then(function (sources) {
    return Promise.all(sources.map(function (source) {
      return Promise.resolve(source.getItems(_objectSpread$7({
        query: query,
        refresh: refresh,
        state: store.getState()
      }, setters))).then(function (itemsOrDescription) {
        return preResolve(itemsOrDescription, source.sourceId, store.getState());
      });
    })).then(resolve$2).then(function (responses) {
      return postResolve(responses, sources, store);
    }).then(function (collections) {
      return reshape({
        collections: collections,
        props: props,
        state: store.getState()
      });
    });
  }))).then(function (collections) {
    var _nextState$isOpen2;
    // Parameters passed to `onInput` could be stale when the following code
    // executes, because `onInput` calls may not resolve in order.
    // If it becomes a problem we'll need to save the last passed parameters.
    // See: https://codesandbox.io/s/agitated-cookies-y290z

    setStatus('idle');
    setCollections(collections);
    var isPanelOpen = props.shouldPanelOpen({
      state: store.getState()
    });
    setIsOpen((_nextState$isOpen2 = nextState.isOpen) !== null && _nextState$isOpen2 !== void 0 ? _nextState$isOpen2 : props.openOnFocus && !query && isPanelOpen || isPanelOpen);
    var highlightedItem = getActiveItem(store.getState());
    if (store.getState().activeItemId !== null && highlightedItem) {
      var item = highlightedItem.item,
        itemInputValue = highlightedItem.itemInputValue,
        itemUrl = highlightedItem.itemUrl,
        source = highlightedItem.source;
      source.onActive(_objectSpread$7({
        event: event,
        item: item,
        itemInputValue: itemInputValue,
        itemUrl: itemUrl,
        refresh: refresh,
        source: source,
        state: store.getState()
      }, setters));
    }
  }).finally(function () {
    setStatus('idle');
    if (lastStalledId) {
      props.environment.clearTimeout(lastStalledId);
    }
  });
  return store.pendingRequests.add(request);
}

function _typeof$4(obj) {
  "@babel/helpers - typeof";

  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$4(obj);
}
var _excluded$8 = ["event", "props", "refresh", "store"];
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) {
      _defineProperty$7(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$7(obj, key, value) {
  key = _toPropertyKey$4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$4(arg) {
  var key = _toPrimitive$4(arg, "string");
  return _typeof$4(key) === "symbol" ? key : String(key);
}
function _toPrimitive$4(input, hint) {
  if (_typeof$4(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$4(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _objectWithoutProperties$8(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$8(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function onKeyDown(_ref) {
  var event = _ref.event,
    props = _ref.props,
    refresh = _ref.refresh,
    store = _ref.store,
    setters = _objectWithoutProperties$8(_ref, _excluded$8);
  if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
    // eslint-disable-next-line no-inner-declarations
    var triggerScrollIntoView = function triggerScrollIntoView() {
      var nodeItem = props.environment.document.getElementById("".concat(props.id, "-item-").concat(store.getState().activeItemId));
      if (nodeItem) {
        if (nodeItem.scrollIntoViewIfNeeded) {
          nodeItem.scrollIntoViewIfNeeded(false);
        } else {
          nodeItem.scrollIntoView(false);
        }
      }
    }; // eslint-disable-next-line no-inner-declarations
    var triggerOnActive = function triggerOnActive() {
      var highlightedItem = getActiveItem(store.getState());
      if (store.getState().activeItemId !== null && highlightedItem) {
        var item = highlightedItem.item,
          itemInputValue = highlightedItem.itemInputValue,
          itemUrl = highlightedItem.itemUrl,
          source = highlightedItem.source;
        source.onActive(_objectSpread$6({
          event: event,
          item: item,
          itemInputValue: itemInputValue,
          itemUrl: itemUrl,
          refresh: refresh,
          source: source,
          state: store.getState()
        }, setters));
      }
    }; // Default browser behavior changes the caret placement on ArrowUp and
    // ArrowDown.
    event.preventDefault();

    // When re-opening the panel, we need to split the logic to keep the actions
    // synchronized as `onInput` returns a promise.
    if (store.getState().isOpen === false && (props.openOnFocus || Boolean(store.getState().query))) {
      onInput(_objectSpread$6({
        event: event,
        props: props,
        query: store.getState().query,
        refresh: refresh,
        store: store
      }, setters)).then(function () {
        store.dispatch(event.key, {
          nextActiveItemId: props.defaultActiveItemId
        });
        triggerOnActive();
        // Since we rely on the DOM, we need to wait for all the micro tasks to
        // finish (which include re-opening the panel) to make sure all the
        // elements are available.
        setTimeout(triggerScrollIntoView, 0);
      });
    } else {
      store.dispatch(event.key, {});
      triggerOnActive();
      triggerScrollIntoView();
    }
  } else if (event.key === 'Escape') {
    // This prevents the default browser behavior on `input[type="search"]`
    // from removing the query right away because we first want to close the
    // panel.
    event.preventDefault();
    store.dispatch(event.key, null);

    // Hitting the `Escape` key signals the end of a user interaction with the
    // autocomplete. At this point, we should ignore any requests that are still
    // pending and could reopen the panel once they resolve, because that would
    // result in an unsolicited UI behavior.
    store.pendingRequests.cancelAll();
  } else if (event.key === 'Tab') {
    store.dispatch('blur', null);

    // Hitting the `Escape` key signals the end of a user interaction with the
    // autocomplete. At this point, we should ignore any requests that are still
    // pending and could reopen the panel once they resolve, because that would
    // result in an unsolicited UI behavior.
    store.pendingRequests.cancelAll();
  } else if (event.key === 'Enter') {
    // No active item, so we let the browser handle the native `onSubmit` form
    // event.
    if (store.getState().activeItemId === null || store.getState().collections.every(function (collection) {
      return collection.items.length === 0;
    })) {
      // If requests are still pending when the panel closes, they could reopen
      // the panel once they resolve.
      // We want to prevent any subsequent query from reopening the panel
      // because it would result in an unsolicited UI behavior.
      if (!props.debug) {
        store.pendingRequests.cancelAll();
      }
      return;
    }

    // This prevents the `onSubmit` event to be sent because an item is
    // highlighted.
    event.preventDefault();
    var _ref2 = getActiveItem(store.getState()),
      item = _ref2.item,
      itemInputValue = _ref2.itemInputValue,
      itemUrl = _ref2.itemUrl,
      source = _ref2.source;
    if (event.metaKey || event.ctrlKey) {
      if (itemUrl !== undefined) {
        source.onSelect(_objectSpread$6({
          event: event,
          item: item,
          itemInputValue: itemInputValue,
          itemUrl: itemUrl,
          refresh: refresh,
          source: source,
          state: store.getState()
        }, setters));
        props.navigator.navigateNewTab({
          itemUrl: itemUrl,
          item: item,
          state: store.getState()
        });
      }
    } else if (event.shiftKey) {
      if (itemUrl !== undefined) {
        source.onSelect(_objectSpread$6({
          event: event,
          item: item,
          itemInputValue: itemInputValue,
          itemUrl: itemUrl,
          refresh: refresh,
          source: source,
          state: store.getState()
        }, setters));
        props.navigator.navigateNewWindow({
          itemUrl: itemUrl,
          item: item,
          state: store.getState()
        });
      }
    } else if (event.altKey) ; else {
      if (itemUrl !== undefined) {
        source.onSelect(_objectSpread$6({
          event: event,
          item: item,
          itemInputValue: itemInputValue,
          itemUrl: itemUrl,
          refresh: refresh,
          source: source,
          state: store.getState()
        }, setters));
        props.navigator.navigate({
          itemUrl: itemUrl,
          item: item,
          state: store.getState()
        });
        return;
      }
      onInput(_objectSpread$6({
        event: event,
        nextState: {
          isOpen: false
        },
        props: props,
        query: itemInputValue,
        refresh: refresh,
        store: store
      }, setters)).then(function () {
        source.onSelect(_objectSpread$6({
          event: event,
          item: item,
          itemInputValue: itemInputValue,
          itemUrl: itemUrl,
          refresh: refresh,
          source: source,
          state: store.getState()
        }, setters));
      });
    }
  }
}

function _typeof$3(obj) {
  "@babel/helpers - typeof";

  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$3(obj);
}
var _excluded$7 = ["props", "refresh", "store"],
  _excluded2 = ["inputElement", "formElement", "panelElement"],
  _excluded3 = ["inputElement"],
  _excluded4 = ["inputElement", "maxLength"],
  _excluded5 = ["sourceIndex"],
  _excluded6 = ["sourceIndex"],
  _excluded7 = ["item", "source", "sourceIndex"];
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$6(obj, key, value) {
  key = _toPropertyKey$3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$3(arg) {
  var key = _toPrimitive$3(arg, "string");
  return _typeof$3(key) === "symbol" ? key : String(key);
}
function _toPrimitive$3(input, hint) {
  if (_typeof$3(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$3(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _objectWithoutProperties$7(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$7(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function getPropGetters(_ref) {
  var props = _ref.props,
    refresh = _ref.refresh,
    store = _ref.store,
    setters = _objectWithoutProperties$7(_ref, _excluded$7);
  var getEnvironmentProps = function getEnvironmentProps(providedProps) {
    var inputElement = providedProps.inputElement,
      formElement = providedProps.formElement,
      panelElement = providedProps.panelElement,
      rest = _objectWithoutProperties$7(providedProps, _excluded2);
    function onMouseDownOrTouchStart(event) {
      // The `onTouchStart`/`onMouseDown` events shouldn't trigger the `blur`
      // handler when it's not an interaction with Autocomplete.
      // We detect it with the following heuristics:
      // - the panel is closed AND there are no pending requests
      //   (no interaction with the autocomplete, no future state updates)
      // - OR the touched target is the input element (should open the panel)
      var isAutocompleteInteraction = store.getState().isOpen || !store.pendingRequests.isEmpty();
      if (!isAutocompleteInteraction || event.target === inputElement) {
        return;
      }

      // @TODO: support cases where there are multiple Autocomplete instances.
      // Right now, a second instance makes this computation return false.
      var isTargetWithinAutocomplete = [formElement, panelElement].some(function (contextNode) {
        return isOrContainsNode$1(contextNode, event.target);
      });
      if (isTargetWithinAutocomplete === false) {
        store.dispatch('blur', null);

        // If requests are still pending when the user closes the panel, they
        // could reopen the panel once they resolve.
        // We want to prevent any subsequent query from reopening the panel
        // because it would result in an unsolicited UI behavior.
        if (!props.debug) {
          store.pendingRequests.cancelAll();
        }
      }
    }
    return _objectSpread$5({
      // We do not rely on the native `blur` event of the input to close the
      // panel, but rather on a custom `touchstart`/`mousedown` event outside
      // of the autocomplete elements.
      // This ensures we don't mistakenly interpret interactions within the
      // autocomplete (but outside of the input) as a signal to close the panel.
      // For example, clicking reset button causes an input blur, but if
      // `openOnFocus=true`, it shouldn't close the panel.
      // On touch devices, scrolling results (`touchmove`) causes an input blur
      // but shouldn't close the panel.
      onTouchStart: onMouseDownOrTouchStart,
      onMouseDown: onMouseDownOrTouchStart,
      // When scrolling on touch devices (mobiles, tablets, etc.), we want to
      // mimic the native platform behavior where the input is blurred to
      // hide the virtual keyboard. This gives more vertical space to
      // discover all the suggestions showing up in the panel.
      onTouchMove: function onTouchMove(event) {
        if (store.getState().isOpen === false || inputElement !== props.environment.document.activeElement || event.target === inputElement) {
          return;
        }
        inputElement.blur();
      }
    }, rest);
  };
  var getRootProps = function getRootProps(rest) {
    return _objectSpread$5({
      role: 'combobox',
      'aria-expanded': store.getState().isOpen,
      'aria-haspopup': 'listbox',
      'aria-owns': store.getState().isOpen ? "".concat(props.id, "-list") : undefined,
      'aria-labelledby': "".concat(props.id, "-label")
    }, rest);
  };
  var getFormProps = function getFormProps(providedProps) {
    providedProps.inputElement;
      var rest = _objectWithoutProperties$7(providedProps, _excluded3);
    return _objectSpread$5({
      action: '',
      noValidate: true,
      role: 'search',
      onSubmit: function onSubmit(event) {
        var _providedProps$inputE;
        event.preventDefault();
        props.onSubmit(_objectSpread$5({
          event: event,
          refresh: refresh,
          state: store.getState()
        }, setters));
        store.dispatch('submit', null);
        (_providedProps$inputE = providedProps.inputElement) === null || _providedProps$inputE === void 0 ? void 0 : _providedProps$inputE.blur();
      },
      onReset: function onReset(event) {
        var _providedProps$inputE2;
        event.preventDefault();
        props.onReset(_objectSpread$5({
          event: event,
          refresh: refresh,
          state: store.getState()
        }, setters));
        store.dispatch('reset', null);
        (_providedProps$inputE2 = providedProps.inputElement) === null || _providedProps$inputE2 === void 0 ? void 0 : _providedProps$inputE2.focus();
      }
    }, rest);
  };
  var getInputProps = function getInputProps(providedProps) {
    var _props$environment$na;
    function onFocus(event) {
      // We want to trigger a query when `openOnFocus` is true
      // because the panel should open with the current query.
      if (props.openOnFocus || Boolean(store.getState().query)) {
        onInput(_objectSpread$5({
          event: event,
          props: props,
          query: store.getState().completion || store.getState().query,
          refresh: refresh,
          store: store
        }, setters));
      }
      store.dispatch('focus', null);
    }
    var _ref2 = providedProps || {};
      _ref2.inputElement;
      var _ref2$maxLength = _ref2.maxLength,
      maxLength = _ref2$maxLength === void 0 ? 512 : _ref2$maxLength,
      rest = _objectWithoutProperties$7(_ref2, _excluded4);
    var activeItem = getActiveItem(store.getState());
    var userAgent = ((_props$environment$na = props.environment.navigator) === null || _props$environment$na === void 0 ? void 0 : _props$environment$na.userAgent) || '';
    var shouldFallbackKeyHint = isSamsung(userAgent);
    var enterKeyHint = activeItem !== null && activeItem !== void 0 && activeItem.itemUrl && !shouldFallbackKeyHint ? 'go' : 'search';
    return _objectSpread$5({
      'aria-autocomplete': 'both',
      'aria-activedescendant': store.getState().isOpen && store.getState().activeItemId !== null ? "".concat(props.id, "-item-").concat(store.getState().activeItemId) : undefined,
      'aria-controls': store.getState().isOpen ? "".concat(props.id, "-list") : undefined,
      'aria-labelledby': "".concat(props.id, "-label"),
      value: store.getState().completion || store.getState().query,
      id: "".concat(props.id, "-input"),
      autoComplete: 'off',
      autoCorrect: 'off',
      autoCapitalize: 'off',
      enterKeyHint: enterKeyHint,
      spellCheck: 'false',
      autoFocus: props.autoFocus,
      placeholder: props.placeholder,
      maxLength: maxLength,
      type: 'search',
      onChange: function onChange(event) {
        onInput(_objectSpread$5({
          event: event,
          props: props,
          query: event.currentTarget.value.slice(0, maxLength),
          refresh: refresh,
          store: store
        }, setters));
      },
      onKeyDown: function onKeyDown$1(event) {
        onKeyDown(_objectSpread$5({
          event: event,
          props: props,
          refresh: refresh,
          store: store
        }, setters));
      },
      onFocus: onFocus,
      // We don't rely on the `blur` event.
      // See explanation in `onTouchStart`/`onMouseDown`.
      // @MAJOR See if we need to keep this handler.
      onBlur: noop$2,
      onClick: function onClick(event) {
        // When the panel is closed and you click on the input while
        // the input is focused, the `onFocus` event is not triggered
        // (default browser behavior).
        // In an autocomplete context, it makes sense to open the panel in this
        // case.
        // We mimic this event by catching the `onClick` event which
        // triggers the `onFocus` for the panel to open.
        if (providedProps.inputElement === props.environment.document.activeElement && !store.getState().isOpen) {
          onFocus(event);
        }
      }
    }, rest);
  };
  var getAutocompleteId = function getAutocompleteId(instanceId, sourceId) {
    return typeof sourceId !== 'undefined' ? "".concat(instanceId, "-").concat(sourceId) : instanceId;
  };
  var getLabelProps = function getLabelProps(providedProps) {
    var _ref3 = providedProps || {},
      sourceIndex = _ref3.sourceIndex,
      rest = _objectWithoutProperties$7(_ref3, _excluded5);
    return _objectSpread$5({
      htmlFor: "".concat(getAutocompleteId(props.id, sourceIndex), "-input"),
      id: "".concat(getAutocompleteId(props.id, sourceIndex), "-label")
    }, rest);
  };
  var getListProps = function getListProps(providedProps) {
    var _ref4 = providedProps || {},
      sourceIndex = _ref4.sourceIndex,
      rest = _objectWithoutProperties$7(_ref4, _excluded6);
    return _objectSpread$5({
      role: 'listbox',
      'aria-labelledby': "".concat(getAutocompleteId(props.id, sourceIndex), "-label"),
      id: "".concat(getAutocompleteId(props.id, sourceIndex), "-list")
    }, rest);
  };
  var getPanelProps = function getPanelProps(rest) {
    return _objectSpread$5({
      onMouseDown: function onMouseDown(event) {
        // Prevents the `activeElement` from being changed to the panel so
        // that the blur event is not triggered, otherwise it closes the
        // panel.
        event.preventDefault();
      },
      onMouseLeave: function onMouseLeave() {
        store.dispatch('mouseleave', null);
      }
    }, rest);
  };
  var getItemProps = function getItemProps(providedProps) {
    var item = providedProps.item,
      source = providedProps.source,
      sourceIndex = providedProps.sourceIndex,
      rest = _objectWithoutProperties$7(providedProps, _excluded7);
    return _objectSpread$5({
      id: "".concat(getAutocompleteId(props.id, sourceIndex), "-item-").concat(item.__autocomplete_id),
      role: 'option',
      'aria-selected': store.getState().activeItemId === item.__autocomplete_id,
      onMouseMove: function onMouseMove(event) {
        if (item.__autocomplete_id === store.getState().activeItemId) {
          return;
        }
        store.dispatch('mousemove', item.__autocomplete_id);
        var activeItem = getActiveItem(store.getState());
        if (store.getState().activeItemId !== null && activeItem) {
          var _item = activeItem.item,
            itemInputValue = activeItem.itemInputValue,
            itemUrl = activeItem.itemUrl,
            _source = activeItem.source;
          _source.onActive(_objectSpread$5({
            event: event,
            item: _item,
            itemInputValue: itemInputValue,
            itemUrl: itemUrl,
            refresh: refresh,
            source: _source,
            state: store.getState()
          }, setters));
        }
      },
      onMouseDown: function onMouseDown(event) {
        // Prevents the `activeElement` from being changed to the item so it
        // can remain with the current `activeElement`.
        event.preventDefault();
      },
      onClick: function onClick(event) {
        var itemInputValue = source.getItemInputValue({
          item: item,
          state: store.getState()
        });
        var itemUrl = source.getItemUrl({
          item: item,
          state: store.getState()
        });

        // If `getItemUrl` is provided, it means that the suggestion
        // is a link, not plain text that aims at updating the query.
        // We can therefore skip the state change because it will update
        // the `activeItemId`, resulting in a UI flash, especially
        // noticeable on mobile.
        var runPreCommand = itemUrl ? Promise.resolve() : onInput(_objectSpread$5({
          event: event,
          nextState: {
            isOpen: false
          },
          props: props,
          query: itemInputValue,
          refresh: refresh,
          store: store
        }, setters));
        runPreCommand.then(function () {
          source.onSelect(_objectSpread$5({
            event: event,
            item: item,
            itemInputValue: itemInputValue,
            itemUrl: itemUrl,
            refresh: refresh,
            source: source,
            state: store.getState()
          }, setters));
        });
      }
    }, rest);
  };
  return {
    getEnvironmentProps: getEnvironmentProps,
    getRootProps: getRootProps,
    getFormProps: getFormProps,
    getLabelProps: getLabelProps,
    getInputProps: getInputProps,
    getPanelProps: getPanelProps,
    getListProps: getListProps,
    getItemProps: getItemProps
  };
}

function _typeof$2(obj) {
  "@babel/helpers - typeof";

  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$2(obj);
}
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) {
      _defineProperty$5(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$5(obj, key, value) {
  key = _toPropertyKey$2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$2(arg) {
  var key = _toPrimitive$2(arg, "string");
  return _typeof$2(key) === "symbol" ? key : String(key);
}
function _toPrimitive$2(input, hint) {
  if (_typeof$2(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$2(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function getMetadata(_ref) {
  var _, _options$__autocomple, _options$__autocomple2, _options$__autocomple3;
  var plugins = _ref.plugins,
    options = _ref.options;
  var optionsKey = (_ = (((_options$__autocomple = options.__autocomplete_metadata) === null || _options$__autocomple === void 0 ? void 0 : _options$__autocomple.userAgents) || [])[0]) === null || _ === void 0 ? void 0 : _.segment;
  var extraOptions = optionsKey ? _defineProperty$5({}, optionsKey, Object.keys(((_options$__autocomple2 = options.__autocomplete_metadata) === null || _options$__autocomple2 === void 0 ? void 0 : _options$__autocomple2.options) || {})) : {};
  return {
    plugins: plugins.map(function (plugin) {
      return {
        name: plugin.name,
        options: Object.keys(plugin.__autocomplete_pluginOptions || [])
      };
    }),
    options: _objectSpread$4({
      'autocomplete-core': Object.keys(options)
    }, extraOptions),
    ua: userAgents.concat(((_options$__autocomple3 = options.__autocomplete_metadata) === null || _options$__autocomple3 === void 0 ? void 0 : _options$__autocomple3.userAgents) || [])
  };
}
function injectMetadata(_ref3) {
  var _environment$navigato, _environment$navigato2;
  var metadata = _ref3.metadata,
    environment = _ref3.environment;
  var isMetadataEnabled = (_environment$navigato = environment.navigator) === null || _environment$navigato === void 0 ? void 0 : (_environment$navigato2 = _environment$navigato.userAgent) === null || _environment$navigato2 === void 0 ? void 0 : _environment$navigato2.includes('Algolia Crawler');
  if (isMetadataEnabled) {
    var metadataContainer = environment.document.createElement('meta');
    var headRef = environment.document.querySelector('head');
    metadataContainer.name = 'algolia:metadata';
    setTimeout(function () {
      metadataContainer.content = JSON.stringify(metadata);
      headRef.appendChild(metadataContainer);
    }, 0);
  }
}

function getCompletion(_ref) {
  var _getActiveItem;
  var state = _ref.state;
  if (state.isOpen === false || state.activeItemId === null) {
    return null;
  }
  return ((_getActiveItem = getActiveItem(state)) === null || _getActiveItem === void 0 ? void 0 : _getActiveItem.itemInputValue) || null;
}

function _typeof$1(obj) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$1(obj);
}
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$4(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$1(arg) {
  var key = _toPrimitive$1(arg, "string");
  return _typeof$1(key) === "symbol" ? key : String(key);
}
function _toPrimitive$1(input, hint) {
  if (_typeof$1(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$1(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var stateReducer$1 = function stateReducer(state, action) {
  switch (action.type) {
    case 'setActiveItemId':
      {
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          activeItemId: action.payload
        });
      }
    case 'setQuery':
      {
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          query: action.payload,
          completion: null
        });
      }
    case 'setCollections':
      {
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          collections: action.payload
        });
      }
    case 'setIsOpen':
      {
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          isOpen: action.payload
        });
      }
    case 'setStatus':
      {
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          status: action.payload
        });
      }
    case 'setContext':
      {
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          context: _objectSpread$3(_objectSpread$3({}, state.context), action.payload)
        });
      }
    case 'ArrowDown':
      {
        var nextState = _objectSpread$3(_objectSpread$3({}, state), {}, {
          activeItemId: action.payload.hasOwnProperty('nextActiveItemId') ? action.payload.nextActiveItemId : getNextActiveItemId(1, state.activeItemId, getItemsCount(state), action.props.defaultActiveItemId)
        });
        return _objectSpread$3(_objectSpread$3({}, nextState), {}, {
          completion: getCompletion({
            state: nextState
          })
        });
      }
    case 'ArrowUp':
      {
        var _nextState = _objectSpread$3(_objectSpread$3({}, state), {}, {
          activeItemId: getNextActiveItemId(-1, state.activeItemId, getItemsCount(state), action.props.defaultActiveItemId)
        });
        return _objectSpread$3(_objectSpread$3({}, _nextState), {}, {
          completion: getCompletion({
            state: _nextState
          })
        });
      }
    case 'Escape':
      {
        if (state.isOpen) {
          return _objectSpread$3(_objectSpread$3({}, state), {}, {
            activeItemId: null,
            isOpen: false,
            completion: null
          });
        }
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          activeItemId: null,
          query: '',
          status: 'idle',
          collections: []
        });
      }
    case 'submit':
      {
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          activeItemId: null,
          isOpen: false,
          status: 'idle'
        });
      }
    case 'reset':
      {
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          activeItemId:
          // Since we open the panel on reset when openOnFocus=true
          // we need to restore the highlighted index to the defaultActiveItemId. (DocSearch use-case)

          // Since we close the panel when openOnFocus=false
          // we lose track of the highlighted index. (Query-suggestions use-case)
          action.props.openOnFocus === true ? action.props.defaultActiveItemId : null,
          status: 'idle',
          query: ''
        });
      }
    case 'focus':
      {
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          activeItemId: action.props.defaultActiveItemId,
          isOpen: (action.props.openOnFocus || Boolean(state.query)) && action.props.shouldPanelOpen({
            state: state
          })
        });
      }
    case 'blur':
      {
        if (action.props.debug) {
          return state;
        }
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          isOpen: false,
          activeItemId: null
        });
      }
    case 'mousemove':
      {
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          activeItemId: action.payload
        });
      }
    case 'mouseleave':
      {
        return _objectSpread$3(_objectSpread$3({}, state), {}, {
          activeItemId: action.props.defaultActiveItemId
        });
      }
    default:
      invariant$1(false, "The reducer action ".concat(JSON.stringify(action.type), " is not supported."));
      return state;
  }
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
      _defineProperty$3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$3(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function createAutocomplete(options) {
  checkOptions(options);
  var subscribers = [];
  var props = getDefaultProps(options, subscribers);
  var store = createStore(stateReducer$1, props, onStoreStateChange);
  var setters = getAutocompleteSetters({
    store: store
  });
  var propGetters = getPropGetters(_objectSpread$2({
    props: props,
    refresh: refresh,
    store: store,
    navigator: props.navigator
  }, setters));
  function onStoreStateChange(_ref) {
    var prevState = _ref.prevState,
      state = _ref.state;
    props.onStateChange(_objectSpread$2({
      prevState: prevState,
      state: state,
      refresh: refresh,
      navigator: props.navigator
    }, setters));
  }
  function refresh() {
    return onInput(_objectSpread$2({
      event: new Event('input'),
      nextState: {
        isOpen: store.getState().isOpen
      },
      props: props,
      navigator: props.navigator,
      query: store.getState().query,
      refresh: refresh,
      store: store
    }, setters));
  }
  if (options.insights && !props.plugins.some(function (plugin) {
    return plugin.name === 'aa.algoliaInsightsPlugin';
  })) {
    var insightsParams = typeof options.insights === 'boolean' ? {} : options.insights;
    props.plugins.push(createAlgoliaInsightsPlugin(insightsParams));
  }
  props.plugins.forEach(function (plugin) {
    var _plugin$subscribe;
    return (_plugin$subscribe = plugin.subscribe) === null || _plugin$subscribe === void 0 ? void 0 : _plugin$subscribe.call(plugin, _objectSpread$2(_objectSpread$2({}, setters), {}, {
      navigator: props.navigator,
      refresh: refresh,
      onSelect: function onSelect(fn) {
        subscribers.push({
          onSelect: fn
        });
      },
      onActive: function onActive(fn) {
        subscribers.push({
          onActive: fn
        });
      },
      onResolve: function onResolve(fn) {
        subscribers.push({
          onResolve: fn
        });
      }
    }));
  });
  injectMetadata({
    metadata: getMetadata({
      plugins: props.plugins,
      options: options
    }),
    environment: props.environment
  });
  return _objectSpread$2(_objectSpread$2({
    refresh: refresh,
    navigator: props.navigator
  }, propGetters), setters);
}

var MAX_QUERY_SIZE = 64;

function AlgoliaLogo(_ref) {
  var _ref$translations = _ref.translations,
    translations = _ref$translations === void 0 ? {} : _ref$translations;
  var _translations$searchB = translations.searchByText,
    searchByText = _translations$searchB === void 0 ? 'Search by' : _translations$searchB;
  return /*#__PURE__*/React__default["default"].createElement("a", {
    href: "https://www.algolia.com/ref/docsearch/?utm_source=".concat(window.location.hostname, "&utm_medium=referral&utm_content=powered_by&utm_campaign=docsearch"),
    target: "_blank",
    rel: "noopener noreferrer"
  }, /*#__PURE__*/React__default["default"].createElement("span", {
    className: "DocSearch-Label"
  }, searchByText), /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "77",
    height: "19",
    "aria-label": "Algolia",
    role: "img",
    id: "Layer_1",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 2196.2 500"
  }, /*#__PURE__*/React__default["default"].createElement("defs", null, /*#__PURE__*/React__default["default"].createElement("style", null, ".cls-1,.cls-2{fill:#003dff;}.cls-2{fill-rule:evenodd;}")), /*#__PURE__*/React__default["default"].createElement("path", {
    className: "cls-2",
    d: "M1070.38,275.3V5.91c0-3.63-3.24-6.39-6.82-5.83l-50.46,7.94c-2.87,.45-4.99,2.93-4.99,5.84l.17,273.22c0,12.92,0,92.7,95.97,95.49,3.33,.1,6.09-2.58,6.09-5.91v-40.78c0-2.96-2.19-5.51-5.12-5.84-34.85-4.01-34.85-47.57-34.85-54.72Z"
  }), /*#__PURE__*/React__default["default"].createElement("rect", {
    className: "cls-1",
    x: "1845.88",
    y: "104.73",
    width: "62.58",
    height: "277.9",
    rx: "5.9",
    ry: "5.9"
  }), /*#__PURE__*/React__default["default"].createElement("path", {
    className: "cls-2",
    d: "M1851.78,71.38h50.77c3.26,0,5.9-2.64,5.9-5.9V5.9c0-3.62-3.24-6.39-6.82-5.83l-50.77,7.95c-2.87,.45-4.99,2.92-4.99,5.83v51.62c0,3.26,2.64,5.9,5.9,5.9Z"
  }), /*#__PURE__*/React__default["default"].createElement("path", {
    className: "cls-2",
    d: "M1764.03,275.3V5.91c0-3.63-3.24-6.39-6.82-5.83l-50.46,7.94c-2.87,.45-4.99,2.93-4.99,5.84l.17,273.22c0,12.92,0,92.7,95.97,95.49,3.33,.1,6.09-2.58,6.09-5.91v-40.78c0-2.96-2.19-5.51-5.12-5.84-34.85-4.01-34.85-47.57-34.85-54.72Z"
  }), /*#__PURE__*/React__default["default"].createElement("path", {
    className: "cls-2",
    d: "M1631.95,142.72c-11.14-12.25-24.83-21.65-40.78-28.31-15.92-6.53-33.26-9.85-52.07-9.85-18.78,0-36.15,3.17-51.92,9.85-15.59,6.66-29.29,16.05-40.76,28.31-11.47,12.23-20.38,26.87-26.76,44.03-6.38,17.17-9.24,37.37-9.24,58.36,0,20.99,3.19,36.87,9.55,54.21,6.38,17.32,15.14,32.11,26.45,44.36,11.29,12.23,24.83,21.62,40.6,28.46,15.77,6.83,40.12,10.33,52.4,10.48,12.25,0,36.78-3.82,52.7-10.48,15.92-6.68,29.46-16.23,40.78-28.46,11.29-12.25,20.05-27.04,26.25-44.36,6.22-17.34,9.24-33.22,9.24-54.21,0-20.99-3.34-41.19-10.03-58.36-6.38-17.17-15.14-31.8-26.43-44.03Zm-44.43,163.75c-11.47,15.75-27.56,23.7-48.09,23.7-20.55,0-36.63-7.8-48.1-23.7-11.47-15.75-17.21-34.01-17.21-61.2,0-26.89,5.59-49.14,17.06-64.87,11.45-15.75,27.54-23.52,48.07-23.52,20.55,0,36.63,7.78,48.09,23.52,11.47,15.57,17.36,37.98,17.36,64.87,0,27.19-5.72,45.3-17.19,61.2Z"
  }), /*#__PURE__*/React__default["default"].createElement("path", {
    className: "cls-2",
    d: "M894.42,104.73h-49.33c-48.36,0-90.91,25.48-115.75,64.1-14.52,22.58-22.99,49.63-22.99,78.73,0,44.89,20.13,84.92,51.59,111.1,2.93,2.6,6.05,4.98,9.31,7.14,12.86,8.49,28.11,13.47,44.52,13.47,1.23,0,2.46-.03,3.68-.09,.36-.02,.71-.05,1.07-.07,.87-.05,1.75-.11,2.62-.2,.34-.03,.68-.08,1.02-.12,.91-.1,1.82-.21,2.73-.34,.21-.03,.42-.07,.63-.1,32.89-5.07,61.56-30.82,70.9-62.81v57.83c0,3.26,2.64,5.9,5.9,5.9h50.42c3.26,0,5.9-2.64,5.9-5.9V110.63c0-3.26-2.64-5.9-5.9-5.9h-56.32Zm0,206.92c-12.2,10.16-27.97,13.98-44.84,15.12-.16,.01-.33,.03-.49,.04-1.12,.07-2.24,.1-3.36,.1-42.24,0-77.12-35.89-77.12-79.37,0-10.25,1.96-20.01,5.42-28.98,11.22-29.12,38.77-49.74,71.06-49.74h49.33v142.83Z"
  }), /*#__PURE__*/React__default["default"].createElement("path", {
    className: "cls-2",
    d: "M2133.97,104.73h-49.33c-48.36,0-90.91,25.48-115.75,64.1-14.52,22.58-22.99,49.63-22.99,78.73,0,44.89,20.13,84.92,51.59,111.1,2.93,2.6,6.05,4.98,9.31,7.14,12.86,8.49,28.11,13.47,44.52,13.47,1.23,0,2.46-.03,3.68-.09,.36-.02,.71-.05,1.07-.07,.87-.05,1.75-.11,2.62-.2,.34-.03,.68-.08,1.02-.12,.91-.1,1.82-.21,2.73-.34,.21-.03,.42-.07,.63-.1,32.89-5.07,61.56-30.82,70.9-62.81v57.83c0,3.26,2.64,5.9,5.9,5.9h50.42c3.26,0,5.9-2.64,5.9-5.9V110.63c0-3.26-2.64-5.9-5.9-5.9h-56.32Zm0,206.92c-12.2,10.16-27.97,13.98-44.84,15.12-.16,.01-.33,.03-.49,.04-1.12,.07-2.24,.1-3.36,.1-42.24,0-77.12-35.89-77.12-79.37,0-10.25,1.96-20.01,5.42-28.98,11.22-29.12,38.77-49.74,71.06-49.74h49.33v142.83Z"
  }), /*#__PURE__*/React__default["default"].createElement("path", {
    className: "cls-2",
    d: "M1314.05,104.73h-49.33c-48.36,0-90.91,25.48-115.75,64.1-11.79,18.34-19.6,39.64-22.11,62.59-.58,5.3-.88,10.68-.88,16.14s.31,11.15,.93,16.59c4.28,38.09,23.14,71.61,50.66,94.52,2.93,2.6,6.05,4.98,9.31,7.14,12.86,8.49,28.11,13.47,44.52,13.47h0c17.99,0,34.61-5.93,48.16-15.97,16.29-11.58,28.88-28.54,34.48-47.75v50.26h-.11v11.08c0,21.84-5.71,38.27-17.34,49.36-11.61,11.08-31.04,16.63-58.25,16.63-11.12,0-28.79-.59-46.6-2.41-2.83-.29-5.46,1.5-6.27,4.22l-12.78,43.11c-1.02,3.46,1.27,7.02,4.83,7.53,21.52,3.08,42.52,4.68,54.65,4.68,48.91,0,85.16-10.75,108.89-32.21,21.48-19.41,33.15-48.89,35.2-88.52V110.63c0-3.26-2.64-5.9-5.9-5.9h-56.32Zm0,64.1s.65,139.13,0,143.36c-12.08,9.77-27.11,13.59-43.49,14.7-.16,.01-.33,.03-.49,.04-1.12,.07-2.24,.1-3.36,.1-1.32,0-2.63-.03-3.94-.1-40.41-2.11-74.52-37.26-74.52-79.38,0-10.25,1.96-20.01,5.42-28.98,11.22-29.12,38.77-49.74,71.06-49.74h49.33Z"
  }), /*#__PURE__*/React__default["default"].createElement("path", {
    className: "cls-1",
    d: "M249.83,0C113.3,0,2,110.09,.03,246.16c-2,138.19,110.12,252.7,248.33,253.5,42.68,.25,83.79-10.19,120.3-30.03,3.56-1.93,4.11-6.83,1.08-9.51l-23.38-20.72c-4.75-4.21-11.51-5.4-17.36-2.92-25.48,10.84-53.17,16.38-81.71,16.03-111.68-1.37-201.91-94.29-200.13-205.96,1.76-110.26,92-199.41,202.67-199.41h202.69V407.41l-115-102.18c-3.72-3.31-9.42-2.66-12.42,1.31-18.46,24.44-48.53,39.64-81.93,37.34-46.33-3.2-83.87-40.5-87.34-86.81-4.15-55.24,39.63-101.52,94-101.52,49.18,0,89.68,37.85,93.91,85.95,.38,4.28,2.31,8.27,5.52,11.12l29.95,26.55c3.4,3.01,8.79,1.17,9.63-3.3,2.16-11.55,2.92-23.58,2.07-35.92-4.82-70.34-61.8-126.93-132.17-131.26-80.68-4.97-148.13,58.14-150.27,137.25-2.09,77.1,61.08,143.56,138.19,145.26,32.19,.71,62.03-9.41,86.14-26.95l150.26,133.2c6.44,5.71,16.61,1.14,16.61-7.47V9.48C499.66,4.25,495.42,0,490.18,0H249.83Z"
  })));
}

function CommandIcon(props) {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "15",
    height: "15",
    "aria-label": props.ariaLabel,
    role: "img"
  }, /*#__PURE__*/React__default["default"].createElement("g", {
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "1.2"
  }, props.children));
}
function Footer(_ref) {
  var _ref$translations = _ref.translations,
    translations = _ref$translations === void 0 ? {} : _ref$translations;
  var _translations$selectT = translations.selectText,
    selectText = _translations$selectT === void 0 ? 'to select' : _translations$selectT,
    _translations$selectK = translations.selectKeyAriaLabel,
    selectKeyAriaLabel = _translations$selectK === void 0 ? 'Enter key' : _translations$selectK,
    _translations$navigat = translations.navigateText,
    navigateText = _translations$navigat === void 0 ? 'to navigate' : _translations$navigat,
    _translations$navigat2 = translations.navigateUpKeyAriaLabel,
    navigateUpKeyAriaLabel = _translations$navigat2 === void 0 ? 'Arrow up' : _translations$navigat2,
    _translations$navigat3 = translations.navigateDownKeyAriaLabel,
    navigateDownKeyAriaLabel = _translations$navigat3 === void 0 ? 'Arrow down' : _translations$navigat3,
    _translations$closeTe = translations.closeText,
    closeText = _translations$closeTe === void 0 ? 'to close' : _translations$closeTe,
    _translations$closeKe = translations.closeKeyAriaLabel,
    closeKeyAriaLabel = _translations$closeKe === void 0 ? 'Escape key' : _translations$closeKe,
    _translations$searchB = translations.searchByText,
    searchByText = _translations$searchB === void 0 ? 'Search by' : _translations$searchB;
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Logo"
  }, /*#__PURE__*/React__default["default"].createElement(AlgoliaLogo, {
    translations: {
      searchByText: searchByText
    }
  })), /*#__PURE__*/React__default["default"].createElement("ul", {
    className: "DocSearch-Commands"
  }, /*#__PURE__*/React__default["default"].createElement("li", null, /*#__PURE__*/React__default["default"].createElement("kbd", {
    className: "DocSearch-Commands-Key"
  }, /*#__PURE__*/React__default["default"].createElement(CommandIcon, {
    ariaLabel: selectKeyAriaLabel
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"
  }))), /*#__PURE__*/React__default["default"].createElement("span", {
    className: "DocSearch-Label"
  }, selectText)), /*#__PURE__*/React__default["default"].createElement("li", null, /*#__PURE__*/React__default["default"].createElement("kbd", {
    className: "DocSearch-Commands-Key"
  }, /*#__PURE__*/React__default["default"].createElement(CommandIcon, {
    ariaLabel: navigateDownKeyAriaLabel
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M7.5 3.5v8M10.5 8.5l-3 3-3-3"
  }))), /*#__PURE__*/React__default["default"].createElement("kbd", {
    className: "DocSearch-Commands-Key"
  }, /*#__PURE__*/React__default["default"].createElement(CommandIcon, {
    ariaLabel: navigateUpKeyAriaLabel
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M7.5 11.5v-8M10.5 6.5l-3-3-3 3"
  }))), /*#__PURE__*/React__default["default"].createElement("span", {
    className: "DocSearch-Label"
  }, navigateText)), /*#__PURE__*/React__default["default"].createElement("li", null, /*#__PURE__*/React__default["default"].createElement("kbd", {
    className: "DocSearch-Commands-Key"
  }, /*#__PURE__*/React__default["default"].createElement(CommandIcon, {
    ariaLabel: closeKeyAriaLabel
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"
  }))), /*#__PURE__*/React__default["default"].createElement("span", {
    className: "DocSearch-Label"
  }, closeText))));
}

function Hit(_ref) {
  var hit = _ref.hit,
    children = _ref.children;
  return /*#__PURE__*/React__default["default"].createElement("a", {
    href: hit.url
  }, children);
}

function LoadingIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    viewBox: "0 0 38 38",
    stroke: "currentColor",
    strokeOpacity: ".5"
  }, /*#__PURE__*/React__default["default"].createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /*#__PURE__*/React__default["default"].createElement("g", {
    transform: "translate(1 1)",
    strokeWidth: "2"
  }, /*#__PURE__*/React__default["default"].createElement("circle", {
    strokeOpacity: ".3",
    cx: "18",
    cy: "18",
    r: "18"
  }), /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M36 18c0-9.94-8.06-18-18-18"
  }, /*#__PURE__*/React__default["default"].createElement("animateTransform", {
    attributeName: "transform",
    type: "rotate",
    from: "0 18 18",
    to: "360 18 18",
    dur: "1s",
    repeatCount: "indefinite"
  })))));
}

function RecentIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20"
  }, /*#__PURE__*/React__default["default"].createElement("g", {
    stroke: "currentColor",
    fill: "none",
    fillRule: "evenodd",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M3.18 6.6a8.23 8.23 0 1112.93 9.94h0a8.23 8.23 0 01-11.63 0"
  }), /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M6.44 7.25H2.55V3.36M10.45 6v5.6M10.45 11.6L13 13"
  })));
}

function ResetIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z",
    stroke: "currentColor",
    fill: "none",
    fillRule: "evenodd",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
}

function SelectIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    className: "DocSearch-Hit-Select-Icon",
    width: "20",
    height: "20",
    viewBox: "0 0 20 20"
  }, /*#__PURE__*/React__default["default"].createElement("g", {
    stroke: "currentColor",
    fill: "none",
    fillRule: "evenodd",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M18 3v4c0 2-2 4-4 4H2"
  }), /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M8 17l-6-6 6-6"
  })));
}

var LvlIcon = function LvlIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M17 6v12c0 .52-.2 1-1 1H4c-.7 0-1-.33-1-1V2c0-.55.42-1 1-1h8l5 5zM14 8h-3.13c-.51 0-.87-.34-.87-.87V4",
    stroke: "currentColor",
    fill: "none",
    fillRule: "evenodd",
    strokeLinejoin: "round"
  }));
};
function SourceIcon(props) {
  switch (props.type) {
    case 'lvl1':
      return /*#__PURE__*/React__default["default"].createElement(LvlIcon, null);
    case 'content':
      return /*#__PURE__*/React__default["default"].createElement(ContentIcon, null);
    default:
      return /*#__PURE__*/React__default["default"].createElement(AnchorIcon, null);
  }
}
function AnchorIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M13 13h4-4V8H7v5h6v4-4H7V8H3h4V3v5h6V3v5h4-4v5zm-6 0v4-4H3h4z",
    stroke: "currentColor",
    fill: "none",
    fillRule: "evenodd",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
}
function ContentIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M17 5H3h14zm0 5H3h14zm0 5H3h14z",
    stroke: "currentColor",
    fill: "none",
    fillRule: "evenodd",
    strokeLinejoin: "round"
  }));
}

function StarIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M10 14.2L5 17l1-5.6-4-4 5.5-.7 2.5-5 2.5 5 5.6.8-4 4 .9 5.5z",
    stroke: "currentColor",
    fill: "none",
    fillRule: "evenodd",
    strokeLinejoin: "round"
  }));
}

function ErrorIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "40",
    height: "40",
    viewBox: "0 0 20 20",
    fill: "none",
    fillRule: "evenodd",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M19 4.8a16 16 0 00-2-1.2m-3.3-1.2A16 16 0 001.1 4.7M16.7 8a12 12 0 00-2.8-1.4M10 6a12 12 0 00-6.7 2M12.3 14.7a4 4 0 00-4.5 0M14.5 11.4A8 8 0 0010 10M3 16L18 2M10 18h0"
  }));
}

function NoResultsIcon() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "40",
    height: "40",
    viewBox: "0 0 20 20",
    fill: "none",
    fillRule: "evenodd",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    d: "M15.5 4.8c2 3 1.7 7-1 9.7h0l4.3 4.3-4.3-4.3a7.8 7.8 0 01-9.8 1m-2.2-2.2A7.8 7.8 0 0113.2 2.4M2 18L18 2"
  }));
}

function ErrorScreen(_ref) {
  var _ref$translations = _ref.translations,
    translations = _ref$translations === void 0 ? {} : _ref$translations;
  var _translations$titleTe = translations.titleText,
    titleText = _translations$titleTe === void 0 ? 'Unable to fetch results' : _translations$titleTe,
    _translations$helpTex = translations.helpText,
    helpText = _translations$helpTex === void 0 ? 'You might want to check your network connection.' : _translations$helpTex;
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-ErrorScreen"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Screen-Icon"
  }, /*#__PURE__*/React__default["default"].createElement(ErrorIcon, null)), /*#__PURE__*/React__default["default"].createElement("p", {
    className: "DocSearch-Title"
  }, titleText), /*#__PURE__*/React__default["default"].createElement("p", {
    className: "DocSearch-Help"
  }, helpText));
}

var _excluded$6 = ["translations"];
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$4(arr);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _objectWithoutProperties$6(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$6(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function NoResultsScreen(_ref) {
  var _ref$translations = _ref.translations,
    translations = _ref$translations === void 0 ? {} : _ref$translations,
    props = _objectWithoutProperties$6(_ref, _excluded$6);
  var _translations$noResul = translations.noResultsText,
    noResultsText = _translations$noResul === void 0 ? 'No results for' : _translations$noResul,
    _translations$suggest = translations.suggestedQueryText,
    suggestedQueryText = _translations$suggest === void 0 ? 'Try searching for' : _translations$suggest,
    _translations$reportM = translations.reportMissingResultsText,
    reportMissingResultsText = _translations$reportM === void 0 ? 'Believe this query should return results?' : _translations$reportM,
    _translations$reportM2 = translations.reportMissingResultsLinkText,
    reportMissingResultsLinkText = _translations$reportM2 === void 0 ? 'Let us know.' : _translations$reportM2;
  var searchSuggestions = props.state.context.searchSuggestions;
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-NoResults"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Screen-Icon"
  }, /*#__PURE__*/React__default["default"].createElement(NoResultsIcon, null)), /*#__PURE__*/React__default["default"].createElement("p", {
    className: "DocSearch-Title"
  }, noResultsText, " \"", /*#__PURE__*/React__default["default"].createElement("strong", null, props.state.query), "\""), searchSuggestions && searchSuggestions.length > 0 && /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-NoResults-Prefill-List"
  }, /*#__PURE__*/React__default["default"].createElement("p", {
    className: "DocSearch-Help"
  }, suggestedQueryText, ":"), /*#__PURE__*/React__default["default"].createElement("ul", null, searchSuggestions.slice(0, 3).reduce(function (acc, search) {
    return [].concat(_toConsumableArray(acc), [/*#__PURE__*/React__default["default"].createElement("li", {
      key: search
    }, /*#__PURE__*/React__default["default"].createElement("button", {
      className: "DocSearch-Prefill",
      key: search,
      type: "button",
      onClick: function onClick() {
        props.setQuery(search.toLowerCase() + ' ');
        props.refresh();
        props.inputRef.current.focus();
      }
    }, search))]);
  }, []))), props.getMissingResultsUrl && /*#__PURE__*/React__default["default"].createElement("p", {
    className: "DocSearch-Help"
  }, "".concat(reportMissingResultsText, " "), /*#__PURE__*/React__default["default"].createElement("a", {
    href: props.getMissingResultsUrl({
      query: props.state.query
    }),
    target: "_blank",
    rel: "noopener noreferrer"
  }, reportMissingResultsLinkText)));
}

var _excluded$5 = ["hit", "attribute", "tagName"];
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$5(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$5(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function getPropertyByPath(object, path) {
  var parts = path.split('.');
  return parts.reduce(function (prev, current) {
    if (prev !== null && prev !== void 0 && prev[current]) return prev[current];
    return null;
  }, object);
}
function Snippet(_ref) {
  var hit = _ref.hit,
    attribute = _ref.attribute,
    _ref$tagName = _ref.tagName,
    tagName = _ref$tagName === void 0 ? 'span' : _ref$tagName,
    rest = _objectWithoutProperties$5(_ref, _excluded$5);
  return /*#__PURE__*/React$2.createElement(tagName, _objectSpread$1(_objectSpread$1({}, rest), {}, {
    dangerouslySetInnerHTML: {
      __html: getPropertyByPath(hit, "_snippetResult.".concat(attribute, ".value")) || getPropertyByPath(hit, attribute)
    }
  }));
}

function _slicedToArray$3(arr, i) {
  return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$3(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$3(arr) {
  if (Array.isArray(arr)) return arr;
}
function _extends$d() {
  _extends$d = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$d.apply(this, arguments);
}
function Results(props) {
  if (!props.collection || props.collection.items.length === 0) {
    return null;
  }
  return /*#__PURE__*/React__default["default"].createElement("section", {
    className: "DocSearch-Hits"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Hit-source"
  }, props.title), /*#__PURE__*/React__default["default"].createElement("ul", props.getListProps(), props.collection.items.map(function (item, index) {
    return /*#__PURE__*/React__default["default"].createElement(Result, _extends$d({
      key: [props.title, item.objectID].join(':'),
      item: item,
      index: index
    }, props));
  })));
}
function Result(_ref) {
  var item = _ref.item,
    index = _ref.index,
    renderIcon = _ref.renderIcon,
    renderAction = _ref.renderAction,
    getItemProps = _ref.getItemProps,
    onItemClick = _ref.onItemClick,
    collection = _ref.collection,
    hitComponent = _ref.hitComponent;
  var _React$useState = React__default["default"].useState(false),
    _React$useState2 = _slicedToArray$3(_React$useState, 2),
    isDeleting = _React$useState2[0],
    setIsDeleting = _React$useState2[1];
  var _React$useState3 = React__default["default"].useState(false),
    _React$useState4 = _slicedToArray$3(_React$useState3, 2),
    isFavoriting = _React$useState4[0],
    setIsFavoriting = _React$useState4[1];
  var action = React__default["default"].useRef(null);
  var Hit = hitComponent;
  function runDeleteTransition(cb) {
    setIsDeleting(true);
    action.current = cb;
  }
  function runFavoriteTransition(cb) {
    setIsFavoriting(true);
    action.current = cb;
  }
  return /*#__PURE__*/React__default["default"].createElement("li", _extends$d({
    className: ['DocSearch-Hit', item.__docsearch_parent && 'DocSearch-Hit--Child', isDeleting && 'DocSearch-Hit--deleting', isFavoriting && 'DocSearch-Hit--favoriting'].filter(Boolean).join(' '),
    onTransitionEnd: function onTransitionEnd() {
      if (action.current) {
        action.current();
      }
    }
  }, getItemProps({
    item: item,
    source: collection.source,
    onClick: function onClick(event) {
      onItemClick(item, event);
    }
  })), /*#__PURE__*/React__default["default"].createElement(Hit, {
    hit: item
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Hit-Container"
  }, renderIcon({
    item: item,
    index: index
  }), item.hierarchy[item.type] && item.type === 'lvl1' && /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Hit-content-wrapper"
  }, /*#__PURE__*/React__default["default"].createElement(Snippet, {
    className: "DocSearch-Hit-title",
    hit: item,
    attribute: "hierarchy.lvl1"
  }), item.content && /*#__PURE__*/React__default["default"].createElement(Snippet, {
    className: "DocSearch-Hit-path",
    hit: item,
    attribute: "content"
  })), item.hierarchy[item.type] && (item.type === 'lvl2' || item.type === 'lvl3' || item.type === 'lvl4' || item.type === 'lvl5' || item.type === 'lvl6') && /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Hit-content-wrapper"
  }, /*#__PURE__*/React__default["default"].createElement(Snippet, {
    className: "DocSearch-Hit-title",
    hit: item,
    attribute: "hierarchy.".concat(item.type)
  }), /*#__PURE__*/React__default["default"].createElement(Snippet, {
    className: "DocSearch-Hit-path",
    hit: item,
    attribute: "hierarchy.lvl1"
  })), item.type === 'content' && /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Hit-content-wrapper"
  }, /*#__PURE__*/React__default["default"].createElement(Snippet, {
    className: "DocSearch-Hit-title",
    hit: item,
    attribute: "content"
  }), /*#__PURE__*/React__default["default"].createElement(Snippet, {
    className: "DocSearch-Hit-path",
    hit: item,
    attribute: "hierarchy.lvl1"
  })), renderAction({
    item: item,
    runDeleteTransition: runDeleteTransition,
    runFavoriteTransition: runFavoriteTransition
  }))));
}

function groupBy(values, predicate, maxResultsPerGroup) {
  return values.reduce(function (acc, item) {
    var key = predicate(item);
    if (!acc.hasOwnProperty(key)) {
      acc[key] = [];
    } // We limit each section to show 5 hits maximum.
    // This acts as a frontend alternative to `distinct`.

    if (acc[key].length < (maxResultsPerGroup || 5)) {
      acc[key].push(item);
    }
    return acc;
  }, {});
}

function identity$1(x) {
  return x;
}

/**
 * Detect when an event is modified with a special key to let the browser
 * trigger its default behavior.
 */
function isModifierEvent(event) {
  var isMiddleClick = event.button === 1;
  return isMiddleClick || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
}

function noop$1() {}

var regexHighlightTags = /(<mark>|<\/mark>)/g;
var regexHasHighlightTags = RegExp(regexHighlightTags.source);
function removeHighlightTags(hit) {
  var _internalDocSearchHit, _hit$_highlightResult;
  var internalDocSearchHit = hit;
  if (!internalDocSearchHit.__docsearch_parent && !hit._highlightResult) {
    return hit.hierarchy.lvl0;
  }
  var _ref = (internalDocSearchHit.__docsearch_parent ? (_internalDocSearchHit = internalDocSearchHit.__docsearch_parent) === null || _internalDocSearchHit === void 0 || (_internalDocSearchHit = _internalDocSearchHit._highlightResult) === null || _internalDocSearchHit === void 0 || (_internalDocSearchHit = _internalDocSearchHit.hierarchy) === null || _internalDocSearchHit === void 0 ? void 0 : _internalDocSearchHit.lvl0 : (_hit$_highlightResult = hit._highlightResult) === null || _hit$_highlightResult === void 0 || (_hit$_highlightResult = _hit$_highlightResult.hierarchy) === null || _hit$_highlightResult === void 0 ? void 0 : _hit$_highlightResult.lvl0) || {},
    value = _ref.value;
  return value && regexHasHighlightTags.test(value) ? value.replace(regexHighlightTags, '') : value;
}

function _extends$c() {
  _extends$c = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$c.apply(this, arguments);
}
function ResultsScreen(props) {
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Dropdown-Container"
  }, props.state.collections.map(function (collection) {
    if (collection.items.length === 0) {
      return null;
    }
    var title = removeHighlightTags(collection.items[0]);
    return /*#__PURE__*/React__default["default"].createElement(Results, _extends$c({}, props, {
      key: collection.source.sourceId,
      title: title,
      collection: collection,
      renderIcon: function renderIcon(_ref) {
        var _collection$items;
        var item = _ref.item,
          index = _ref.index;
        return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, item.__docsearch_parent && /*#__PURE__*/React__default["default"].createElement("svg", {
          className: "DocSearch-Hit-Tree",
          viewBox: "0 0 24 54"
        }, /*#__PURE__*/React__default["default"].createElement("g", {
          stroke: "currentColor",
          fill: "none",
          fillRule: "evenodd",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }, item.__docsearch_parent !== ((_collection$items = collection.items[index + 1]) === null || _collection$items === void 0 ? void 0 : _collection$items.__docsearch_parent) ? /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M8 6v21M20 27H8.3"
        }) : /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M8 6v42M20 27H8.3"
        }))), /*#__PURE__*/React__default["default"].createElement("div", {
          className: "DocSearch-Hit-icon"
        }, /*#__PURE__*/React__default["default"].createElement(SourceIcon, {
          type: item.type
        })));
      },
      renderAction: function renderAction() {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: "DocSearch-Hit-action"
        }, /*#__PURE__*/React__default["default"].createElement(SelectIcon, null));
      }
    }));
  }), props.resultsFooterComponent && /*#__PURE__*/React__default["default"].createElement("section", {
    className: "DocSearch-HitsFooter"
  }, /*#__PURE__*/React__default["default"].createElement(props.resultsFooterComponent, {
    state: props.state
  })));
}

var _excluded$4 = ["translations"];
function _extends$b() {
  _extends$b = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$b.apply(this, arguments);
}
function _objectWithoutProperties$4(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$4(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function StartScreen(_ref) {
  var _ref$translations = _ref.translations,
    translations = _ref$translations === void 0 ? {} : _ref$translations,
    props = _objectWithoutProperties$4(_ref, _excluded$4);
  var _translations$recentS = translations.recentSearchesTitle,
    recentSearchesTitle = _translations$recentS === void 0 ? 'Recent' : _translations$recentS,
    _translations$noRecen = translations.noRecentSearchesText,
    noRecentSearchesText = _translations$noRecen === void 0 ? 'No recent searches' : _translations$noRecen,
    _translations$saveRec = translations.saveRecentSearchButtonTitle,
    saveRecentSearchButtonTitle = _translations$saveRec === void 0 ? 'Save this search' : _translations$saveRec,
    _translations$removeR = translations.removeRecentSearchButtonTitle,
    removeRecentSearchButtonTitle = _translations$removeR === void 0 ? 'Remove this search from history' : _translations$removeR,
    _translations$favorit = translations.favoriteSearchesTitle,
    favoriteSearchesTitle = _translations$favorit === void 0 ? 'Favorite' : _translations$favorit,
    _translations$removeF = translations.removeFavoriteSearchButtonTitle,
    removeFavoriteSearchButtonTitle = _translations$removeF === void 0 ? 'Remove this search from favorites' : _translations$removeF;
  if (props.state.status === 'idle' && props.hasCollections === false) {
    if (props.disableUserPersonalization) {
      return null;
    }
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: "DocSearch-StartScreen"
    }, /*#__PURE__*/React__default["default"].createElement("p", {
      className: "DocSearch-Help"
    }, noRecentSearchesText));
  }
  if (props.hasCollections === false) {
    return null;
  }
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Dropdown-Container"
  }, /*#__PURE__*/React__default["default"].createElement(Results, _extends$b({}, props, {
    title: recentSearchesTitle,
    collection: props.state.collections[0],
    renderIcon: function renderIcon() {
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: "DocSearch-Hit-icon"
      }, /*#__PURE__*/React__default["default"].createElement(RecentIcon, null));
    },
    renderAction: function renderAction(_ref2) {
      var item = _ref2.item,
        runFavoriteTransition = _ref2.runFavoriteTransition,
        runDeleteTransition = _ref2.runDeleteTransition;
      return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", {
        className: "DocSearch-Hit-action"
      }, /*#__PURE__*/React__default["default"].createElement("button", {
        className: "DocSearch-Hit-action-button",
        title: saveRecentSearchButtonTitle,
        type: "submit",
        onClick: function onClick(event) {
          event.preventDefault();
          event.stopPropagation();
          runFavoriteTransition(function () {
            props.favoriteSearches.add(item);
            props.recentSearches.remove(item);
            props.refresh();
          });
        }
      }, /*#__PURE__*/React__default["default"].createElement(StarIcon, null))), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "DocSearch-Hit-action"
      }, /*#__PURE__*/React__default["default"].createElement("button", {
        className: "DocSearch-Hit-action-button",
        title: removeRecentSearchButtonTitle,
        type: "submit",
        onClick: function onClick(event) {
          event.preventDefault();
          event.stopPropagation();
          runDeleteTransition(function () {
            props.recentSearches.remove(item);
            props.refresh();
          });
        }
      }, /*#__PURE__*/React__default["default"].createElement(ResetIcon, null))));
    }
  })), /*#__PURE__*/React__default["default"].createElement(Results, _extends$b({}, props, {
    title: favoriteSearchesTitle,
    collection: props.state.collections[1],
    renderIcon: function renderIcon() {
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: "DocSearch-Hit-icon"
      }, /*#__PURE__*/React__default["default"].createElement(StarIcon, null));
    },
    renderAction: function renderAction(_ref3) {
      var item = _ref3.item,
        runDeleteTransition = _ref3.runDeleteTransition;
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: "DocSearch-Hit-action"
      }, /*#__PURE__*/React__default["default"].createElement("button", {
        className: "DocSearch-Hit-action-button",
        title: removeFavoriteSearchButtonTitle,
        type: "submit",
        onClick: function onClick(event) {
          event.preventDefault();
          event.stopPropagation();
          runDeleteTransition(function () {
            props.favoriteSearches.remove(item);
            props.refresh();
          });
        }
      }, /*#__PURE__*/React__default["default"].createElement(ResetIcon, null)));
    }
  })));
}

var _excluded$3 = ["translations"];
function _extends$a() {
  _extends$a = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$a.apply(this, arguments);
}
function _objectWithoutProperties$3(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ScreenState = /*#__PURE__*/React__default["default"].memo(function (_ref) {
  var _ref$translations = _ref.translations,
    translations = _ref$translations === void 0 ? {} : _ref$translations,
    props = _objectWithoutProperties$3(_ref, _excluded$3);
  if (props.state.status === 'error') {
    return /*#__PURE__*/React__default["default"].createElement(ErrorScreen, {
      translations: translations === null || translations === void 0 ? void 0 : translations.errorScreen
    });
  }
  var hasCollections = props.state.collections.some(function (collection) {
    return collection.items.length > 0;
  });
  if (!props.state.query) {
    return /*#__PURE__*/React__default["default"].createElement(StartScreen, _extends$a({}, props, {
      hasCollections: hasCollections,
      translations: translations === null || translations === void 0 ? void 0 : translations.startScreen
    }));
  }
  if (hasCollections === false) {
    return /*#__PURE__*/React__default["default"].createElement(NoResultsScreen, _extends$a({}, props, {
      translations: translations === null || translations === void 0 ? void 0 : translations.noResultsScreen
    }));
  }
  return /*#__PURE__*/React__default["default"].createElement(ResultsScreen, props);
}, function areEqual(_prevProps, nextProps) {
  // We don't update the screen when Autocomplete is loading or stalled to
  // avoid UI flashes:
  //  - Empty screen → Results screen
  //  - NoResults screen → NoResults screen with another query
  return nextProps.state.status === 'loading' || nextProps.state.status === 'stalled';
});

var _excluded$2 = ["translations"];
function _extends$9() {
  _extends$9 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$9.apply(this, arguments);
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function SearchBox(_ref) {
  var _ref$translations = _ref.translations,
    translations = _ref$translations === void 0 ? {} : _ref$translations,
    props = _objectWithoutProperties$2(_ref, _excluded$2);
  var _translations$resetBu = translations.resetButtonTitle,
    resetButtonTitle = _translations$resetBu === void 0 ? 'Clear the query' : _translations$resetBu,
    _translations$resetBu2 = translations.resetButtonAriaLabel,
    resetButtonAriaLabel = _translations$resetBu2 === void 0 ? 'Clear the query' : _translations$resetBu2,
    _translations$cancelB = translations.cancelButtonText,
    cancelButtonText = _translations$cancelB === void 0 ? 'Cancel' : _translations$cancelB,
    _translations$cancelB2 = translations.cancelButtonAriaLabel,
    cancelButtonAriaLabel = _translations$cancelB2 === void 0 ? 'Cancel' : _translations$cancelB2;
  var _props$getFormProps = props.getFormProps({
      inputElement: props.inputRef.current
    }),
    onReset = _props$getFormProps.onReset;
  React__default["default"].useEffect(function () {
    if (props.autoFocus && props.inputRef.current) {
      props.inputRef.current.focus();
    }
  }, [props.autoFocus, props.inputRef]);
  React__default["default"].useEffect(function () {
    if (props.isFromSelection && props.inputRef.current) {
      props.inputRef.current.select();
    }
  }, [props.isFromSelection, props.inputRef]);
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("form", {
    className: "DocSearch-Form",
    onSubmit: function onSubmit(event) {
      event.preventDefault();
    },
    onReset: onReset
  }, /*#__PURE__*/React__default["default"].createElement("label", _extends$9({
    className: "DocSearch-MagnifierLabel"
  }, props.getLabelProps()), /*#__PURE__*/React__default["default"].createElement(SearchIcon, null)), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-LoadingIndicator"
  }, /*#__PURE__*/React__default["default"].createElement(LoadingIcon, null)), /*#__PURE__*/React__default["default"].createElement("input", _extends$9({
    className: "DocSearch-Input",
    ref: props.inputRef
  }, props.getInputProps({
    inputElement: props.inputRef.current,
    autoFocus: props.autoFocus,
    maxLength: MAX_QUERY_SIZE
  }))), /*#__PURE__*/React__default["default"].createElement("button", {
    type: "reset",
    title: resetButtonTitle,
    className: "DocSearch-Reset",
    "aria-label": resetButtonAriaLabel,
    hidden: !props.state.query
  }, /*#__PURE__*/React__default["default"].createElement(ResetIcon, null))), /*#__PURE__*/React__default["default"].createElement("button", {
    className: "DocSearch-Cancel",
    type: "reset",
    "aria-label": cancelButtonAriaLabel,
    onClick: props.onClose
  }, cancelButtonText));
}

var _excluded$1 = ["_highlightResult", "_snippetResult"];
function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function isLocalStorageSupported() {
  var key = '__TEST_KEY__';
  try {
    localStorage.setItem(key, '');
    localStorage.removeItem(key);
    return true;
  } catch (error) {
    return false;
  }
}
function createStorage(key) {
  if (isLocalStorageSupported() === false) {
    return {
      setItem: function setItem() {},
      getItem: function getItem() {
        return [];
      }
    };
  }
  return {
    setItem: function setItem(item) {
      return window.localStorage.setItem(key, JSON.stringify(item));
    },
    getItem: function getItem() {
      var item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : [];
    }
  };
}
function createStoredSearches(_ref) {
  var key = _ref.key,
    _ref$limit = _ref.limit,
    limit = _ref$limit === void 0 ? 5 : _ref$limit;
  var storage = createStorage(key);
  var items = storage.getItem().slice(0, limit);
  return {
    add: function add(item) {
      var _ref2 = item;
        _ref2._highlightResult;
        _ref2._snippetResult;
        var hit = _objectWithoutProperties$1(_ref2, _excluded$1);
      var isQueryAlreadySaved = items.findIndex(function (x) {
        return x.objectID === hit.objectID;
      });
      if (isQueryAlreadySaved > -1) {
        items.splice(isQueryAlreadySaved, 1);
      }
      items.unshift(hit);
      items = items.slice(0, limit);
      storage.setItem(items);
    },
    remove: function remove(item) {
      items = items.filter(function (x) {
        return x.objectID !== item.objectID;
      });
      storage.setItem(items);
    },
    getAll: function getAll() {
      return items;
    }
  };
}

function createBrowserLocalStorageCache(options) {
  const namespaceKey = `algoliasearch-client-js-${options.key}`;
  // eslint-disable-next-line functional/no-let
  let storage;
  const getStorage = () => {
    if (storage === undefined) {
      storage = options.localStorage || window.localStorage;
    }
    return storage;
  };
  const getNamespace = () => {
    return JSON.parse(getStorage().getItem(namespaceKey) || '{}');
  };
  const setNamespace = namespace => {
    getStorage().setItem(namespaceKey, JSON.stringify(namespace));
  };
  const removeOutdatedCacheItems = () => {
    const timeToLive = options.timeToLive ? options.timeToLive * 1000 : null;
    const namespace = getNamespace();
    const filteredNamespaceWithoutOldFormattedCacheItems = Object.fromEntries(Object.entries(namespace).filter(([, cacheItem]) => {
      return cacheItem.timestamp !== undefined;
    }));
    setNamespace(filteredNamespaceWithoutOldFormattedCacheItems);
    if (!timeToLive) return;
    const filteredNamespaceWithoutExpiredItems = Object.fromEntries(Object.entries(filteredNamespaceWithoutOldFormattedCacheItems).filter(([, cacheItem]) => {
      const currentTimestamp = new Date().getTime();
      const isExpired = cacheItem.timestamp + timeToLive < currentTimestamp;
      return !isExpired;
    }));
    setNamespace(filteredNamespaceWithoutExpiredItems);
  };
  return {
    get(key, defaultValue, events = {
      miss: () => Promise.resolve()
    }) {
      return Promise.resolve().then(() => {
        removeOutdatedCacheItems();
        const keyAsString = JSON.stringify(key);
        return getNamespace()[keyAsString];
      }).then(value => {
        return Promise.all([value ? value.value : defaultValue(), value !== undefined]);
      }).then(([value, exists]) => {
        return Promise.all([value, exists || events.miss(value)]);
      }).then(([value]) => value);
    },
    set(key, value) {
      return Promise.resolve().then(() => {
        const namespace = getNamespace();
        // eslint-disable-next-line functional/immutable-data
        namespace[JSON.stringify(key)] = {
          timestamp: new Date().getTime(),
          value
        };
        getStorage().setItem(namespaceKey, JSON.stringify(namespace));
        return value;
      });
    },
    delete(key) {
      return Promise.resolve().then(() => {
        const namespace = getNamespace();
        // eslint-disable-next-line functional/immutable-data
        delete namespace[JSON.stringify(key)];
        getStorage().setItem(namespaceKey, JSON.stringify(namespace));
      });
    },
    clear() {
      return Promise.resolve().then(() => {
        getStorage().removeItem(namespaceKey);
      });
    }
  };
}

// @todo Add logger on options to debug when caches go wrong.
function createFallbackableCache(options) {
  const caches = [...options.caches];
  const current = caches.shift(); // eslint-disable-line functional/immutable-data
  if (current === undefined) {
    return createNullCache();
  }
  return {
    get(key, defaultValue, events = {
      miss: () => Promise.resolve()
    }) {
      return current.get(key, defaultValue, events).catch(() => {
        return createFallbackableCache({
          caches
        }).get(key, defaultValue, events);
      });
    },
    set(key, value) {
      return current.set(key, value).catch(() => {
        return createFallbackableCache({
          caches
        }).set(key, value);
      });
    },
    delete(key) {
      return current.delete(key).catch(() => {
        return createFallbackableCache({
          caches
        }).delete(key);
      });
    },
    clear() {
      return current.clear().catch(() => {
        return createFallbackableCache({
          caches
        }).clear();
      });
    }
  };
}
function createNullCache() {
  return {
    get(_key, defaultValue, events = {
      miss: () => Promise.resolve()
    }) {
      const value = defaultValue();
      return value.then(result => Promise.all([result, events.miss(result)])).then(([result]) => result);
    },
    set(_key, value) {
      return Promise.resolve(value);
    },
    delete(_key) {
      return Promise.resolve();
    },
    clear() {
      return Promise.resolve();
    }
  };
}
function createInMemoryCache(options = {
  serializable: true
}) {
  // eslint-disable-next-line functional/no-let
  let cache = {};
  return {
    get(key, defaultValue, events = {
      miss: () => Promise.resolve()
    }) {
      const keyAsString = JSON.stringify(key);
      if (keyAsString in cache) {
        return Promise.resolve(options.serializable ? JSON.parse(cache[keyAsString]) : cache[keyAsString]);
      }
      const promise = defaultValue();
      const miss = events && events.miss || (() => Promise.resolve());
      return promise.then(value => miss(value)).then(() => promise);
    },
    set(key, value) {
      // eslint-disable-next-line functional/immutable-data
      cache[JSON.stringify(key)] = options.serializable ? JSON.stringify(value) : value;
      return Promise.resolve(value);
    },
    delete(key) {
      // eslint-disable-next-line functional/immutable-data
      delete cache[JSON.stringify(key)];
      return Promise.resolve();
    },
    clear() {
      cache = {};
      return Promise.resolve();
    }
  };
}
function createAuth(authMode, appId, apiKey) {
  const credentials = {
    'x-algolia-api-key': apiKey,
    'x-algolia-application-id': appId
  };
  return {
    headers() {
      return authMode === AuthMode.WithinHeaders ? credentials : {};
    },
    queryParameters() {
      return authMode === AuthMode.WithinQueryParameters ? credentials : {};
    }
  };
}

// eslint-disable-next-line functional/prefer-readonly-type
function shuffle(array) {
  let c = array.length - 1; // eslint-disable-line functional/no-let
  // eslint-disable-next-line functional/no-loop-statement
  for (c; c > 0; c--) {
    const b = Math.floor(Math.random() * (c + 1));
    const a = array[c];
    array[c] = array[b]; // eslint-disable-line functional/immutable-data, no-param-reassign
    array[b] = a; // eslint-disable-line functional/immutable-data, no-param-reassign
  }

  return array;
}
function addMethods(base, methods) {
  if (!methods) {
    return base;
  }
  Object.keys(methods).forEach(key => {
    // eslint-disable-next-line functional/immutable-data, no-param-reassign
    base[key] = methods[key](base);
  });
  return base;
}
function encode(format, ...args) {
  // eslint-disable-next-line functional/no-let
  let i = 0;
  return format.replace(/%s/g, () => encodeURIComponent(args[i++]));
}
const version$1 = '4.20.0';
const AuthMode = {
  /**
   * If auth credentials should be in query parameters.
   */
  WithinQueryParameters: 0,
  /**
   * If auth credentials should be in headers.
   */
  WithinHeaders: 1
};
function createMappedRequestOptions(requestOptions, timeout) {
  const options = requestOptions || {};
  const data = options.data || {};
  Object.keys(options).forEach(key => {
    if (['timeout', 'headers', 'queryParameters', 'data', 'cacheable'].indexOf(key) === -1) {
      data[key] = options[key]; // eslint-disable-line functional/immutable-data
    }
  });

  return {
    data: Object.entries(data).length > 0 ? data : undefined,
    timeout: options.timeout || timeout,
    headers: options.headers || {},
    queryParameters: options.queryParameters || {},
    cacheable: options.cacheable
  };
}
const CallEnum = {
  /**
   * If the host is read only.
   */
  Read: 1,
  /**
   * If the host is write only.
   */
  Write: 2,
  /**
   * If the host is both read and write.
   */
  Any: 3
};
const HostStatusEnum = {
  Up: 1,
  Down: 2,
  Timeouted: 3
};

// By default, API Clients at Algolia have expiration delay
// of 5 mins. In the JavaScript client, we have 2 mins.
const EXPIRATION_DELAY = 2 * 60 * 1000;
function createStatefulHost(host, status = HostStatusEnum.Up) {
  return {
    ...host,
    status,
    lastUpdate: Date.now()
  };
}
function isStatefulHostUp(host) {
  return host.status === HostStatusEnum.Up || Date.now() - host.lastUpdate > EXPIRATION_DELAY;
}
function isStatefulHostTimeouted(host) {
  return host.status === HostStatusEnum.Timeouted && Date.now() - host.lastUpdate <= EXPIRATION_DELAY;
}
function createStatelessHost(options) {
  if (typeof options === 'string') {
    return {
      protocol: 'https',
      url: options,
      accept: CallEnum.Any
    };
  }
  return {
    protocol: options.protocol || 'https',
    url: options.url,
    accept: options.accept || CallEnum.Any
  };
}
const MethodEnum = {
  Delete: 'DELETE',
  Get: 'GET',
  Post: 'POST',
  Put: 'PUT'
};
function createRetryableOptions(hostsCache, statelessHosts) {
  return Promise.all(statelessHosts.map(statelessHost => {
    return hostsCache.get(statelessHost, () => {
      return Promise.resolve(createStatefulHost(statelessHost));
    });
  })).then(statefulHosts => {
    const hostsUp = statefulHosts.filter(host => isStatefulHostUp(host));
    const hostsTimeouted = statefulHosts.filter(host => isStatefulHostTimeouted(host));
    /**
     * Note, we put the hosts that previously timeouted on the end of the list.
     */
    const hostsAvailable = [...hostsUp, ...hostsTimeouted];
    const statelessHostsAvailable = hostsAvailable.length > 0 ? hostsAvailable.map(host => createStatelessHost(host)) : statelessHosts;
    return {
      getTimeout(timeoutsCount, baseTimeout) {
        /**
         * Imagine that you have 4 hosts, if timeouts will increase
         * on the following way: 1 (timeouted) > 4 (timeouted) > 5 (200)
         *
         * Note that, the very next request, we start from the previous timeout
         *
         *  5 (timeouted) > 6 (timeouted) > 7 ...
         *
         * This strategy may need to be reviewed, but is the strategy on the our
         * current v3 version.
         */
        const timeoutMultiplier = hostsTimeouted.length === 0 && timeoutsCount === 0 ? 1 : hostsTimeouted.length + 3 + timeoutsCount;
        return timeoutMultiplier * baseTimeout;
      },
      statelessHosts: statelessHostsAvailable
    };
  });
}
const isNetworkError = ({
  isTimedOut,
  status
}) => {
  return !isTimedOut && ~~status === 0;
};
const isRetryable = response => {
  const status = response.status;
  const isTimedOut = response.isTimedOut;
  return isTimedOut || isNetworkError(response) || ~~(status / 100) !== 2 && ~~(status / 100) !== 4;
};
const isSuccess = ({
  status
}) => {
  return ~~(status / 100) === 2;
};
const retryDecision = (response, outcomes) => {
  if (isRetryable(response)) {
    return outcomes.onRetry(response);
  }
  if (isSuccess(response)) {
    return outcomes.onSuccess(response);
  }
  return outcomes.onFail(response);
};
function retryableRequest(transporter, statelessHosts, request, requestOptions) {
  const stackTrace = []; // eslint-disable-line functional/prefer-readonly-type
  /**
   * First we prepare the payload that do not depend from hosts.
   */
  const data = serializeData(request, requestOptions);
  const headers = serializeHeaders(transporter, requestOptions);
  const method = request.method;
  // On `GET`, the data is proxied to query parameters.
  const dataQueryParameters = request.method !== MethodEnum.Get ? {} : {
    ...request.data,
    ...requestOptions.data
  };
  const queryParameters = {
    'x-algolia-agent': transporter.userAgent.value,
    ...transporter.queryParameters,
    ...dataQueryParameters,
    ...requestOptions.queryParameters
  };
  let timeoutsCount = 0; // eslint-disable-line functional/no-let
  const retry = (hosts,
  // eslint-disable-line functional/prefer-readonly-type
  getTimeout) => {
    /**
     * We iterate on each host, until there is no host left.
     */
    const host = hosts.pop(); // eslint-disable-line functional/immutable-data
    if (host === undefined) {
      throw createRetryError(stackTraceWithoutCredentials(stackTrace));
    }
    const payload = {
      data,
      headers,
      method,
      url: serializeUrl(host, request.path, queryParameters),
      connectTimeout: getTimeout(timeoutsCount, transporter.timeouts.connect),
      responseTimeout: getTimeout(timeoutsCount, requestOptions.timeout)
    };
    /**
     * The stackFrame is pushed to the stackTrace so we
     * can have information about onRetry and onFailure
     * decisions.
     */
    const pushToStackTrace = response => {
      const stackFrame = {
        request: payload,
        response,
        host,
        triesLeft: hosts.length
      };
      // eslint-disable-next-line functional/immutable-data
      stackTrace.push(stackFrame);
      return stackFrame;
    };
    const decisions = {
      onSuccess: response => deserializeSuccess(response),
      onRetry(response) {
        const stackFrame = pushToStackTrace(response);
        /**
         * If response is a timeout, we increaset the number of
         * timeouts so we can increase the timeout later.
         */
        if (response.isTimedOut) {
          timeoutsCount++;
        }
        return Promise.all([
        /**
         * Failures are individually send the logger, allowing
         * the end user to debug / store stack frames even
         * when a retry error does not happen.
         */
        transporter.logger.info('Retryable failure', stackFrameWithoutCredentials(stackFrame)),
        /**
         * We also store the state of the host in failure cases. If the host, is
         * down it will remain down for the next 2 minutes. In a timeout situation,
         * this host will be added end of the list of hosts on the next request.
         */
        transporter.hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? HostStatusEnum.Timeouted : HostStatusEnum.Down))]).then(() => retry(hosts, getTimeout));
      },
      onFail(response) {
        pushToStackTrace(response);
        throw deserializeFailure(response, stackTraceWithoutCredentials(stackTrace));
      }
    };
    return transporter.requester.send(payload).then(response => {
      return retryDecision(response, decisions);
    });
  };
  /**
   * Finally, for each retryable host perform request until we got a non
   * retryable response. Some notes here:
   *
   * 1. The reverse here is applied so we can apply a `pop` later on => more performant.
   * 2. We also get from the retryable options a timeout multiplier that is tailored
   * for the current context.
   */
  return createRetryableOptions(transporter.hostsCache, statelessHosts).then(options => {
    return retry([...options.statelessHosts].reverse(), options.getTimeout);
  });
}
function createTransporter(options) {
  const {
    hostsCache,
    logger,
    requester,
    requestsCache,
    responsesCache,
    timeouts,
    userAgent,
    hosts,
    queryParameters,
    headers
  } = options;
  const transporter = {
    hostsCache,
    logger,
    requester,
    requestsCache,
    responsesCache,
    timeouts,
    userAgent,
    headers,
    queryParameters,
    hosts: hosts.map(host => createStatelessHost(host)),
    read(request, requestOptions) {
      /**
       * First, we compute the user request options. Now, keep in mind,
       * that using request options the user is able to modified the intire
       * payload of the request. Such as headers, query parameters, and others.
       */
      const mappedRequestOptions = createMappedRequestOptions(requestOptions, transporter.timeouts.read);
      const createRetryableRequest = () => {
        /**
         * Then, we prepare a function factory that contains the construction of
         * the retryable request. At this point, we may *not* perform the actual
         * request. But we want to have the function factory ready.
         */
        return retryableRequest(transporter, transporter.hosts.filter(host => (host.accept & CallEnum.Read) !== 0), request, mappedRequestOptions);
      };
      /**
       * Once we have the function factory ready, we need to determine of the
       * request is "cacheable" - should be cached. Note that, once again,
       * the user can force this option.
       */
      const cacheable = mappedRequestOptions.cacheable !== undefined ? mappedRequestOptions.cacheable : request.cacheable;
      /**
       * If is not "cacheable", we immediatly trigger the retryable request, no
       * need to check cache implementations.
       */
      if (cacheable !== true) {
        return createRetryableRequest();
      }
      /**
       * If the request is "cacheable", we need to first compute the key to ask
       * the cache implementations if this request is on progress or if the
       * response already exists on the cache.
       */
      const key = {
        request,
        mappedRequestOptions,
        transporter: {
          queryParameters: transporter.queryParameters,
          headers: transporter.headers
        }
      };
      /**
       * With the computed key, we first ask the responses cache
       * implemention if this request was been resolved before.
       */
      return transporter.responsesCache.get(key, () => {
        /**
         * If the request has never resolved before, we actually ask if there
         * is a current request with the same key on progress.
         */
        return transporter.requestsCache.get(key, () => {
          return transporter.requestsCache
          /**
           * Finally, if there is no request in progress with the same key,
           * this `createRetryableRequest()` will actually trigger the
           * retryable request.
           */.set(key, createRetryableRequest()).then(response => Promise.all([transporter.requestsCache.delete(key), response]), err => Promise.all([transporter.requestsCache.delete(key), Promise.reject(err)])).then(([_, response]) => response);
        });
      }, {
        /**
         * Of course, once we get this response back from the server, we
         * tell response cache to actually store the received response
         * to be used later.
         */
        miss: response => transporter.responsesCache.set(key, response)
      });
    },
    write(request, requestOptions) {
      /**
       * On write requests, no cache mechanisms are applied, and we
       * proxy the request immediately to the requester.
       */
      return retryableRequest(transporter, transporter.hosts.filter(host => (host.accept & CallEnum.Write) !== 0), request, createMappedRequestOptions(requestOptions, transporter.timeouts.write));
    }
  };
  return transporter;
}
function createUserAgent(version) {
  const userAgent = {
    value: `Algolia for JavaScript (${version})`,
    add(options) {
      const addedUserAgent = `; ${options.segment}${options.version !== undefined ? ` (${options.version})` : ''}`;
      if (userAgent.value.indexOf(addedUserAgent) === -1) {
        // eslint-disable-next-line functional/immutable-data
        userAgent.value = `${userAgent.value}${addedUserAgent}`;
      }
      return userAgent;
    }
  };
  return userAgent;
}
function deserializeSuccess(response) {
  // eslint-disable-next-line functional/no-try-statement
  try {
    return JSON.parse(response.content);
  } catch (e) {
    throw createDeserializationError(e.message, response);
  }
}
function deserializeFailure({
  content,
  status
}, stackFrame) {
  // eslint-disable-next-line functional/no-let
  let message = content;
  // eslint-disable-next-line functional/no-try-statement
  try {
    message = JSON.parse(content).message;
  } catch (e) {
    // ..
  }
  return createApiError(message, status, stackFrame);
}
function serializeUrl(host, path, queryParameters) {
  const queryParametersAsString = serializeQueryParameters(queryParameters);
  // eslint-disable-next-line functional/no-let
  let url = `${host.protocol}://${host.url}/${path.charAt(0) === '/' ? path.substr(1) : path}`;
  if (queryParametersAsString.length) {
    url += `?${queryParametersAsString}`;
  }
  return url;
}
function serializeQueryParameters(parameters) {
  const isObjectOrArray = value => Object.prototype.toString.call(value) === '[object Object]' || Object.prototype.toString.call(value) === '[object Array]';
  return Object.keys(parameters).map(key => encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key])).join('&');
}
function serializeData(request, requestOptions) {
  if (request.method === MethodEnum.Get || request.data === undefined && requestOptions.data === undefined) {
    return undefined;
  }
  const data = Array.isArray(request.data) ? request.data : {
    ...request.data,
    ...requestOptions.data
  };
  return JSON.stringify(data);
}
function serializeHeaders(transporter, requestOptions) {
  const headers = {
    ...transporter.headers,
    ...requestOptions.headers
  };
  const serializedHeaders = {};
  Object.keys(headers).forEach(header => {
    const value = headers[header];
    // @ts-ignore
    // eslint-disable-next-line functional/immutable-data
    serializedHeaders[header.toLowerCase()] = value;
  });
  return serializedHeaders;
}
function stackTraceWithoutCredentials(stackTrace) {
  return stackTrace.map(stackFrame => stackFrameWithoutCredentials(stackFrame));
}
function stackFrameWithoutCredentials(stackFrame) {
  const modifiedHeaders = stackFrame.request.headers['x-algolia-api-key'] ? {
    'x-algolia-api-key': '*****'
  } : {};
  return {
    ...stackFrame,
    request: {
      ...stackFrame.request,
      headers: {
        ...stackFrame.request.headers,
        ...modifiedHeaders
      }
    }
  };
}
function createApiError(message, status, transporterStackTrace) {
  return {
    name: 'ApiError',
    message,
    status,
    transporterStackTrace
  };
}
function createDeserializationError(message, response) {
  return {
    name: 'DeserializationError',
    message,
    response
  };
}
function createRetryError(transporterStackTrace) {
  return {
    name: 'RetryError',
    message: 'Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.',
    transporterStackTrace
  };
}
const createSearchClient = options => {
  const appId = options.appId;
  const auth = createAuth(options.authMode !== undefined ? options.authMode : AuthMode.WithinHeaders, appId, options.apiKey);
  const transporter = createTransporter({
    hosts: [{
      url: `${appId}-dsn.algolia.net`,
      accept: CallEnum.Read
    }, {
      url: `${appId}.algolia.net`,
      accept: CallEnum.Write
    }].concat(shuffle([{
      url: `${appId}-1.algolianet.com`
    }, {
      url: `${appId}-2.algolianet.com`
    }, {
      url: `${appId}-3.algolianet.com`
    }])),
    ...options,
    headers: {
      ...auth.headers(),
      ...{
        'content-type': 'application/x-www-form-urlencoded'
      },
      ...options.headers
    },
    queryParameters: {
      ...auth.queryParameters(),
      ...options.queryParameters
    }
  });
  const base = {
    transporter,
    appId,
    addAlgoliaAgent(segment, version) {
      transporter.userAgent.add({
        segment,
        version
      });
    },
    clearCache() {
      return Promise.all([transporter.requestsCache.clear(), transporter.responsesCache.clear()]).then(() => undefined);
    }
  };
  return addMethods(base, options.methods);
};
const customRequest = base => {
  return (request, requestOptions) => {
    if (request.method === MethodEnum.Get) {
      return base.transporter.read(request, requestOptions);
    }
    return base.transporter.write(request, requestOptions);
  };
};
const initIndex = base => {
  return (indexName, options = {}) => {
    const searchIndex = {
      transporter: base.transporter,
      appId: base.appId,
      indexName
    };
    return addMethods(searchIndex, options.methods);
  };
};
const multipleQueries = base => {
  return (queries, requestOptions) => {
    const requests = queries.map(query => {
      return {
        ...query,
        params: serializeQueryParameters(query.params || {})
      };
    });
    return base.transporter.read({
      method: MethodEnum.Post,
      path: '1/indexes/*/queries',
      data: {
        requests
      },
      cacheable: true
    }, requestOptions);
  };
};
const multipleSearchForFacetValues = base => {
  return (queries, requestOptions) => {
    return Promise.all(queries.map(query => {
      const {
        facetName,
        facetQuery,
        ...params
      } = query.params;
      return initIndex(base)(query.indexName, {
        methods: {
          searchForFacetValues
        }
      }).searchForFacetValues(facetName, facetQuery, {
        ...requestOptions,
        ...params
      });
    }));
  };
};
const findAnswers = base => {
  return (query, queryLanguages, requestOptions) => {
    return base.transporter.read({
      method: MethodEnum.Post,
      path: encode('1/answers/%s/prediction', base.indexName),
      data: {
        query,
        queryLanguages
      },
      cacheable: true
    }, requestOptions);
  };
};
const search = base => {
  return (query, requestOptions) => {
    return base.transporter.read({
      method: MethodEnum.Post,
      path: encode('1/indexes/%s/query', base.indexName),
      data: {
        query
      },
      cacheable: true
    }, requestOptions);
  };
};
const searchForFacetValues = base => {
  return (facetName, facetQuery, requestOptions) => {
    return base.transporter.read({
      method: MethodEnum.Post,
      path: encode('1/indexes/%s/facets/%s/query', base.indexName, facetName),
      data: {
        facetQuery
      },
      cacheable: true
    }, requestOptions);
  };
};
const LogLevelEnum = {
  Debug: 1,
  Info: 2,
  Error: 3
};

/* eslint no-console: 0 */
function createConsoleLogger(logLevel) {
  return {
    debug(message, args) {
      if (LogLevelEnum.Debug >= logLevel) {
        console.debug(message, args);
      }
      return Promise.resolve();
    },
    info(message, args) {
      if (LogLevelEnum.Info >= logLevel) {
        console.info(message, args);
      }
      return Promise.resolve();
    },
    error(message, args) {
      console.error(message, args);
      return Promise.resolve();
    }
  };
}
function createBrowserXhrRequester() {
  return {
    send(request) {
      return new Promise(resolve => {
        const baseRequester = new XMLHttpRequest();
        baseRequester.open(request.method, request.url, true);
        Object.keys(request.headers).forEach(key => baseRequester.setRequestHeader(key, request.headers[key]));
        const createTimeout = (timeout, content) => {
          return setTimeout(() => {
            baseRequester.abort();
            resolve({
              status: 0,
              content,
              isTimedOut: true
            });
          }, timeout * 1000);
        };
        const connectTimeout = createTimeout(request.connectTimeout, 'Connection timeout');
        // eslint-disable-next-line functional/no-let
        let responseTimeout;
        // eslint-disable-next-line functional/immutable-data
        baseRequester.onreadystatechange = () => {
          if (baseRequester.readyState > baseRequester.OPENED && responseTimeout === undefined) {
            clearTimeout(connectTimeout);
            responseTimeout = createTimeout(request.responseTimeout, 'Socket timeout');
          }
        };
        // eslint-disable-next-line functional/immutable-data
        baseRequester.onerror = () => {
          // istanbul ignore next
          if (baseRequester.status === 0) {
            clearTimeout(connectTimeout);
            clearTimeout(responseTimeout);
            resolve({
              content: baseRequester.responseText || 'Network request failed',
              status: baseRequester.status,
              isTimedOut: false
            });
          }
        };
        //  eslint-disable-next-line functional/immutable-data
        baseRequester.onload = () => {
          clearTimeout(connectTimeout);
          clearTimeout(responseTimeout);
          resolve({
            content: baseRequester.responseText,
            status: baseRequester.status,
            isTimedOut: false
          });
        };
        baseRequester.send(request.data);
      });
    }
  };
}
function algoliasearch(appId, apiKey, options) {
  const commonOptions = {
    appId,
    apiKey,
    timeouts: {
      connect: 1,
      read: 2,
      write: 30
    },
    requester: createBrowserXhrRequester(),
    logger: createConsoleLogger(LogLevelEnum.Error),
    responsesCache: createInMemoryCache(),
    requestsCache: createInMemoryCache({
      serializable: false
    }),
    hostsCache: createFallbackableCache({
      caches: [createBrowserLocalStorageCache({
        key: `${version$1}-${appId}`
      }), createInMemoryCache()]
    }),
    userAgent: createUserAgent(version$1).add({
      segment: 'Browser',
      version: 'lite'
    }),
    authMode: AuthMode.WithinQueryParameters
  };
  return createSearchClient({
    ...commonOptions,
    ...options,
    methods: {
      search: multipleQueries,
      searchForFacetValues: multipleSearchForFacetValues,
      multipleQueries,
      multipleSearchForFacetValues,
      customRequest,
      initIndex: base => indexName => {
        return initIndex(base)(indexName, {
          methods: {
            search,
            searchForFacetValues,
            findAnswers
          }
        });
      }
    }
  });
}
// eslint-disable-next-line functional/immutable-data
algoliasearch.version = version$1;

var version = '3.5.2';

function useSearchClient(appId, apiKey, transformSearchClient) {
  var searchClient = React__default["default"].useMemo(function () {
    var client = algoliasearch(appId, apiKey);
    client.addAlgoliaAgent('docsearch', version); // Since DocSearch.js relies on DocSearch React with an alias to Preact,
    // we cannot add the `docsearch-react` user agent by default, otherwise
    // it would also be sent on a DocSearch.js integration.
    // We therefore only add the `docsearch-react` user agent if `docsearch.js`
    // is not present.

    if (/docsearch.js \(.*\)/.test(client.transporter.userAgent.value) === false) {
      client.addAlgoliaAgent('docsearch-react', version);
    }
    return transformSearchClient(client);
  }, [appId, apiKey, transformSearchClient]);
  return searchClient;
}

function useTouchEvents(_ref) {
  var getEnvironmentProps = _ref.getEnvironmentProps,
    panelElement = _ref.panelElement,
    formElement = _ref.formElement,
    inputElement = _ref.inputElement;
  React__default["default"].useEffect(function () {
    if (!(panelElement && formElement && inputElement)) {
      return undefined;
    }
    var _getEnvironmentProps = getEnvironmentProps({
        panelElement: panelElement,
        formElement: formElement,
        inputElement: inputElement
      }),
      onTouchStart = _getEnvironmentProps.onTouchStart,
      onTouchMove = _getEnvironmentProps.onTouchMove;
    window.addEventListener('touchstart', onTouchStart);
    window.addEventListener('touchmove', onTouchMove);
    return function () {
      window.removeEventListener('touchstart', onTouchStart);
      window.removeEventListener('touchmove', onTouchMove);
    };
  }, [getEnvironmentProps, panelElement, formElement, inputElement]);
}

function useTrapFocus(_ref) {
  var container = _ref.container;
  React__default["default"].useEffect(function () {
    if (!container) {
      return undefined;
    }
    var focusableElements = container.querySelectorAll('a[href]:not([disabled]), button:not([disabled]), input:not([disabled])');
    var firstElement = focusableElements[0];
    var lastElement = focusableElements[focusableElements.length - 1];
    function trapFocus(event) {
      if (event.key !== 'Tab') {
        return;
      }
      if (event.shiftKey) {
        if (document.activeElement === firstElement) {
          event.preventDefault();
          lastElement.focus();
        }
      } else if (document.activeElement === lastElement) {
        event.preventDefault();
        firstElement.focus();
      }
    }
    container.addEventListener('keydown', trapFocus);
    return function () {
      container.removeEventListener('keydown', trapFocus);
    };
  }, [container]);
}

var _excluded = ["footer", "searchBox"];
function _extends$8() {
  _extends$8 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray$2(arr, i) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$2(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function DocSearchModal(_ref) {
  var appId = _ref.appId,
    apiKey = _ref.apiKey,
    indexName = _ref.indexName,
    _ref$placeholder = _ref.placeholder,
    placeholder = _ref$placeholder === void 0 ? 'Search docs' : _ref$placeholder,
    searchParameters = _ref.searchParameters,
    maxResultsPerGroup = _ref.maxResultsPerGroup,
    _ref$onClose = _ref.onClose,
    onClose = _ref$onClose === void 0 ? noop$1 : _ref$onClose,
    _ref$transformItems = _ref.transformItems,
    transformItems = _ref$transformItems === void 0 ? identity$1 : _ref$transformItems,
    _ref$hitComponent = _ref.hitComponent,
    hitComponent = _ref$hitComponent === void 0 ? Hit : _ref$hitComponent,
    _ref$resultsFooterCom = _ref.resultsFooterComponent,
    resultsFooterComponent = _ref$resultsFooterCom === void 0 ? function () {
      return null;
    } : _ref$resultsFooterCom,
    navigator = _ref.navigator,
    _ref$initialScrollY = _ref.initialScrollY,
    initialScrollY = _ref$initialScrollY === void 0 ? 0 : _ref$initialScrollY,
    _ref$transformSearchC = _ref.transformSearchClient,
    transformSearchClient = _ref$transformSearchC === void 0 ? identity$1 : _ref$transformSearchC,
    _ref$disableUserPerso = _ref.disableUserPersonalization,
    disableUserPersonalization = _ref$disableUserPerso === void 0 ? false : _ref$disableUserPerso,
    _ref$initialQuery = _ref.initialQuery,
    initialQueryFromProp = _ref$initialQuery === void 0 ? '' : _ref$initialQuery,
    _ref$translations = _ref.translations,
    translations = _ref$translations === void 0 ? {} : _ref$translations,
    getMissingResultsUrl = _ref.getMissingResultsUrl,
    _ref$insights = _ref.insights,
    insights = _ref$insights === void 0 ? false : _ref$insights;
  var footerTranslations = translations.footer,
    searchBoxTranslations = translations.searchBox,
    screenStateTranslations = _objectWithoutProperties(translations, _excluded);
  var _React$useState = React__default["default"].useState({
      query: '',
      collections: [],
      completion: null,
      context: {},
      isOpen: false,
      activeItemId: null,
      status: 'idle'
    }),
    _React$useState2 = _slicedToArray$2(_React$useState, 2),
    state = _React$useState2[0],
    setState = _React$useState2[1];
  var containerRef = React__default["default"].useRef(null);
  var modalRef = React__default["default"].useRef(null);
  var formElementRef = React__default["default"].useRef(null);
  var dropdownRef = React__default["default"].useRef(null);
  var inputRef = React__default["default"].useRef(null);
  var snippetLength = React__default["default"].useRef(10);
  var initialQueryFromSelection = React__default["default"].useRef(typeof window !== 'undefined' ? window.getSelection().toString().slice(0, MAX_QUERY_SIZE) : '').current;
  var initialQuery = React__default["default"].useRef(initialQueryFromProp || initialQueryFromSelection).current;
  var searchClient = useSearchClient(appId, apiKey, transformSearchClient);
  var favoriteSearches = React__default["default"].useRef(createStoredSearches({
    key: "__DOCSEARCH_FAVORITE_SEARCHES__".concat(indexName),
    limit: 10
  })).current;
  var recentSearches = React__default["default"].useRef(createStoredSearches({
    key: "__DOCSEARCH_RECENT_SEARCHES__".concat(indexName),
    // We display 7 recent searches and there's no favorites, but only
    // 4 when there are favorites.
    limit: favoriteSearches.getAll().length === 0 ? 7 : 4
  })).current;
  var saveRecentSearch = React__default["default"].useCallback(function saveRecentSearch(item) {
    if (disableUserPersonalization) {
      return;
    } // We don't store `content` record, but their parent if available.

    var search = item.type === 'content' ? item.__docsearch_parent : item; // We save the recent search only if it's not favorited.

    if (search && favoriteSearches.getAll().findIndex(function (x) {
      return x.objectID === search.objectID;
    }) === -1) {
      recentSearches.add(search);
    }
  }, [favoriteSearches, recentSearches, disableUserPersonalization]);
  var sendItemClickEvent = React__default["default"].useCallback(function (item) {
    if (!state.context.algoliaInsightsPlugin || !item.__autocomplete_id) return;
    var insightsItem = item;
    var insightsClickParams = {
      eventName: 'Item Selected',
      index: insightsItem.__autocomplete_indexName,
      items: [insightsItem],
      positions: [item.__autocomplete_id],
      queryID: insightsItem.__autocomplete_queryID
    };
    state.context.algoliaInsightsPlugin.insights.clickedObjectIDsAfterSearch(insightsClickParams);
  }, [state.context.algoliaInsightsPlugin]);
  var autocomplete = React__default["default"].useMemo(function () {
    return createAutocomplete({
      id: 'docsearch',
      defaultActiveItemId: 0,
      placeholder: placeholder,
      openOnFocus: true,
      initialState: {
        query: initialQuery,
        context: {
          searchSuggestions: []
        }
      },
      insights: insights,
      navigator: navigator,
      onStateChange: function onStateChange(props) {
        setState(props.state);
      },
      getSources: function getSources(_ref2) {
        var query = _ref2.query,
          sourcesState = _ref2.state,
          setContext = _ref2.setContext,
          setStatus = _ref2.setStatus;
        if (!query) {
          if (disableUserPersonalization) {
            return [];
          }
          return [{
            sourceId: 'recentSearches',
            onSelect: function onSelect(_ref3) {
              var item = _ref3.item,
                event = _ref3.event;
              saveRecentSearch(item);
              if (!isModifierEvent(event)) {
                onClose();
              }
            },
            getItemUrl: function getItemUrl(_ref4) {
              var item = _ref4.item;
              return item.url;
            },
            getItems: function getItems() {
              return recentSearches.getAll();
            }
          }, {
            sourceId: 'favoriteSearches',
            onSelect: function onSelect(_ref5) {
              var item = _ref5.item,
                event = _ref5.event;
              saveRecentSearch(item);
              if (!isModifierEvent(event)) {
                onClose();
              }
            },
            getItemUrl: function getItemUrl(_ref6) {
              var item = _ref6.item;
              return item.url;
            },
            getItems: function getItems() {
              return favoriteSearches.getAll();
            }
          }];
        }
        var insightsActive = Boolean(insights);
        return searchClient.search([{
          query: query,
          indexName: indexName,
          params: _objectSpread({
            attributesToRetrieve: ['hierarchy.lvl0', 'hierarchy.lvl1', 'hierarchy.lvl2', 'hierarchy.lvl3', 'hierarchy.lvl4', 'hierarchy.lvl5', 'hierarchy.lvl6', 'content', 'type', 'url'],
            attributesToSnippet: ["hierarchy.lvl1:".concat(snippetLength.current), "hierarchy.lvl2:".concat(snippetLength.current), "hierarchy.lvl3:".concat(snippetLength.current), "hierarchy.lvl4:".concat(snippetLength.current), "hierarchy.lvl5:".concat(snippetLength.current), "hierarchy.lvl6:".concat(snippetLength.current), "content:".concat(snippetLength.current)],
            snippetEllipsisText: '…',
            highlightPreTag: '<mark>',
            highlightPostTag: '</mark>',
            hitsPerPage: 20,
            clickAnalytics: insightsActive
          }, searchParameters)
        }]).catch(function (error) {
          // The Algolia `RetryError` happens when all the servers have
          // failed, meaning that there's no chance the response comes
          // back. This is the right time to display an error.
          // See https://github.com/algolia/algoliasearch-client-javascript/blob/2ffddf59bc765cd1b664ee0346b28f00229d6e12/packages/transporter/src/errors/createRetryError.ts#L5
          if (error.name === 'RetryError') {
            setStatus('error');
          }
          throw error;
        }).then(function (_ref7) {
          var results = _ref7.results;
          var firstResult = results[0];
          var hits = firstResult.hits,
            nbHits = firstResult.nbHits;
          var sources = groupBy(hits, function (hit) {
            return removeHighlightTags(hit);
          }, maxResultsPerGroup); // We store the `lvl0`s to display them as search suggestions
          // in the "no results" screen.

          if (sourcesState.context.searchSuggestions.length < Object.keys(sources).length) {
            setContext({
              searchSuggestions: Object.keys(sources)
            });
          }
          setContext({
            nbHits: nbHits
          });
          var insightsParams = {};
          if (insightsActive) {
            insightsParams = {
              __autocomplete_indexName: indexName,
              __autocomplete_queryID: firstResult.queryID,
              __autocomplete_algoliaCredentials: {
                appId: appId,
                apiKey: apiKey
              }
            };
          }
          return Object.values(sources).map(function (items, index) {
            return {
              sourceId: "hits".concat(index),
              onSelect: function onSelect(_ref8) {
                var item = _ref8.item,
                  event = _ref8.event;
                saveRecentSearch(item);
                if (!isModifierEvent(event)) {
                  onClose();
                }
              },
              getItemUrl: function getItemUrl(_ref9) {
                var item = _ref9.item;
                return item.url;
              },
              getItems: function getItems() {
                return Object.values(groupBy(items, function (item) {
                  return item.hierarchy.lvl1;
                }, maxResultsPerGroup)).map(transformItems).map(function (groupedHits) {
                  return groupedHits.map(function (item) {
                    var parent = null;
                    var potentialParent = groupedHits.find(function (siblingItem) {
                      return siblingItem.type === 'lvl1' && siblingItem.hierarchy.lvl1 === item.hierarchy.lvl1;
                    });
                    if (item.type !== 'lvl1' && potentialParent) {
                      parent = potentialParent;
                    }
                    return _objectSpread(_objectSpread({}, item), {}, {
                      __docsearch_parent: parent
                    }, insightsParams);
                  });
                }).flat();
              }
            };
          });
        });
      }
    });
  }, [indexName, searchParameters, maxResultsPerGroup, searchClient, onClose, recentSearches, favoriteSearches, saveRecentSearch, initialQuery, placeholder, navigator, transformItems, disableUserPersonalization, insights, appId, apiKey]);
  var getEnvironmentProps = autocomplete.getEnvironmentProps,
    getRootProps = autocomplete.getRootProps,
    refresh = autocomplete.refresh;
  useTouchEvents({
    getEnvironmentProps: getEnvironmentProps,
    panelElement: dropdownRef.current,
    formElement: formElementRef.current,
    inputElement: inputRef.current
  });
  useTrapFocus({
    container: containerRef.current
  });
  React__default["default"].useEffect(function () {
    document.body.classList.add('DocSearch--active');
    return function () {
      var _window$scrollTo, _window;
      document.body.classList.remove('DocSearch--active'); // IE11 doesn't support `scrollTo` so we check that the method exists
      // first.

      (_window$scrollTo = (_window = window).scrollTo) === null || _window$scrollTo === void 0 ? void 0 : _window$scrollTo.call(_window, 0, initialScrollY);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  React__default["default"].useEffect(function () {
    var isMobileMediaQuery = window.matchMedia('(max-width: 768px)');
    if (isMobileMediaQuery.matches) {
      snippetLength.current = 5;
    }
  }, []);
  React__default["default"].useEffect(function () {
    if (dropdownRef.current) {
      dropdownRef.current.scrollTop = 0;
    }
  }, [state.query]); // We don't focus the input when there's an initial query (i.e. Selection
  // Search) because users rather want to see the results directly, without the
  // keyboard appearing.
  // We therefore need to refresh the autocomplete instance to load all the
  // results, which is usually triggered on focus.

  React__default["default"].useEffect(function () {
    if (initialQuery.length > 0) {
      refresh();
      if (inputRef.current) {
        inputRef.current.focus();
      }
    }
  }, [initialQuery, refresh]); // We rely on a CSS property to set the modal height to the full viewport height
  // because all mobile browsers don't compute their height the same way.
  // See https://css-tricks.com/the-trick-to-viewport-units-on-mobile/

  React__default["default"].useEffect(function () {
    function setFullViewportHeight() {
      if (modalRef.current) {
        var vh = window.innerHeight * 0.01;
        modalRef.current.style.setProperty('--docsearch-vh', "".concat(vh, "px"));
      }
    }
    setFullViewportHeight();
    window.addEventListener('resize', setFullViewportHeight);
    return function () {
      window.removeEventListener('resize', setFullViewportHeight);
    };
  }, []);
  return /*#__PURE__*/React__default["default"].createElement("div", _extends$8({
    ref: containerRef
  }, getRootProps({
    'aria-expanded': true
  }), {
    className: ['DocSearch', 'DocSearch-Container', state.status === 'stalled' && 'DocSearch-Container--Stalled', state.status === 'error' && 'DocSearch-Container--Errored'].filter(Boolean).join(' '),
    role: "button",
    tabIndex: 0,
    onMouseDown: function onMouseDown(event) {
      if (event.target === event.currentTarget) {
        onClose();
      }
    }
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Modal",
    ref: modalRef
  }, /*#__PURE__*/React__default["default"].createElement("header", {
    className: "DocSearch-SearchBar",
    ref: formElementRef
  }, /*#__PURE__*/React__default["default"].createElement(SearchBox, _extends$8({}, autocomplete, {
    state: state,
    autoFocus: initialQuery.length === 0,
    inputRef: inputRef,
    isFromSelection: Boolean(initialQuery) && initialQuery === initialQueryFromSelection,
    translations: searchBoxTranslations,
    onClose: onClose
  }))), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "DocSearch-Dropdown",
    ref: dropdownRef
  }, /*#__PURE__*/React__default["default"].createElement(ScreenState, _extends$8({}, autocomplete, {
    indexName: indexName,
    state: state,
    hitComponent: hitComponent,
    resultsFooterComponent: resultsFooterComponent,
    disableUserPersonalization: disableUserPersonalization,
    recentSearches: recentSearches,
    favoriteSearches: favoriteSearches,
    inputRef: inputRef,
    translations: screenStateTranslations,
    getMissingResultsUrl: getMissingResultsUrl,
    onItemClick: function onItemClick(item, event) {
      // If insights is active, send insights click event
      sendItemClickEvent(item);
      saveRecentSearch(item);
      if (!isModifierEvent(event)) {
        onClose();
      }
    }
  }))), /*#__PURE__*/React__default["default"].createElement("footer", {
    className: "DocSearch-Footer"
  }, /*#__PURE__*/React__default["default"].createElement(Footer, {
    translations: footerTranslations
  }))));
}

function isEditingContent(event) {
  var element = event.target;
  var tagName = element.tagName;
  return element.isContentEditable || tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
}
function useDocSearchKeyboardEvents(_ref) {
  var isOpen = _ref.isOpen,
    onOpen = _ref.onOpen,
    onClose = _ref.onClose,
    onInput = _ref.onInput,
    searchButtonRef = _ref.searchButtonRef;
  React__default["default"].useEffect(function () {
    function onKeyDown(event) {
      var _event$key;
      function open() {
        // We check that no other DocSearch modal is showing before opening
        // another one.
        if (!document.body.classList.contains('DocSearch--active')) {
          onOpen();
        }
      }
      if (event.keyCode === 27 && isOpen ||
      // The `Cmd+K` shortcut both opens and closes the modal.
      // We need to check for `event.key` because it can be `undefined` with
      // Chrome's autofill feature.
      // See https://github.com/paperjs/paper.js/issues/1398
      ((_event$key = event.key) === null || _event$key === void 0 ? void 0 : _event$key.toLowerCase()) === 'k' && (event.metaKey || event.ctrlKey) ||
      // The `/` shortcut opens but doesn't close the modal because it's
      // a character.
      !isEditingContent(event) && event.key === '/' && !isOpen) {
        event.preventDefault();
        if (isOpen) {
          onClose();
        } else if (!document.body.classList.contains('DocSearch--active')) {
          open();
        }
      }
      if (searchButtonRef && searchButtonRef.current === document.activeElement && onInput) {
        if (/[a-zA-Z0-9]/.test(String.fromCharCode(event.keyCode))) {
          onInput(event);
        }
      }
    }
    window.addEventListener('keydown', onKeyDown);
    return function () {
      window.removeEventListener('keydown', onKeyDown);
    };
  }, [isOpen, onOpen, onClose, onInput, searchButtonRef]);
}

function _extends$7() {
  _extends$7 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$1(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr)) return arr;
}
function DocSearch(props) {
  var _props$translations, _props$translations2;
  var searchButtonRef = React__default["default"].useRef(null);
  var _React$useState = React__default["default"].useState(false),
    _React$useState2 = _slicedToArray$1(_React$useState, 2),
    isOpen = _React$useState2[0],
    setIsOpen = _React$useState2[1];
  var _React$useState3 = React__default["default"].useState((props === null || props === void 0 ? void 0 : props.initialQuery) || undefined),
    _React$useState4 = _slicedToArray$1(_React$useState3, 2),
    initialQuery = _React$useState4[0],
    setInitialQuery = _React$useState4[1];
  var onOpen = React__default["default"].useCallback(function () {
    setIsOpen(true);
  }, [setIsOpen]);
  var onClose = React__default["default"].useCallback(function () {
    setIsOpen(false);
  }, [setIsOpen]);
  var onInput = React__default["default"].useCallback(function (event) {
    setIsOpen(true);
    setInitialQuery(event.key);
  }, [setIsOpen, setInitialQuery]);
  useDocSearchKeyboardEvents({
    isOpen: isOpen,
    onOpen: onOpen,
    onClose: onClose,
    onInput: onInput,
    searchButtonRef: searchButtonRef
  });
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement(DocSearchButton, {
    ref: searchButtonRef,
    translations: props === null || props === void 0 || (_props$translations = props.translations) === null || _props$translations === void 0 ? void 0 : _props$translations.button,
    onClick: onOpen
  }), isOpen && /*#__PURE__*/reactDom.createPortal( /*#__PURE__*/React__default["default"].createElement(DocSearchModal, _extends$7({}, props, {
    initialScrollY: window.scrollY,
    initialQuery: initialQuery,
    translations: props === null || props === void 0 || (_props$translations2 = props.translations) === null || _props$translations2 === void 0 ? void 0 : _props$translations2.modal,
    onClose: onClose
  })), document.body));
}

function IntraNav({
  search,
  ourSite = ""
}) {
  React$2.useState("");
  React$2.useEffect(() => {}, []);
  const sites = [{
    title: "Urbit.org",
    href: "https://urbit.org"
  }, {
    title: "Operators",
    href: "https://operators.urbit.org"
  }, {
    title: "Developers",
    href: "https://developers.urbit.org"
  }, {
    title: "Roadmap",
    href: "https://roadmap.urbit.org"
  }];
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: "bg-wall-100 w-full"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "layout max-w-screen-lg hidden md:block px-8 mx-auto"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "flex justify-between items-center py-2"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "flex space-x-4 items-center"
  }, sites.map(site => /*#__PURE__*/React__default["default"].createElement("a", {
    key: site.title,
    className: classNames("text-xs", {
      "font-bold": ourSite.includes(site.href)
    }),
    href: site.href
  }, site.title)), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "w-[1px] h-[1.25rem] bg-wall-400"
  }), /*#__PURE__*/React__default["default"].createElement("a", {
    className: "text-xs",
    href: "https://network.urbit.org"
  }, "Network Explorer")), /*#__PURE__*/React__default["default"].createElement(DocSearch, {
    appId: "3EVOAL3MOI",
    apiKey: "00ccef825c17a672ef1c1a9bea3a9903",
    indexName: "developers-urbit"
  }))));
}

function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}

function _extends$5() {
  _extends$5 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
var LEFT = "Left";
var RIGHT = "Right";
var UP = "Up";
var DOWN = "Down";
var defaultProps$1 = {
  delta: 10,
  preventDefaultTouchmoveEvent: false,
  rotationAngle: 0,
  trackMouse: false,
  trackTouch: true
};
var initialState = {
  first: true,
  initial: [0, 0],
  start: 0,
  swiping: false,
  xy: [0, 0]
};
var mouseMove = "mousemove";
var mouseUp$1 = "mouseup";
var touchEnd$1 = "touchend";
var touchMove = "touchmove";
var touchStart = "touchstart";
function getDirection(absX, absY, deltaX, deltaY) {
  if (absX > absY) {
    if (deltaX > 0) {
      return RIGHT;
    }
    return LEFT;
  } else if (deltaY > 0) {
    return DOWN;
  }
  return UP;
}
function rotateXYByAngle(pos, angle) {
  if (angle === 0) return pos;
  var angleInRadians = Math.PI / 180 * angle;
  var x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);
  var y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);
  return [x, y];
}
function getHandlers(set, handlerProps) {
  var onStart = function onStart(event) {
    if (event && "touches" in event && event.touches.length > 1) return;
    set(function (state, props) {
      if (props.trackMouse) {
        document.addEventListener(mouseMove, onMove);
        document.addEventListener(mouseUp$1, onUp);
      }
      var _ref = "touches" in event ? event.touches[0] : event,
        clientX = _ref.clientX,
        clientY = _ref.clientY;
      var xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);
      return _extends$5({}, state, initialState, {
        initial: [].concat(xy),
        xy: xy,
        start: event.timeStamp || 0
      });
    });
  };
  var onMove = function onMove(event) {
    set(function (state, props) {
      if ("touches" in event && event.touches.length > 1) {
        return state;
      }
      var _ref2 = "touches" in event ? event.touches[0] : event,
        clientX = _ref2.clientX,
        clientY = _ref2.clientY;
      var _rotateXYByAngle = rotateXYByAngle([clientX, clientY], props.rotationAngle),
        x = _rotateXYByAngle[0],
        y = _rotateXYByAngle[1];
      var deltaX = x - state.xy[0];
      var deltaY = y - state.xy[1];
      var absX = Math.abs(deltaX);
      var absY = Math.abs(deltaY);
      var time = (event.timeStamp || 0) - state.start;
      var velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);
      var vxvy = [deltaX / (time || 1), deltaY / (time || 1)];
      var dir = getDirection(absX, absY, deltaX, deltaY);
      var delta = typeof props.delta === "number" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps$1.delta;
      if (absX < delta && absY < delta && !state.swiping) return state;
      var eventData = {
        absX: absX,
        absY: absY,
        deltaX: deltaX,
        deltaY: deltaY,
        dir: dir,
        event: event,
        first: state.first,
        initial: state.initial,
        velocity: velocity,
        vxvy: vxvy
      };
      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);
      props.onSwiping && props.onSwiping(eventData);
      var cancelablePageSwipe = false;
      if (props.onSwiping || props.onSwiped || "onSwiped" + dir in props) {
        cancelablePageSwipe = true;
      }
      if (cancelablePageSwipe && props.preventDefaultTouchmoveEvent && props.trackTouch && event.cancelable) event.preventDefault();
      return _extends$5({}, state, {
        first: false,
        eventData: eventData,
        swiping: true
      });
    });
  };
  var onEnd = function onEnd(event) {
    set(function (state, props) {
      var eventData;
      if (state.swiping && state.eventData) {
        eventData = _extends$5({}, state.eventData, {
          event: event
        });
        props.onSwiped && props.onSwiped(eventData);
        var onSwipedDir = props["onSwiped" + eventData.dir];
        onSwipedDir && onSwipedDir(eventData);
      } else {
        props.onTap && props.onTap({
          event: event
        });
      }
      return _extends$5({}, state, initialState, {
        eventData: eventData
      });
    });
  };
  var cleanUpMouse = function cleanUpMouse() {
    document.removeEventListener(mouseMove, onMove);
    document.removeEventListener(mouseUp$1, onUp);
  };
  var onUp = function onUp(e) {
    cleanUpMouse();
    onEnd(e);
  };
  var attachTouch = function attachTouch(el, passive) {
    var cleanup = function cleanup() {};
    if (el && el.addEventListener) {
      var tls = [[touchStart, onStart], [touchMove, onMove], [touchEnd$1, onEnd]];
      tls.forEach(function (_ref3) {
        var e = _ref3[0],
          h = _ref3[1];
        return el.addEventListener(e, h, {
          passive: passive
        });
      });
      cleanup = function cleanup() {
        return tls.forEach(function (_ref4) {
          var e = _ref4[0],
            h = _ref4[1];
          return el.removeEventListener(e, h);
        });
      };
    }
    return cleanup;
  };
  var onRef = function onRef(el) {
    if (el === null) return;
    set(function (state, props) {
      if (state.el === el) return state;
      var addState = {};
      if (state.el && state.el !== el && state.cleanUpTouch) {
        state.cleanUpTouch();
        addState.cleanUpTouch = void 0;
      }
      if (props.trackTouch && el) {
        addState.cleanUpTouch = attachTouch(el, !props.preventDefaultTouchmoveEvent);
      }
      return _extends$5({}, state, {
        el: el
      }, addState);
    });
  };
  var output = {
    ref: onRef
  };
  if (handlerProps.trackMouse) {
    output.onMouseDown = onStart;
  }
  return [output, attachTouch];
}
function updateTransientState(state, props, attachTouch) {
  var addState = {};
  if (!props.trackTouch && state.cleanUpTouch) {
    state.cleanUpTouch();
    addState.cleanUpTouch = void 0;
  } else if (props.trackTouch && !state.cleanUpTouch) {
    if (state.el) {
      addState.cleanUpTouch = attachTouch(state.el, !props.preventDefaultTouchmoveEvent);
    }
  }
  return _extends$5({}, state, addState);
}
function useSwipeable(options) {
  var trackMouse = options.trackMouse;
  var transientState = React__namespace.useRef(_extends$5({}, initialState));
  var transientProps = React__namespace.useRef(_extends$5({}, defaultProps$1));
  transientProps.current = _extends$5({}, defaultProps$1, options, {
    delta: options.delta === void 0 ? defaultProps$1.delta : options.delta,
    rotationAngle: options.rotationAngle === void 0 ? defaultProps$1.rotationAngle : options.rotationAngle,
    trackTouch: options.trackTouch === void 0 ? defaultProps$1.trackTouch : options.trackTouch
  });
  var _React$useMemo = React__namespace.useMemo(function () {
      return getHandlers(function (stateSetter) {
        return transientState.current = stateSetter(transientState.current, transientProps.current);
      }, {
        trackMouse: trackMouse
      });
    }, [trackMouse]),
    handlers = _React$useMemo[0],
    attachTouch = _React$useMemo[1];
  transientState.current = updateTransientState(transientState.current, transientProps.current, attachTouch);
  return handlers;
}

function MenuTray({
  isOpen,
  setTray,
  search,
  children
}) {
  // Locks document scrolling when menu is open
  if (typeof document !== "undefined") {
    if (isOpen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "visible";
    }
  }
  const handlers = useSwipeable({
    onSwipedLeft: e => setTray(false)
  });

  // Slides the tray in or out from the left
  const trayClasses = classNames({
    "tray-menu-open": isOpen,
    "tray-menu-closed": !isOpen
  });

  // Fades the background overlay in or out
  const overlayClasses = classNames({
    "tray-overlay-open": isOpen,
    "tray-overlay-closed": !isOpen
  });

  // Hides or shows the menu
  const menuClasses = classNames({
    "menu-open": isOpen,
    "menu-closed": !isOpen
  });
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("nav", _extends$6({}, handlers, {
    className: `z-20 w-screen h-screen top-0 left-0 fixed block md:hidden ${menuClasses}`
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    onClick: () => setTray(!isOpen),
    className: `bg-washedWhite w-screen h-screen ${overlayClasses}`
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    className: `absolute bg-wall-100 h-screen top-0 left-0 tray-menu-width overflow-y-scroll mb-24 ${trayClasses}`
  }, /*#__PURE__*/React__default["default"].createElement("div", _extends$6({}, handlers, {
    className: "flex flex-col px-4 md:px-8 pt-8 md:pt-10 lg:pt-12"
  }), children)), /*#__PURE__*/React__default["default"].createElement("div", {
    id: "search-tray",
    className: `fixed items-center justify-center type-ui rounded-xl bg-white text-wall-500 left-4 right-4 bottom-4 mobile-search-button-width`
  }, /*#__PURE__*/React__default["default"].createElement(DocSearch, {
    appId: "3EVOAL3MOI",
    apiKey: "00ccef825c17a672ef1c1a9bea3a9903",
    indexName: "developers-urbit"
  }))), /*#__PURE__*/React__default["default"].createElement("button", {
    onClick: () => setTray(!isOpen),
    className: "z-20 fixed bottom-4 right-4 w-16 h-16 bg-wall-600 flex items-center justify-center rounded-full md:hidden"
  }, isOpen ? /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M0.39382 13.7045C-0.131273 14.2296 -0.131274 15.081 0.39382 15.6061C0.918913 16.1312 1.77026 16.1312 2.29535 15.6061L7.99999 9.90142L13.7047 15.6061C14.2297 16.1312 15.0811 16.1312 15.6062 15.6061C16.1313 15.081 16.1313 14.2296 15.6062 13.7046L9.90152 7.99989L15.6061 2.29535C16.1312 1.77026 16.1312 0.918913 15.6061 0.39382C15.081 -0.131273 14.2296 -0.131273 13.7045 0.39382L7.99999 6.09836L2.29548 0.393844C1.77038 -0.131249 0.919038 -0.13125 0.393945 0.393844C-0.131148 0.918937 -0.131148 1.77028 0.393945 2.29537L6.09846 7.99989L0.39382 13.7045Z",
    className: "fill-white"
  })) : /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 16 17",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default["default"].createElement("rect", {
    width: "16",
    height: "3",
    rx: "1.5",
    className: "fill-white"
  }), /*#__PURE__*/React__default["default"].createElement("rect", {
    y: "7",
    width: "16",
    height: "3",
    rx: "1.5",
    className: "fill-white"
  }), /*#__PURE__*/React__default["default"].createElement("rect", {
    y: "14",
    width: "16",
    height: "3",
    rx: "1.5",
    className: "fill-white"
  }))));
}

const RenderTree = ({
  root,
  posts
}) => {
  const router$1 = router.useRouter();
  const childPages = (thisLink, children, level = 0) => /*#__PURE__*/React__default["default"].createElement("ul", {
    className: "pl-0"
  }, Object.entries(children).map(([childSlug, child]) => /*#__PURE__*/React__default["default"].createElement("li", null, pageTree(path.join(thisLink, childSlug), child, level))));
  const pageTree = (thisLink, tree, level = 0) => {
    const firstCrumb = "/" + router$1.asPath.split("/").slice(1).join("/").split("#")[0];
    const includesThisPage = firstCrumb.includes(thisLink + "/");
    const isThisPage = router$1.asPath === thisLink;
    const [isOpen, toggleTree] = React$2.useState(includesThisPage);
    React$2.useEffect(() => {
      const handleRouteChange = () => {
        const firstCrumb = "/" + router$1.asPath.split("/").slice(1).join("/").split("#")[0];
        const includesThisPage = firstCrumb.includes(thisLink + "/");
        toggleTree(includesThisPage);
      };
      router$1.events.on("routeChangeComplete", handleRouteChange);
      return () => {
        router$1.events.off("routeChangeStart", handleRouteChange);
      };
    }, [router$1.asPath]);
    const activeClasses = classNames({
      hidden: !isOpen
    });
    const headingItemClasses = classNames({
      "pl-0 text-base font-semibold hover:text-green-400 leading-relaxed": level === 0,
      "pl-4 text-base font-semibold hover:text-green-400": level === 1,
      "pl-8 text-base hover:text-green-400": level === 2,
      "dot text-green-400": isThisPage,
      "text-wall-600": !isThisPage
    });
    const pageItemClasses = classNames({
      "pl-4 text-base hover:text-green-400": level === 0,
      "pl-8 text-base hover:text-green-400": level === 1,
      "pl-12 text-base hover:text-green-400": level === 2
    });
    if (tree?.type === "tab") {
      return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("p", {
        className: "text-xs uppercase font-semibold text-wall-400 mt-4"
      }, tree.title), childPages(thisLink, tree.children, level), tree.pages.map(({
        title,
        slug
      }) => {
        const href = path.join(thisLink, slug);
        const isSelected = router$1.asPath === href;
        const selectedClasses = classNames({
          dot: isSelected,
          "text-green-400": isSelected,
          "text-wall-600": !isSelected
        });
        return /*#__PURE__*/React__default["default"].createElement("li", {
          className: "ml-0"
        }, /*#__PURE__*/React__default["default"].createElement(Link__default["default"], {
          href: href,
          passHref: true
        }, /*#__PURE__*/React__default["default"].createElement("a", {
          className: `relative font-semibold inline-block ${selectedClasses} `
        }, title)));
      }));
    }
    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("span", {
      onClick: () => toggleTree(!isOpen)
    }, /*#__PURE__*/React__default["default"].createElement("p", {
      className: `${headingItemClasses} relative cursor-pointer`
    }, tree.title)), /*#__PURE__*/React__default["default"].createElement("div", {
      className: activeClasses
    }, /*#__PURE__*/React__default["default"].createElement("ul", {
      className: ""
    }, tree.pages.map(({
      title,
      slug
    }) => {
      const href = path.join(thisLink, slug);
      const isSelected = router$1.asPath === href;
      const selectedClasses = classNames({
        dot: isSelected,
        "text-green-400": isSelected,
        "text-wall-600": !isSelected
      });
      return /*#__PURE__*/React__default["default"].createElement("li", null, /*#__PURE__*/React__default["default"].createElement(Link__default["default"], {
        href: href,
        passHref: true
      }, /*#__PURE__*/React__default["default"].createElement("a", {
        className: `relative inline-block ${selectedClasses} ${pageItemClasses} `
      }, title)));
    })), childPages(thisLink, tree.children, level + 1)));
  };
  return childPages(root, posts);
};

const TableOfContents = ({
  staticPosition,
  noh3s,
  markdown = true
}) => {
  const {
    nestedHeadings
  } = useHeadingsData(noh3s, markdown);
  const [activeId, setActiveId] = React$2.useState();
  useIntersectionObserver(setActiveId);
  return /*#__PURE__*/React__default["default"].createElement("nav", {
    className: (staticPosition ? "static" : "sticky") + " min-h-0 overflow-y-auto w-52 shrink-0 pb-24 hidden lg:block pl-4",
    style: {
      top: "8rem",
      height: "calc(100vh - 16rem)",
      'font-variant': "none"
    }
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "relative after:fixed after:bg-gradient-to-t after:from-white after:via-white after:bottom-0 after:w-52 after:h-60 after:pointer-events-none leading-none"
  }, /*#__PURE__*/React__default["default"].createElement(Headings, {
    headings: nestedHeadings,
    activeId: activeId
  })));
};
const getNestedHeadings = headingElements => {
  const nestedHeadings = [];
  headingElements.forEach((heading, index) => {
    const {
      innerText: title,
      id
    } = heading;
    if (heading.nodeName === "H2") {
      nestedHeadings.push({
        id,
        title,
        items: []
      });
    } else if (heading.nodeName === "H3" && nestedHeadings.length > 0) {
      nestedHeadings[nestedHeadings.length - 1].items.push({
        id,
        title
      });
    }
  });
  return nestedHeadings;
};
const useHeadingsData = (noh3s, markdown) => {
  const [nestedHeadings, setNestedHeadings] = React$2.useState([]);
  const md = markdown ? '.markdown' : '';
  const query = noh3s ? `${md} h2` : `${md} h2, ${md} h3`;
  React$2.useEffect(() => {
    const headingElements = Array.from(document.querySelectorAll(query));
    const newNestedHeadings = getNestedHeadings(headingElements);
    setNestedHeadings(newNestedHeadings);
  }, []);
  return {
    nestedHeadings
  };
};
const Headings = ({
  headings,
  activeId
}) => /*#__PURE__*/React__default["default"].createElement("ul", {
  className: classNames("space-y-2", {
    hidden: headings.length === 1 && headings?.[0]?.items?.length === 0
  })
}, headings.map((heading, index) => /*#__PURE__*/React__default["default"].createElement("li", {
  key: heading.id
}, /*#__PURE__*/React__default["default"].createElement("a", {
  className: classNames("font-medium text-sm", {
    "text-green-400": heading.id === activeId && index !== 0
  }),
  href: `#${heading.id}`
}, heading.title), heading.items.length > 0 && /*#__PURE__*/React__default["default"].createElement("ul", {
  className: "pl-2 text-xs"
}, heading.items.map(child => /*#__PURE__*/React__default["default"].createElement("li", {
  key: child.id,
  className: child.id === activeId ? "text-green-400" : "text-wall-500"
}, /*#__PURE__*/React__default["default"].createElement("a", {
  href: `#${child.id}`
}, child.title)))))));
const useIntersectionObserver = setActiveId => {
  const headingElementsRef = React$2.useRef({});
  React$2.useEffect(() => {
    const callback = headings => {
      headingElementsRef.current = headings.reduce((map, headingElement) => {
        map[headingElement.target.id] = headingElement;
        return map;
      }, headingElementsRef.current);
      const visibleHeadings = [];
      Object.keys(headingElementsRef.current).forEach(key => {
        const headingElement = headingElementsRef.current[key];
        if (headingElement.isIntersecting) visibleHeadings.push(headingElement);
      });
      const getIndexFromId = id => headingElements.findIndex(heading => heading.id === id);
      if (visibleHeadings.length === 1) {
        setActiveId(visibleHeadings[0].target.id);
      } else if (visibleHeadings.length > 1) {
        const sortedVisibleHeadings = visibleHeadings.sort((a, b) => getIndexFromId(a.target.id) > getIndexFromId(b.target.id));
        setActiveId(sortedVisibleHeadings[0].target.id);
      }
    };
    const observer = new IntersectionObserver(callback, {
      rootMargin: "0px 0px -50% 0px"
    });
    const headingElements = Array.from(document.querySelectorAll("h2, h3"));
    headingElements.forEach(element => observer.observe(element));
    return () => observer.disconnect();
  }, [setActiveId]);
};

function TwoUp({
  children,
  className = ""
}) {
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: `flex flex-wrap w-full ${className}`
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "w-full md:w-1/2 pr-0 pb-8 md:pr-4"
  }, children[0] || null), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "w-full md:w-1/2 pl-0 pb-8 md:pl-4"
  }, children[1] || null));
}

function IndexCard({
  slug,
  title,
  image,
  author,
  ship,
  content,
  id = ""
}) {
  return /*#__PURE__*/React__default["default"].createElement(Link__default["default"], {
    href: slug
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "cursor-pointer bg-wall-100 rounded-xl basis-1/2 h-full"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "flex flex-col p-6 justify-between items-between h-full relative"
  }, image ? /*#__PURE__*/React__default["default"].createElement("img", {
    className: "rounded-xl w-full flex-1 object-cover",
    src: image,
    style: {
      aspectRatio: "4 / 3"
    }
  }) : /*#__PURE__*/React__default["default"].createElement("div", {
    className: "bg-wall-200 rounded-xl w-full flex-1",
    style: {
      aspectRatio: "4 / 3"
    }
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "grow-1 flex flex-col h-full min-h-0 pt-4"
  }, /*#__PURE__*/React__default["default"].createElement("h3", {
    className: "mb-2",
    id: id ? id : title
  }, title), /*#__PURE__*/React__default["default"].createElement("p", {
    className: "text-sm"
  }, author ? /*#__PURE__*/React__default["default"].createElement("span", {
    className: "type-sub-bold mr-2"
  }, author) : null, ship ? /*#__PURE__*/React__default["default"].createElement(Link__default["default"], {
    href: `https://urbit.org/ids/${ship}`,
    passHref: true
  }, /*#__PURE__*/React__default["default"].createElement("a", {
    className: "type-sub-bold text-wall-500 font-mono"
  }, ship)) : null), content))));
}

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN$1 = 0 / 0;

/** `Object#toString` result references. */
var symbolTag$1 = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim$1 = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary$1 = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal$1 = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt$1 = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$1 = objectProto$1.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max,
  nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now$1 = function () {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce$1(func, wait, options) {
  var lastArgs,
    lastThis,
    maxWait,
    result,
    timerId,
    lastCallTime,
    lastInvokeTime = 0,
    leading = false,
    maxing = false,
    trailing = true;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$3(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax$1(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs,
      thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime,
      result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }
  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }
  function flush() {
    return timerId === undefined ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(),
      isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$3(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$1(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$1(value) {
  return typeof value == 'symbol' || isObjectLike$1(value) && objectToString$1.call(value) == symbolTag$1;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber$1(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN$1;
  }
  if (isObject$3(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$3(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim$1, '');
  var isBinary = reIsBinary$1.test(value);
  return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
}
var lodash_debounce = debounce$1;

var propTypes = {exports: {}};

var reactIs$1 = {exports: {}};

var reactIs_production_min$1 = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min$1;

function requireReactIs_production_min$1 () {
	if (hasRequiredReactIs_production_min$1) return reactIs_production_min$1;
	hasRequiredReactIs_production_min$1 = 1;

	var b = "function" === typeof Symbol && Symbol.for,
	  c = b ? Symbol.for("react.element") : 60103,
	  d = b ? Symbol.for("react.portal") : 60106,
	  e = b ? Symbol.for("react.fragment") : 60107,
	  f = b ? Symbol.for("react.strict_mode") : 60108,
	  g = b ? Symbol.for("react.profiler") : 60114,
	  h = b ? Symbol.for("react.provider") : 60109,
	  k = b ? Symbol.for("react.context") : 60110,
	  l = b ? Symbol.for("react.async_mode") : 60111,
	  m = b ? Symbol.for("react.concurrent_mode") : 60111,
	  n = b ? Symbol.for("react.forward_ref") : 60112,
	  p = b ? Symbol.for("react.suspense") : 60113,
	  q = b ? Symbol.for("react.suspense_list") : 60120,
	  r = b ? Symbol.for("react.memo") : 60115,
	  t = b ? Symbol.for("react.lazy") : 60116,
	  v = b ? Symbol.for("react.block") : 60121,
	  w = b ? Symbol.for("react.fundamental") : 60117,
	  x = b ? Symbol.for("react.responder") : 60118,
	  y = b ? Symbol.for("react.scope") : 60119;
	function z(a) {
	  if ("object" === typeof a && null !== a) {
	    var u = a.$$typeof;
	    switch (u) {
	      case c:
	        switch (a = a.type, a) {
	          case l:
	          case m:
	          case e:
	          case g:
	          case f:
	          case p:
	            return a;
	          default:
	            switch (a = a && a.$$typeof, a) {
	              case k:
	              case n:
	              case t:
	              case r:
	              case h:
	                return a;
	              default:
	                return u;
	            }
	        }
	      case d:
	        return u;
	    }
	  }
	}
	function A(a) {
	  return z(a) === m;
	}
	reactIs_production_min$1.AsyncMode = l;
	reactIs_production_min$1.ConcurrentMode = m;
	reactIs_production_min$1.ContextConsumer = k;
	reactIs_production_min$1.ContextProvider = h;
	reactIs_production_min$1.Element = c;
	reactIs_production_min$1.ForwardRef = n;
	reactIs_production_min$1.Fragment = e;
	reactIs_production_min$1.Lazy = t;
	reactIs_production_min$1.Memo = r;
	reactIs_production_min$1.Portal = d;
	reactIs_production_min$1.Profiler = g;
	reactIs_production_min$1.StrictMode = f;
	reactIs_production_min$1.Suspense = p;
	reactIs_production_min$1.isAsyncMode = function (a) {
	  return A(a) || z(a) === l;
	};
	reactIs_production_min$1.isConcurrentMode = A;
	reactIs_production_min$1.isContextConsumer = function (a) {
	  return z(a) === k;
	};
	reactIs_production_min$1.isContextProvider = function (a) {
	  return z(a) === h;
	};
	reactIs_production_min$1.isElement = function (a) {
	  return "object" === typeof a && null !== a && a.$$typeof === c;
	};
	reactIs_production_min$1.isForwardRef = function (a) {
	  return z(a) === n;
	};
	reactIs_production_min$1.isFragment = function (a) {
	  return z(a) === e;
	};
	reactIs_production_min$1.isLazy = function (a) {
	  return z(a) === t;
	};
	reactIs_production_min$1.isMemo = function (a) {
	  return z(a) === r;
	};
	reactIs_production_min$1.isPortal = function (a) {
	  return z(a) === d;
	};
	reactIs_production_min$1.isProfiler = function (a) {
	  return z(a) === g;
	};
	reactIs_production_min$1.isStrictMode = function (a) {
	  return z(a) === f;
	};
	reactIs_production_min$1.isSuspense = function (a) {
	  return z(a) === p;
	};
	reactIs_production_min$1.isValidElementType = function (a) {
	  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
	};
	reactIs_production_min$1.typeOf = z;
	return reactIs_production_min$1;
}

var reactIs_development$1 = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development$1;

function requireReactIs_development$1 () {
	if (hasRequiredReactIs_development$1) return reactIs_development$1;
	hasRequiredReactIs_development$1 = 1;

	if (process.env.NODE_ENV !== "production") {
	  (function () {

	    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	    // nor polyfill, then a plain number is used for performance.
	    var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	    // (unstable) APIs that have been removed. Can we remove the symbols?

	    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	    var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	    var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	    var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	    var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	    var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
	    function isValidElementType(type) {
	      return typeof type === 'string' || typeof type === 'function' ||
	      // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	    }
	    function typeOf(object) {
	      if (typeof object === 'object' && object !== null) {
	        var $$typeof = object.$$typeof;
	        switch ($$typeof) {
	          case REACT_ELEMENT_TYPE:
	            var type = object.type;
	            switch (type) {
	              case REACT_ASYNC_MODE_TYPE:
	              case REACT_CONCURRENT_MODE_TYPE:
	              case REACT_FRAGMENT_TYPE:
	              case REACT_PROFILER_TYPE:
	              case REACT_STRICT_MODE_TYPE:
	              case REACT_SUSPENSE_TYPE:
	                return type;
	              default:
	                var $$typeofType = type && type.$$typeof;
	                switch ($$typeofType) {
	                  case REACT_CONTEXT_TYPE:
	                  case REACT_FORWARD_REF_TYPE:
	                  case REACT_LAZY_TYPE:
	                  case REACT_MEMO_TYPE:
	                  case REACT_PROVIDER_TYPE:
	                    return $$typeofType;
	                  default:
	                    return $$typeof;
	                }
	            }
	          case REACT_PORTAL_TYPE:
	            return $$typeof;
	        }
	      }
	      return undefined;
	    } // AsyncMode is deprecated along with isAsyncMode

	    var AsyncMode = REACT_ASYNC_MODE_TYPE;
	    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	    var ContextConsumer = REACT_CONTEXT_TYPE;
	    var ContextProvider = REACT_PROVIDER_TYPE;
	    var Element = REACT_ELEMENT_TYPE;
	    var ForwardRef = REACT_FORWARD_REF_TYPE;
	    var Fragment = REACT_FRAGMENT_TYPE;
	    var Lazy = REACT_LAZY_TYPE;
	    var Memo = REACT_MEMO_TYPE;
	    var Portal = REACT_PORTAL_TYPE;
	    var Profiler = REACT_PROFILER_TYPE;
	    var StrictMode = REACT_STRICT_MODE_TYPE;
	    var Suspense = REACT_SUSPENSE_TYPE;
	    var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	    function isAsyncMode(object) {
	      {
	        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	          hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	          console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	        }
	      }
	      return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	    }
	    function isConcurrentMode(object) {
	      return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	    }
	    function isContextConsumer(object) {
	      return typeOf(object) === REACT_CONTEXT_TYPE;
	    }
	    function isContextProvider(object) {
	      return typeOf(object) === REACT_PROVIDER_TYPE;
	    }
	    function isElement(object) {
	      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	    }
	    function isForwardRef(object) {
	      return typeOf(object) === REACT_FORWARD_REF_TYPE;
	    }
	    function isFragment(object) {
	      return typeOf(object) === REACT_FRAGMENT_TYPE;
	    }
	    function isLazy(object) {
	      return typeOf(object) === REACT_LAZY_TYPE;
	    }
	    function isMemo(object) {
	      return typeOf(object) === REACT_MEMO_TYPE;
	    }
	    function isPortal(object) {
	      return typeOf(object) === REACT_PORTAL_TYPE;
	    }
	    function isProfiler(object) {
	      return typeOf(object) === REACT_PROFILER_TYPE;
	    }
	    function isStrictMode(object) {
	      return typeOf(object) === REACT_STRICT_MODE_TYPE;
	    }
	    function isSuspense(object) {
	      return typeOf(object) === REACT_SUSPENSE_TYPE;
	    }
	    reactIs_development$1.AsyncMode = AsyncMode;
	    reactIs_development$1.ConcurrentMode = ConcurrentMode;
	    reactIs_development$1.ContextConsumer = ContextConsumer;
	    reactIs_development$1.ContextProvider = ContextProvider;
	    reactIs_development$1.Element = Element;
	    reactIs_development$1.ForwardRef = ForwardRef;
	    reactIs_development$1.Fragment = Fragment;
	    reactIs_development$1.Lazy = Lazy;
	    reactIs_development$1.Memo = Memo;
	    reactIs_development$1.Portal = Portal;
	    reactIs_development$1.Profiler = Profiler;
	    reactIs_development$1.StrictMode = StrictMode;
	    reactIs_development$1.Suspense = Suspense;
	    reactIs_development$1.isAsyncMode = isAsyncMode;
	    reactIs_development$1.isConcurrentMode = isConcurrentMode;
	    reactIs_development$1.isContextConsumer = isContextConsumer;
	    reactIs_development$1.isContextProvider = isContextProvider;
	    reactIs_development$1.isElement = isElement;
	    reactIs_development$1.isForwardRef = isForwardRef;
	    reactIs_development$1.isFragment = isFragment;
	    reactIs_development$1.isLazy = isLazy;
	    reactIs_development$1.isMemo = isMemo;
	    reactIs_development$1.isPortal = isPortal;
	    reactIs_development$1.isProfiler = isProfiler;
	    reactIs_development$1.isStrictMode = isStrictMode;
	    reactIs_development$1.isSuspense = isSuspense;
	    reactIs_development$1.isValidElementType = isValidElementType;
	    reactIs_development$1.typeOf = typeOf;
	  })();
	}
	return reactIs_development$1;
}

var hasRequiredReactIs;

function requireReactIs () {
	if (hasRequiredReactIs) return reactIs$1.exports;
	hasRequiredReactIs = 1;
	(function (module) {

		if (process.env.NODE_ENV === 'production') {
		  module.exports = requireReactIs_production_min$1();
		} else {
		  module.exports = requireReactIs_development$1();
		}
} (reactIs$1));
	return reactIs$1.exports;
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var objectAssign;
var hasRequiredObjectAssign;

function requireObjectAssign () {
	if (hasRequiredObjectAssign) return objectAssign;
	hasRequiredObjectAssign = 1;

	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	function toObject(val) {
	  if (val === null || val === undefined) {
	    throw new TypeError('Object.assign cannot be called with null or undefined');
	  }
	  return Object(val);
	}
	function shouldUseNative() {
	  try {
	    if (!Object.assign) {
	      return false;
	    }

	    // Detect buggy property enumeration order in older V8 versions.

	    // https://bugs.chromium.org/p/v8/issues/detail?id=4118
	    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
	    test1[5] = 'de';
	    if (Object.getOwnPropertyNames(test1)[0] === '5') {
	      return false;
	    }

	    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
	    var test2 = {};
	    for (var i = 0; i < 10; i++) {
	      test2['_' + String.fromCharCode(i)] = i;
	    }
	    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
	      return test2[n];
	    });
	    if (order2.join('') !== '0123456789') {
	      return false;
	    }

	    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
	    var test3 = {};
	    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
	      test3[letter] = letter;
	    });
	    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
	      return false;
	    }
	    return true;
	  } catch (err) {
	    // We don't expect any of the above to throw, but better to be safe.
	    return false;
	  }
	}
	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	  var from;
	  var to = toObject(target);
	  var symbols;
	  for (var s = 1; s < arguments.length; s++) {
	    from = Object(arguments[s]);
	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	    if (getOwnPropertySymbols) {
	      symbols = getOwnPropertySymbols(from);
	      for (var i = 0; i < symbols.length; i++) {
	        if (propIsEnumerable.call(from, symbols[i])) {
	          to[symbols[i]] = from[symbols[i]];
	        }
	      }
	    }
	  }
	  return to;
	};
	return objectAssign;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;

function requireReactPropTypesSecret () {
	if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
	hasRequiredReactPropTypesSecret = 1;

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	ReactPropTypesSecret_1 = ReactPropTypesSecret;
	return ReactPropTypesSecret_1;
}

var has$1;
var hasRequiredHas;

function requireHas () {
	if (hasRequiredHas) return has$1;
	hasRequiredHas = 1;
	has$1 = Function.call.bind(Object.prototype.hasOwnProperty);
	return has$1;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var checkPropTypes_1;
var hasRequiredCheckPropTypes;

function requireCheckPropTypes () {
	if (hasRequiredCheckPropTypes) return checkPropTypes_1;
	hasRequiredCheckPropTypes = 1;

	var printWarning = function () {};
	if (process.env.NODE_ENV !== 'production') {
	  var ReactPropTypesSecret = requireReactPropTypesSecret();
	  var loggedTypeFailures = {};
	  var has = requireHas();
	  printWarning = function (text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {/**/}
	  };
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
	            err.name = 'Invariant Violation';
	            throw err;
	          }
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error && !(error instanceof Error)) {
	          printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
	        }
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;
	          var stack = getStack ? getStack() : '';
	          printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
	        }
	      }
	    }
	  }
	}

	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
	checkPropTypes.resetWarningCache = function () {
	  if (process.env.NODE_ENV !== 'production') {
	    loggedTypeFailures = {};
	  }
	};
	checkPropTypes_1 = checkPropTypes;
	return checkPropTypes_1;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;

function requireFactoryWithTypeCheckers () {
	if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
	hasRequiredFactoryWithTypeCheckers = 1;

	var ReactIs = requireReactIs();
	var assign = requireObjectAssign();
	var ReactPropTypesSecret = requireReactPropTypesSecret();
	var has = requireHas();
	var checkPropTypes = requireCheckPropTypes();
	var printWarning = function () {};
	if (process.env.NODE_ENV !== 'production') {
	  printWarning = function (text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}
	function emptyFunctionThatReturnsNull() {
	  return null;
	}
	factoryWithTypeCheckers = function (isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bigint: createPrimitiveTypeChecker('bigint'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),
	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message, data) {
	    this.message = message;
	    this.data = data && typeof data === 'object' ? data : {};
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;
	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;
	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (!manualPropTypeCallCache[cacheKey] &&
	          // Avoid spamming the console because they are often not actionable except for lib authors
	          manualPropTypeWarningCount < 3) {
	            printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }
	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);
	    return chainedCheckType;
	  }
	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'), {
	          expectedType: expectedType
	        });
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }
	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!ReactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (arguments.length > 1) {
	          printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
	        } else {
	          printWarning('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }
	      return emptyFunctionThatReturnsNull;
	    }
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }
	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);
	        if (type === 'symbol') {
	          return String(value);
	        }
	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (has(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunctionThatReturnsNull;
	    }
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
	        return emptyFunctionThatReturnsNull;
	      }
	    }
	    function validate(props, propName, componentName, location, propFullName) {
	      var expectedTypes = [];
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
	        if (checkerResult == null) {
	          return null;
	        }
	        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
	          expectedTypes.push(checkerResult.data.expectedType);
	        }
	      }
	      var expectedTypesMessage = expectedTypes.length > 0 ? ', expected one of type [' + expectedTypes.join(', ') + ']' : '';
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	  function invalidValidatorError(componentName, location, propFullName, key, type) {
	    return new PropTypeError((componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + type + '`.');
	  }
	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from props.
	      var allKeys = assign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (has(shapeTypes, key) && typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        if (!checker) {
	          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }
	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }
	        return true;
	      default:
	        return false;
	    }
	  }
	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // falsy value can't be a Symbol
	    if (!propValue) {
	      return false;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }
	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }
	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;
	  return ReactPropTypes;
	};
	return factoryWithTypeCheckers;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;

function requireFactoryWithThrowingShims () {
	if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
	hasRequiredFactoryWithThrowingShims = 1;

	var ReactPropTypesSecret = requireReactPropTypesSecret();
	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;
	factoryWithThrowingShims = function () {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
	    err.name = 'Invariant Violation';
	    throw err;
	  }
	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bigint: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,
	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,
	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };
	  ReactPropTypes.PropTypes = ReactPropTypes;
	  return ReactPropTypes;
	};
	return factoryWithThrowingShims;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var ReactIs = requireReactIs();

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  propTypes.exports = requireFactoryWithThrowingShims()();
}

var reactIs = {exports: {}};

var reactIs_production_min = {};

/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min;

function requireReactIs_production_min () {
	if (hasRequiredReactIs_production_min) return reactIs_production_min;
	hasRequiredReactIs_production_min = 1;

	var b = 60103,
	  c = 60106,
	  d = 60107,
	  e = 60108,
	  f = 60114,
	  g = 60109,
	  h = 60110,
	  k = 60112,
	  l = 60113,
	  m = 60120,
	  n = 60115,
	  p = 60116,
	  q = 60121,
	  r = 60122,
	  u = 60117,
	  v = 60129,
	  w = 60131;
	if ("function" === typeof Symbol && Symbol.for) {
	  var x = Symbol.for;
	  b = x("react.element");
	  c = x("react.portal");
	  d = x("react.fragment");
	  e = x("react.strict_mode");
	  f = x("react.profiler");
	  g = x("react.provider");
	  h = x("react.context");
	  k = x("react.forward_ref");
	  l = x("react.suspense");
	  m = x("react.suspense_list");
	  n = x("react.memo");
	  p = x("react.lazy");
	  q = x("react.block");
	  r = x("react.server.block");
	  u = x("react.fundamental");
	  v = x("react.debug_trace_mode");
	  w = x("react.legacy_hidden");
	}
	function y(a) {
	  if ("object" === typeof a && null !== a) {
	    var t = a.$$typeof;
	    switch (t) {
	      case b:
	        switch (a = a.type, a) {
	          case d:
	          case f:
	          case e:
	          case l:
	          case m:
	            return a;
	          default:
	            switch (a = a && a.$$typeof, a) {
	              case h:
	              case k:
	              case p:
	              case n:
	              case g:
	                return a;
	              default:
	                return t;
	            }
	        }
	      case c:
	        return t;
	    }
	  }
	}
	var z = g,
	  A = b,
	  B = k,
	  C = d,
	  D = p,
	  E = n,
	  F = c,
	  G = f,
	  H = e,
	  I = l;
	reactIs_production_min.ContextConsumer = h;
	reactIs_production_min.ContextProvider = z;
	reactIs_production_min.Element = A;
	reactIs_production_min.ForwardRef = B;
	reactIs_production_min.Fragment = C;
	reactIs_production_min.Lazy = D;
	reactIs_production_min.Memo = E;
	reactIs_production_min.Portal = F;
	reactIs_production_min.Profiler = G;
	reactIs_production_min.StrictMode = H;
	reactIs_production_min.Suspense = I;
	reactIs_production_min.isAsyncMode = function () {
	  return !1;
	};
	reactIs_production_min.isConcurrentMode = function () {
	  return !1;
	};
	reactIs_production_min.isContextConsumer = function (a) {
	  return y(a) === h;
	};
	reactIs_production_min.isContextProvider = function (a) {
	  return y(a) === g;
	};
	reactIs_production_min.isElement = function (a) {
	  return "object" === typeof a && null !== a && a.$$typeof === b;
	};
	reactIs_production_min.isForwardRef = function (a) {
	  return y(a) === k;
	};
	reactIs_production_min.isFragment = function (a) {
	  return y(a) === d;
	};
	reactIs_production_min.isLazy = function (a) {
	  return y(a) === p;
	};
	reactIs_production_min.isMemo = function (a) {
	  return y(a) === n;
	};
	reactIs_production_min.isPortal = function (a) {
	  return y(a) === c;
	};
	reactIs_production_min.isProfiler = function (a) {
	  return y(a) === f;
	};
	reactIs_production_min.isStrictMode = function (a) {
	  return y(a) === e;
	};
	reactIs_production_min.isSuspense = function (a) {
	  return y(a) === l;
	};
	reactIs_production_min.isValidElementType = function (a) {
	  return "string" === typeof a || "function" === typeof a || a === d || a === f || a === v || a === e || a === l || a === m || a === w || "object" === typeof a && null !== a && (a.$$typeof === p || a.$$typeof === n || a.$$typeof === g || a.$$typeof === h || a.$$typeof === k || a.$$typeof === u || a.$$typeof === q || a[0] === r) ? !0 : !1;
	};
	reactIs_production_min.typeOf = y;
	return reactIs_production_min;
}

var reactIs_development = {};

/** @license React v17.0.2
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development;

function requireReactIs_development () {
	if (hasRequiredReactIs_development) return reactIs_development;
	hasRequiredReactIs_development = 1;

	if (process.env.NODE_ENV !== "production") {
	  (function () {

	    // ATTENTION
	    // When adding new symbols to this file,
	    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
	    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	    // nor polyfill, then a plain number is used for performance.
	    var REACT_ELEMENT_TYPE = 0xeac7;
	    var REACT_PORTAL_TYPE = 0xeaca;
	    var REACT_FRAGMENT_TYPE = 0xeacb;
	    var REACT_STRICT_MODE_TYPE = 0xeacc;
	    var REACT_PROFILER_TYPE = 0xead2;
	    var REACT_PROVIDER_TYPE = 0xeacd;
	    var REACT_CONTEXT_TYPE = 0xeace;
	    var REACT_FORWARD_REF_TYPE = 0xead0;
	    var REACT_SUSPENSE_TYPE = 0xead1;
	    var REACT_SUSPENSE_LIST_TYPE = 0xead8;
	    var REACT_MEMO_TYPE = 0xead3;
	    var REACT_LAZY_TYPE = 0xead4;
	    var REACT_BLOCK_TYPE = 0xead9;
	    var REACT_SERVER_BLOCK_TYPE = 0xeada;
	    var REACT_FUNDAMENTAL_TYPE = 0xead5;
	    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
	    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;
	    if (typeof Symbol === 'function' && Symbol.for) {
	      var symbolFor = Symbol.for;
	      REACT_ELEMENT_TYPE = symbolFor('react.element');
	      REACT_PORTAL_TYPE = symbolFor('react.portal');
	      REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
	      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
	      REACT_PROFILER_TYPE = symbolFor('react.profiler');
	      REACT_PROVIDER_TYPE = symbolFor('react.provider');
	      REACT_CONTEXT_TYPE = symbolFor('react.context');
	      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
	      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
	      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
	      REACT_MEMO_TYPE = symbolFor('react.memo');
	      REACT_LAZY_TYPE = symbolFor('react.lazy');
	      REACT_BLOCK_TYPE = symbolFor('react.block');
	      REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
	      REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
	      symbolFor('react.scope');
	      symbolFor('react.opaque.id');
	      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
	      symbolFor('react.offscreen');
	      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
	    }

	    // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

	    var enableScopeAPI = false; // Experimental Create Event Handle API.

	    function isValidElementType(type) {
	      if (typeof type === 'string' || typeof type === 'function') {
	        return true;
	      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

	      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
	        return true;
	      }
	      if (typeof type === 'object' && type !== null) {
	        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
	          return true;
	        }
	      }
	      return false;
	    }
	    function typeOf(object) {
	      if (typeof object === 'object' && object !== null) {
	        var $$typeof = object.$$typeof;
	        switch ($$typeof) {
	          case REACT_ELEMENT_TYPE:
	            var type = object.type;
	            switch (type) {
	              case REACT_FRAGMENT_TYPE:
	              case REACT_PROFILER_TYPE:
	              case REACT_STRICT_MODE_TYPE:
	              case REACT_SUSPENSE_TYPE:
	              case REACT_SUSPENSE_LIST_TYPE:
	                return type;
	              default:
	                var $$typeofType = type && type.$$typeof;
	                switch ($$typeofType) {
	                  case REACT_CONTEXT_TYPE:
	                  case REACT_FORWARD_REF_TYPE:
	                  case REACT_LAZY_TYPE:
	                  case REACT_MEMO_TYPE:
	                  case REACT_PROVIDER_TYPE:
	                    return $$typeofType;
	                  default:
	                    return $$typeof;
	                }
	            }
	          case REACT_PORTAL_TYPE:
	            return $$typeof;
	        }
	      }
	      return undefined;
	    }
	    var ContextConsumer = REACT_CONTEXT_TYPE;
	    var ContextProvider = REACT_PROVIDER_TYPE;
	    var Element = REACT_ELEMENT_TYPE;
	    var ForwardRef = REACT_FORWARD_REF_TYPE;
	    var Fragment = REACT_FRAGMENT_TYPE;
	    var Lazy = REACT_LAZY_TYPE;
	    var Memo = REACT_MEMO_TYPE;
	    var Portal = REACT_PORTAL_TYPE;
	    var Profiler = REACT_PROFILER_TYPE;
	    var StrictMode = REACT_STRICT_MODE_TYPE;
	    var Suspense = REACT_SUSPENSE_TYPE;
	    var hasWarnedAboutDeprecatedIsAsyncMode = false;
	    var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

	    function isAsyncMode(object) {
	      {
	        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	          hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	          console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
	        }
	      }
	      return false;
	    }
	    function isConcurrentMode(object) {
	      {
	        if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
	          hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

	          console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
	        }
	      }
	      return false;
	    }
	    function isContextConsumer(object) {
	      return typeOf(object) === REACT_CONTEXT_TYPE;
	    }
	    function isContextProvider(object) {
	      return typeOf(object) === REACT_PROVIDER_TYPE;
	    }
	    function isElement(object) {
	      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	    }
	    function isForwardRef(object) {
	      return typeOf(object) === REACT_FORWARD_REF_TYPE;
	    }
	    function isFragment(object) {
	      return typeOf(object) === REACT_FRAGMENT_TYPE;
	    }
	    function isLazy(object) {
	      return typeOf(object) === REACT_LAZY_TYPE;
	    }
	    function isMemo(object) {
	      return typeOf(object) === REACT_MEMO_TYPE;
	    }
	    function isPortal(object) {
	      return typeOf(object) === REACT_PORTAL_TYPE;
	    }
	    function isProfiler(object) {
	      return typeOf(object) === REACT_PROFILER_TYPE;
	    }
	    function isStrictMode(object) {
	      return typeOf(object) === REACT_STRICT_MODE_TYPE;
	    }
	    function isSuspense(object) {
	      return typeOf(object) === REACT_SUSPENSE_TYPE;
	    }
	    reactIs_development.ContextConsumer = ContextConsumer;
	    reactIs_development.ContextProvider = ContextProvider;
	    reactIs_development.Element = Element;
	    reactIs_development.ForwardRef = ForwardRef;
	    reactIs_development.Fragment = Fragment;
	    reactIs_development.Lazy = Lazy;
	    reactIs_development.Memo = Memo;
	    reactIs_development.Portal = Portal;
	    reactIs_development.Profiler = Profiler;
	    reactIs_development.StrictMode = StrictMode;
	    reactIs_development.Suspense = Suspense;
	    reactIs_development.isAsyncMode = isAsyncMode;
	    reactIs_development.isConcurrentMode = isConcurrentMode;
	    reactIs_development.isContextConsumer = isContextConsumer;
	    reactIs_development.isContextProvider = isContextProvider;
	    reactIs_development.isElement = isElement;
	    reactIs_development.isForwardRef = isForwardRef;
	    reactIs_development.isFragment = isFragment;
	    reactIs_development.isLazy = isLazy;
	    reactIs_development.isMemo = isMemo;
	    reactIs_development.isPortal = isPortal;
	    reactIs_development.isProfiler = isProfiler;
	    reactIs_development.isStrictMode = isStrictMode;
	    reactIs_development.isSuspense = isSuspense;
	    reactIs_development.isValidElementType = isValidElementType;
	    reactIs_development.typeOf = typeOf;
	  })();
	}
	return reactIs_development;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireReactIs_production_min();
	} else {
	  module.exports = requireReactIs_development();
	}
} (reactIs));

function t(t) {
  return "object" == typeof t && null != t && 1 === t.nodeType;
}
function e(t, e) {
  return (!e || "hidden" !== t) && "visible" !== t && "clip" !== t;
}
function n$1(t, n) {
  if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
    var r = getComputedStyle(t, null);
    return e(r.overflowY, n) || e(r.overflowX, n) || function (t) {
      var e = function (t) {
        if (!t.ownerDocument || !t.ownerDocument.defaultView) return null;
        try {
          return t.ownerDocument.defaultView.frameElement;
        } catch (t) {
          return null;
        }
      }(t);
      return !!e && (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth);
    }(t);
  }
  return !1;
}
function r(t, e, n, r, i, o, l, d) {
  return o < t && l > e || o > t && l < e ? 0 : o <= t && d <= n || l >= e && d >= n ? o - t - r : l > e && d < n || o < t && d > n ? l - e + i : 0;
}
function computeScrollIntoView (e, i) {
  var o = window,
    l = i.scrollMode,
    d = i.block,
    u = i.inline,
    h = i.boundary,
    a = i.skipOverflowHiddenElements,
    c = "function" == typeof h ? h : function (t) {
      return t !== h;
    };
  if (!t(e)) throw new TypeError("Invalid target");
  for (var f = document.scrollingElement || document.documentElement, s = [], p = e; t(p) && c(p);) {
    if ((p = p.parentElement) === f) {
      s.push(p);
      break;
    }
    null != p && p === document.body && n$1(p) && !n$1(document.documentElement) || null != p && n$1(p, a) && s.push(p);
  }
  for (var m = o.visualViewport ? o.visualViewport.width : innerWidth, g = o.visualViewport ? o.visualViewport.height : innerHeight, w = window.scrollX || pageXOffset, v = window.scrollY || pageYOffset, W = e.getBoundingClientRect(), b = W.height, H = W.width, y = W.top, E = W.right, M = W.bottom, V = W.left, x = "start" === d || "nearest" === d ? y : "end" === d ? M : y + b / 2, I = "center" === u ? V + H / 2 : "end" === u ? E : V, C = [], T = 0; T < s.length; T++) {
    var k = s[T],
      B = k.getBoundingClientRect(),
      D = B.height,
      O = B.width,
      R = B.top,
      X = B.right,
      Y = B.bottom,
      L = B.left;
    if ("if-needed" === l && y >= 0 && V >= 0 && M <= g && E <= m && y >= R && M <= Y && V >= L && E <= X) return C;
    var S = getComputedStyle(k),
      j = parseInt(S.borderLeftWidth, 10),
      q = parseInt(S.borderTopWidth, 10),
      z = parseInt(S.borderRightWidth, 10),
      A = parseInt(S.borderBottomWidth, 10),
      F = 0,
      G = 0,
      J = "offsetWidth" in k ? k.offsetWidth - k.clientWidth - j - z : 0,
      K = "offsetHeight" in k ? k.offsetHeight - k.clientHeight - q - A : 0;
    if (f === k) F = "start" === d ? x : "end" === d ? x - g : "nearest" === d ? r(v, v + g, g, q, A, v + x, v + x + b, b) : x - g / 2, G = "start" === u ? I : "center" === u ? I - m / 2 : "end" === u ? I - m : r(w, w + m, m, j, z, w + I, w + I + H, H), F = Math.max(0, F + v), G = Math.max(0, G + w);else {
      F = "start" === d ? x - R - q : "end" === d ? x - Y + A + K : "nearest" === d ? r(R, Y, D, q, A + K, x, x + b, b) : x - (R + D / 2) + K / 2, G = "start" === u ? I - L - j : "center" === u ? I - (L + O / 2) + J / 2 : "end" === u ? I - X + z + J : r(L, X, O, j, z + J, I, I + H, H);
      var N = k.scrollLeft,
        P = k.scrollTop;
      x += P - (F = Math.max(0, Math.min(P + F, k.scrollHeight - D + K))), I += N - (G = Math.max(0, Math.min(N + G, k.scrollWidth - O + J)));
    }
    C.push({
      el: k,
      top: F,
      left: G
    });
  }
  return C;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};

let idCounter = 0;

/**
 * Accepts a parameter and returns it if it's a function
 * or a noop function if it's not. This allows us to
 * accept a callback, but not worry about it if it's not
 * passed.
 * @param {Function} cb the callback
 * @return {Function} a function
 */
function cbToCb(cb) {
  return typeof cb === 'function' ? cb : noop;
}
function noop() {}

/**
 * Scroll node into view if necessary
 * @param {HTMLElement} node the element that should scroll into view
 * @param {HTMLElement} menuNode the menu element of the component
 */
function scrollIntoView(node, menuNode) {
  if (!node) {
    return;
  }
  const actions = computeScrollIntoView(node, {
    boundary: menuNode,
    block: 'nearest',
    scrollMode: 'if-needed'
  });
  actions.forEach(_ref => {
    let {
      el,
      top,
      left
    } = _ref;
    el.scrollTop = top;
    el.scrollLeft = left;
  });
}

/**
 * @param {HTMLElement} parent the parent node
 * @param {HTMLElement} child the child node
 * @param {Window} environment The window context where downshift renders.
 * @return {Boolean} whether the parent is the child or the child is in the parent
 */
function isOrContainsNode(parent, child, environment) {
  const result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
  return result;
}

/**
 * Simple debounce implementation. Will call the given
 * function once after the time given has passed since
 * it was last called.
 * @param {Function} fn the function to call after the time
 * @param {Number} time the time to wait
 * @return {Function} the debounced function
 */
function debounce(fn, time) {
  let timeoutId;
  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }
  function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    cancel();
    timeoutId = setTimeout(() => {
      timeoutId = null;
      fn(...args);
    }, time);
  }
  wrapper.cancel = cancel;
  return wrapper;
}

/**
 * This is intended to be used to compose event handlers.
 * They are executed in order until one of them sets
 * `event.preventDownshiftDefault = true`.
 * @param {...Function} fns the event handler functions
 * @return {Function} the event handler to add to an element
 */
function callAllEventHandlers() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }
  return function (event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return fns.some(fn => {
      if (fn) {
        fn(event, ...args);
      }
      return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;
    });
  };
}
function handleRefs() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }
  return node => {
    refs.forEach(ref => {
      if (typeof ref === 'function') {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
    });
  };
}

/**
 * This generates a unique ID for an instance of Downshift
 * @return {String} the unique ID
 */
function generateId() {
  return String(idCounter++);
}

/**
 * Default implementation for status message. Only added when menu is open.
 * Will specify if there are results in the list, and if so, how many,
 * and what keys are relevant.
 *
 * @param {Object} param the downshift state and other relevant properties
 * @return {String} the a11y status message
 */
function getA11yStatusMessage$1(_ref2) {
  let {
    isOpen,
    resultCount,
    previousResultCount
  } = _ref2;
  if (!isOpen) {
    return '';
  }
  if (!resultCount) {
    return 'No results are available.';
  }
  if (resultCount !== previousResultCount) {
    return `${resultCount} result${resultCount === 1 ? ' is' : 's are'} available, use up and down arrow keys to navigate. Press Enter key to select.`;
  }
  return '';
}

/**
 * Takes an argument and if it's an array, returns the first item in the array
 * otherwise returns the argument
 * @param {*} arg the maybe-array
 * @param {*} defaultValue the value if arg is falsey not defined
 * @return {*} the arg or it's first item
 */
function unwrapArray(arg, defaultValue) {
  arg = Array.isArray(arg) ? /* istanbul ignore next (preact) */arg[0] : arg;
  if (!arg && defaultValue) {
    return defaultValue;
  } else {
    return arg;
  }
}

/**
 * @param {Object} element (P)react element
 * @return {Boolean} whether it's a DOM element
 */
function isDOMElement(element) {
  // then we assume this is react
  return typeof element.type === 'string';
}

/**
 * @param {Object} element (P)react element
 * @return {Object} the props
 */
function getElementProps(element) {
  return element.props;
}

/**
 * Throws a helpful error message for required properties. Useful
 * to be used as a default in destructuring or object params.
 * @param {String} fnName the function name
 * @param {String} propName the prop name
 */
function requiredProp(fnName, propName) {
  // eslint-disable-next-line no-console
  console.error(`The property "${propName}" is required in "${fnName}"`);
}
const stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];
/**
 * @param {Object} state the state object
 * @return {Object} state that is relevant to downshift
 */
function pickState(state) {
  if (state === void 0) {
    state = {};
  }
  const result = {};
  stateKeys.forEach(k => {
    if (state.hasOwnProperty(k)) {
      result[k] = state[k];
    }
  });
  return result;
}

/**
 * This will perform a shallow merge of the given state object
 * with the state coming from props
 * (for the controlled component scenario)
 * This is used in state updater functions so they're referencing
 * the right state regardless of where it comes from.
 *
 * @param {Object} state The state of the component/hook.
 * @param {Object} props The props that may contain controlled values.
 * @returns {Object} The merged controlled state.
 */
function getState(state, props) {
  return Object.keys(state).reduce((prevState, key) => {
    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
    return prevState;
  }, {});
}

/**
 * This determines whether a prop is a "controlled prop" meaning it is
 * state which is controlled by the outside of this component rather
 * than within this component.
 *
 * @param {Object} props The props that may contain controlled values.
 * @param {String} key the key to check
 * @return {Boolean} whether it is a controlled controlled prop
 */
function isControlledProp(props, key) {
  return props[key] !== undefined;
}

/**
 * Normalizes the 'key' property of a KeyboardEvent in IE/Edge
 * @param {Object} event a keyboardEvent object
 * @return {String} keyboard key
 */
function normalizeArrowKey(event) {
  const {
    key,
    keyCode
  } = event;
  /* istanbul ignore next (ie) */
  if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {
    return `Arrow${key}`;
  }
  return key;
}

/**
 * Simple check if the value passed is object literal
 * @param {*} obj any things
 * @return {Boolean} whether it's object literal
 */
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}

/**
 * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,
 * it will wrap to either 0 or itemCount - 1.
 *
 * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.
 * @param {number} baseIndex The initial position to move from.
 * @param {number} itemCount The total number of items.
 * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
 * @param {boolean} circular Specify if navigation is circular. Default is true.
 * @returns {number} The new index after the move.
 */
function getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
  if (circular === void 0) {
    circular = true;
  }
  if (itemCount === 0) {
    return -1;
  }
  const itemsLastIndex = itemCount - 1;
  if (typeof baseIndex !== 'number' || baseIndex < 0 || baseIndex >= itemCount) {
    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
  }
  let newIndex = baseIndex + moveAmount;
  if (newIndex < 0) {
    newIndex = circular ? itemsLastIndex : 0;
  } else if (newIndex > itemsLastIndex) {
    newIndex = circular ? 0 : itemsLastIndex;
  }
  const nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);
  if (nonDisabledNewIndex === -1) {
    return baseIndex >= itemCount ? -1 : baseIndex;
  }
  return nonDisabledNewIndex;
}

/**
 * Returns the next index in the list of an item that is not disabled.
 *
 * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.
 * @param {number} baseIndex The initial position to move from.
 * @param {number} itemCount The total number of items.
 * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
 * @param {boolean} circular Specify if navigation is circular. Default is true.
 * @returns {number} The new index. Returns baseIndex if item is not disabled. Returns next non-disabled item otherwise. If no non-disabled found it will return -1.
 */
function getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
  const currentElementNode = getItemNodeFromIndex(baseIndex);
  if (!currentElementNode || !currentElementNode.hasAttribute('disabled')) {
    return baseIndex;
  }
  if (moveAmount > 0) {
    for (let index = baseIndex + 1; index < itemCount; index++) {
      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {
        return index;
      }
    }
  } else {
    for (let index = baseIndex - 1; index >= 0; index--) {
      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {
        return index;
      }
    }
  }
  if (circular) {
    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
  }
  return -1;
}

/**
 * Checks if event target is within the downshift elements.
 *
 * @param {EventTarget} target Target to check.
 * @param {HTMLElement[]} downshiftElements The elements that form downshift (list, toggle button etc).
 * @param {Window} environment The window context where downshift renders.
 * @param {boolean} checkActiveElement Whether to also check activeElement.
 *
 * @returns {boolean} Whether or not the target is within downshift elements.
 */
function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
  if (checkActiveElement === void 0) {
    checkActiveElement = true;
  }
  return downshiftElements.some(contextNode => contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment)));
}

// eslint-disable-next-line import/no-mutable-exports
let validateControlledUnchanged = noop;
/* istanbul ignore next */
if (process.env.NODE_ENV !== 'production') {
  validateControlledUnchanged = (state, prevProps, nextProps) => {
    const warningDescription = `This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props`;
    Object.keys(state).forEach(propKey => {
      if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {
        // eslint-disable-next-line no-console
        console.error(`downshift: A component has changed the controlled prop "${propKey}" to be uncontrolled. ${warningDescription}`);
      } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {
        // eslint-disable-next-line no-console
        console.error(`downshift: A component has changed the uncontrolled prop "${propKey}" to be controlled. ${warningDescription}`);
      }
    });
  };
}
const cleanupStatus = debounce(documentProp => {
  getStatusDiv(documentProp).textContent = '';
}, 500);

/**
 * @param {String} status the status message
 * @param {Object} documentProp document passed by the user.
 */
function setStatus(status, documentProp) {
  const div = getStatusDiv(documentProp);
  if (!status) {
    return;
  }
  div.textContent = status;
  cleanupStatus(documentProp);
}

/**
 * Get the status node or create it if it does not already exist.
 * @param {Object} documentProp document passed by the user.
 * @return {HTMLElement} the status node.
 */
function getStatusDiv(documentProp) {
  if (documentProp === void 0) {
    documentProp = document;
  }
  let statusDiv = documentProp.getElementById('a11y-status-message');
  if (statusDiv) {
    return statusDiv;
  }
  statusDiv = documentProp.createElement('div');
  statusDiv.setAttribute('id', 'a11y-status-message');
  statusDiv.setAttribute('role', 'status');
  statusDiv.setAttribute('aria-live', 'polite');
  statusDiv.setAttribute('aria-relevant', 'additions text');
  Object.assign(statusDiv.style, {
    border: '0',
    clip: 'rect(0 0 0 0)',
    height: '1px',
    margin: '-1px',
    overflow: 'hidden',
    padding: '0',
    position: 'absolute',
    width: '1px'
  });
  documentProp.body.appendChild(statusDiv);
  return statusDiv;
}
const unknown = process.env.NODE_ENV !== "production" ? '__autocomplete_unknown__' : 0;
const mouseUp = process.env.NODE_ENV !== "production" ? '__autocomplete_mouseup__' : 1;
const itemMouseEnter = process.env.NODE_ENV !== "production" ? '__autocomplete_item_mouseenter__' : 2;
const keyDownArrowUp = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_arrow_up__' : 3;
const keyDownArrowDown = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_arrow_down__' : 4;
const keyDownEscape = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_escape__' : 5;
const keyDownEnter = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_enter__' : 6;
const keyDownHome = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_home__' : 7;
const keyDownEnd = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_end__' : 8;
const clickItem = process.env.NODE_ENV !== "production" ? '__autocomplete_click_item__' : 9;
const blurInput = process.env.NODE_ENV !== "production" ? '__autocomplete_blur_input__' : 10;
const changeInput = process.env.NODE_ENV !== "production" ? '__autocomplete_change_input__' : 11;
const keyDownSpaceButton = process.env.NODE_ENV !== "production" ? '__autocomplete_keydown_space_button__' : 12;
const clickButton = process.env.NODE_ENV !== "production" ? '__autocomplete_click_button__' : 13;
const blurButton = process.env.NODE_ENV !== "production" ? '__autocomplete_blur_button__' : 14;
const controlledPropUpdatedSelectedItem = process.env.NODE_ENV !== "production" ? '__autocomplete_controlled_prop_updated_selected_item__' : 15;
const touchEnd = process.env.NODE_ENV !== "production" ? '__autocomplete_touchend__' : 16;
var stateChangeTypes$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unknown: unknown,
  mouseUp: mouseUp,
  itemMouseEnter: itemMouseEnter,
  keyDownArrowUp: keyDownArrowUp,
  keyDownArrowDown: keyDownArrowDown,
  keyDownEscape: keyDownEscape,
  keyDownEnter: keyDownEnter,
  keyDownHome: keyDownHome,
  keyDownEnd: keyDownEnd,
  clickItem: clickItem,
  blurInput: blurInput,
  changeInput: changeInput,
  keyDownSpaceButton: keyDownSpaceButton,
  clickButton: clickButton,
  blurButton: blurButton,
  controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,
  touchEnd: touchEnd
});

/* eslint camelcase:0 */
const Downshift = /*#__PURE__*/(() => {
  class Downshift extends React$2.Component {
    constructor(_props) {
      var _this;
      super(_props);
      _this = this;
      this.id = this.props.id || `downshift-${generateId()}`;
      this.menuId = this.props.menuId || `${this.id}-menu`;
      this.labelId = this.props.labelId || `${this.id}-label`;
      this.inputId = this.props.inputId || `${this.id}-input`;
      this.getItemId = this.props.getItemId || (index => `${this.id}-item-${index}`);
      this.input = null;
      this.items = [];
      this.itemCount = null;
      this.previousResultCount = 0;
      this.timeoutIds = [];
      this.internalSetTimeout = (fn, time) => {
        const id = setTimeout(() => {
          this.timeoutIds = this.timeoutIds.filter(i => i !== id);
          fn();
        }, time);
        this.timeoutIds.push(id);
      };
      this.setItemCount = count => {
        this.itemCount = count;
      };
      this.unsetItemCount = () => {
        this.itemCount = null;
      };
      this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {
        if (highlightedIndex === void 0) {
          highlightedIndex = _this.props.defaultHighlightedIndex;
        }
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState({
          highlightedIndex,
          ...otherStateToSet
        });
      };
      this.clearSelection = cb => {
        this.internalSetState({
          selectedItem: null,
          inputValue: '',
          highlightedIndex: this.props.defaultHighlightedIndex,
          isOpen: this.props.defaultIsOpen
        }, cb);
      };
      this.selectItem = (item, otherStateToSet, cb) => {
        otherStateToSet = pickState(otherStateToSet);
        this.internalSetState({
          isOpen: this.props.defaultIsOpen,
          highlightedIndex: this.props.defaultHighlightedIndex,
          selectedItem: item,
          inputValue: this.props.itemToString(item),
          ...otherStateToSet
        }, cb);
      };
      this.selectItemAtIndex = (itemIndex, otherStateToSet, cb) => {
        const item = this.items[itemIndex];
        if (item == null) {
          return;
        }
        this.selectItem(item, otherStateToSet, cb);
      };
      this.selectHighlightedItem = (otherStateToSet, cb) => {
        return this.selectItemAtIndex(this.getState().highlightedIndex, otherStateToSet, cb);
      };
      this.internalSetState = (stateToSet, cb) => {
        let isItemSelected, onChangeArg;
        const onStateChangeArg = {};
        const isStateToSetFunction = typeof stateToSet === 'function';

        // we want to call `onInputValueChange` before the `setState` call
        // so someone controlling the `inputValue` state gets notified of
        // the input change as soon as possible. This avoids issues with
        // preserving the cursor position.
        // See https://github.com/downshift-js/downshift/issues/217 for more info.
        if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {
          this.props.onInputValueChange(stateToSet.inputValue, {
            ...this.getStateAndHelpers(),
            ...stateToSet
          });
        }
        return this.setState(state => {
          state = this.getState(state);
          let newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet;

          // Your own function that could modify the state that will be set.
          newStateToSet = this.props.stateReducer(state, newStateToSet);

          // checks if an item is selected, regardless of if it's different from
          // what was selected before
          // used to determine if onSelect and onChange callbacks should be called
          isItemSelected = newStateToSet.hasOwnProperty('selectedItem');
          // this keeps track of the object we want to call with setState
          const nextState = {};
          // we need to call on change if the outside world is controlling any of our state
          // and we're trying to update that state. OR if the selection has changed and we're
          // trying to update the selection
          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {
            onChangeArg = newStateToSet.selectedItem;
          }
          newStateToSet.type = newStateToSet.type || unknown;
          Object.keys(newStateToSet).forEach(key => {
            // onStateChangeArg should only have the state that is
            // actually changing
            if (state[key] !== newStateToSet[key]) {
              onStateChangeArg[key] = newStateToSet[key];
            }
            // the type is useful for the onStateChangeArg
            // but we don't actually want to set it in internal state.
            // this is an undocumented feature for now... Not all internalSetState
            // calls support it and I'm not certain we want them to yet.
            // But it enables users controlling the isOpen state to know when
            // the isOpen state changes due to mouseup events which is quite handy.
            if (key === 'type') {
              return;
            }
            newStateToSet[key];
            // if it's coming from props, then we don't care to set it internally
            if (!isControlledProp(this.props, key)) {
              nextState[key] = newStateToSet[key];
            }
          });

          // if stateToSet is a function, then we weren't able to call onInputValueChange
          // earlier, so we'll call it now that we know what the inputValue state will be.
          if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {
            this.props.onInputValueChange(newStateToSet.inputValue, {
              ...this.getStateAndHelpers(),
              ...newStateToSet
            });
          }
          return nextState;
        }, () => {
          // call the provided callback if it's a function
          cbToCb(cb)();

          // only call the onStateChange and onChange callbacks if
          // we have relevant information to pass them.
          const hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;
          if (hasMoreStateThanType) {
            this.props.onStateChange(onStateChangeArg, this.getStateAndHelpers());
          }
          if (isItemSelected) {
            this.props.onSelect(stateToSet.selectedItem, this.getStateAndHelpers());
          }
          if (onChangeArg !== undefined) {
            this.props.onChange(onChangeArg, this.getStateAndHelpers());
          }
          // this is currently undocumented and therefore subject to change
          // We'll try to not break it, but just be warned.
          this.props.onUserAction(onStateChangeArg, this.getStateAndHelpers());
        });
      };
      this.rootRef = node => this._rootNode = node;
      this.getRootProps = function (_temp, _temp2) {
        let {
          refKey = 'ref',
          ref,
          ...rest
        } = _temp === void 0 ? {} : _temp;
        let {
          suppressRefError = false
        } = _temp2 === void 0 ? {} : _temp2;
        // this is used in the render to know whether the user has called getRootProps.
        // It uses that to know whether to apply the props automatically
        _this.getRootProps.called = true;
        _this.getRootProps.refKey = refKey;
        _this.getRootProps.suppressRefError = suppressRefError;
        const {
          isOpen
        } = _this.getState();
        return {
          [refKey]: handleRefs(ref, _this.rootRef),
          role: 'combobox',
          'aria-expanded': isOpen,
          'aria-haspopup': 'listbox',
          'aria-owns': isOpen ? _this.menuId : null,
          'aria-labelledby': _this.labelId,
          ...rest
        };
      };
      this.keyDownHandlers = {
        ArrowDown(event) {
          event.preventDefault();
          if (this.getState().isOpen) {
            const amount = event.shiftKey ? 5 : 1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowDown
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowDown
            }, () => {
              const itemCount = this.getItemCount();
              if (itemCount > 0) {
                const {
                  highlightedIndex
                } = this.getState();
                const nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));
                this.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowDown
                });
              }
            });
          }
        },
        ArrowUp(event) {
          event.preventDefault();
          if (this.getState().isOpen) {
            const amount = event.shiftKey ? -5 : -1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowUp
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowUp
            }, () => {
              const itemCount = this.getItemCount();
              if (itemCount > 0) {
                const {
                  highlightedIndex
                } = this.getState();
                const nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));
                this.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowUp
                });
              }
            });
          }
        },
        Enter(event) {
          if (event.which === 229) {
            return;
          }
          const {
            isOpen,
            highlightedIndex
          } = this.getState();
          if (isOpen && highlightedIndex != null) {
            event.preventDefault();
            const item = this.items[highlightedIndex];
            const itemNode = this.getItemNodeFromIndex(highlightedIndex);
            if (item == null || itemNode && itemNode.hasAttribute('disabled')) {
              return;
            }
            this.selectHighlightedItem({
              type: keyDownEnter
            });
          }
        },
        Escape(event) {
          event.preventDefault();
          this.reset({
            type: keyDownEscape,
            ...(!this.state.isOpen && {
              selectedItem: null,
              inputValue: ''
            })
          });
        }
      };
      this.buttonKeyDownHandlers = {
        ...this.keyDownHandlers,
        ' '(event) {
          event.preventDefault();
          this.toggleMenu({
            type: keyDownSpaceButton
          });
        }
      };
      this.inputKeyDownHandlers = {
        ...this.keyDownHandlers,
        Home(event) {
          const {
            isOpen
          } = this.getState();
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          const itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }

          // get next non-disabled starting downwards from 0 if that's disabled.
          const newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, index => this.getItemNodeFromIndex(index), false);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownHome
          });
        },
        End(event) {
          const {
            isOpen
          } = this.getState();
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          const itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }

          // get next non-disabled starting upwards from last index if that's disabled.
          const newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, index => this.getItemNodeFromIndex(index), false);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownEnd
          });
        }
      };
      this.getToggleButtonProps = function (_temp3) {
        let {
          onClick,
          onPress,
          onKeyDown,
          onKeyUp,
          onBlur,
          ...rest
        } = _temp3 === void 0 ? {} : _temp3;
        const {
          isOpen
        } = _this.getState();
        const enabledEventHandlers = {
          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),
          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),
          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),
          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)
        };
        const eventHandlers = rest.disabled ? {} : enabledEventHandlers;
        return {
          type: 'button',
          role: 'button',
          'aria-label': isOpen ? 'close menu' : 'open menu',
          'aria-haspopup': true,
          'data-toggle': true,
          ...eventHandlers,
          ...rest
        };
      };
      this.buttonHandleKeyUp = event => {
        // Prevent click event from emitting in Firefox
        event.preventDefault();
      };
      this.buttonHandleKeyDown = event => {
        const key = normalizeArrowKey(event);
        if (this.buttonKeyDownHandlers[key]) {
          this.buttonKeyDownHandlers[key].call(this, event);
        }
      };
      this.buttonHandleClick = event => {
        event.preventDefault();
        // handle odd case for Safari and Firefox which
        // don't give the button the focus properly.
        /* istanbul ignore if (can't reasonably test this) */
        if (this.props.environment.document.activeElement === this.props.environment.document.body) {
          event.target.focus();
        }
        // to simplify testing components that use downshift, we'll not wrap this in a setTimeout
        // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated
        // when building for production and should therefore have no impact on production code.
        if (process.env.NODE_ENV === 'test') {
          this.toggleMenu({
            type: clickButton
          });
        } else {
          // Ensure that toggle of menu occurs after the potential blur event in iOS
          this.internalSetTimeout(() => this.toggleMenu({
            type: clickButton
          }));
        }
      };
      this.buttonHandleBlur = event => {
        const blurTarget = event.target; // Save blur target for comparison with activeElement later
        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element
        this.internalSetTimeout(() => {
          if (!this.isMouseDown && (this.props.environment.document.activeElement == null || this.props.environment.document.activeElement.id !== this.inputId) && this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)
          ) {
            this.reset({
              type: blurButton
            });
          }
        });
      };
      this.getLabelProps = props => {
        return {
          htmlFor: this.inputId,
          id: this.labelId,
          ...props
        };
      };
      this.getInputProps = function (_temp4) {
        let {
          onKeyDown,
          onBlur,
          onChange,
          onInput,
          onChangeText,
          ...rest
        } = _temp4 === void 0 ? {} : _temp4;
        let onChangeKey;
        let eventHandlers = {};

        /* istanbul ignore next (preact) */
        {
          onChangeKey = 'onChange';
        }
        const {
          inputValue,
          isOpen,
          highlightedIndex
        } = _this.getState();
        if (!rest.disabled) {
          eventHandlers = {
            [onChangeKey]: callAllEventHandlers(onChange, onInput, _this.inputHandleChange),
            onKeyDown: callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown),
            onBlur: callAllEventHandlers(onBlur, _this.inputHandleBlur)
          };
        }
        return {
          'aria-autocomplete': 'list',
          'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,
          'aria-controls': isOpen ? _this.menuId : null,
          'aria-labelledby': _this.labelId,
          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
          // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
          autoComplete: 'off',
          value: inputValue,
          id: _this.inputId,
          ...eventHandlers,
          ...rest
        };
      };
      this.inputHandleKeyDown = event => {
        const key = normalizeArrowKey(event);
        if (key && this.inputKeyDownHandlers[key]) {
          this.inputKeyDownHandlers[key].call(this, event);
        }
      };
      this.inputHandleChange = event => {
        this.internalSetState({
          type: changeInput,
          isOpen: true,
          inputValue: event.target.value,
          highlightedIndex: this.props.defaultHighlightedIndex
        });
      };
      this.inputHandleBlur = () => {
        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element
        this.internalSetTimeout(() => {
          const downshiftButtonIsActive = this.props.environment.document && !!this.props.environment.document.activeElement && !!this.props.environment.document.activeElement.dataset && this.props.environment.document.activeElement.dataset.toggle && this._rootNode && this._rootNode.contains(this.props.environment.document.activeElement);
          if (!this.isMouseDown && !downshiftButtonIsActive) {
            this.reset({
              type: blurInput
            });
          }
        });
      };
      this.menuRef = node => {
        this._menuNode = node;
      };
      this.getMenuProps = function (_temp5, _temp6) {
        let {
          refKey = 'ref',
          ref,
          ...props
        } = _temp5 === void 0 ? {} : _temp5;
        let {
          suppressRefError = false
        } = _temp6 === void 0 ? {} : _temp6;
        _this.getMenuProps.called = true;
        _this.getMenuProps.refKey = refKey;
        _this.getMenuProps.suppressRefError = suppressRefError;
        return {
          [refKey]: handleRefs(ref, _this.menuRef),
          role: 'listbox',
          'aria-labelledby': props && props['aria-label'] ? null : _this.labelId,
          id: _this.menuId,
          ...props
        };
      };
      this.getItemProps = function (_temp7) {
        let {
          onMouseMove,
          onMouseDown,
          onClick,
          onPress,
          index,
          item = process.env.NODE_ENV === 'production' ? /* istanbul ignore next */undefined : requiredProp('getItemProps', 'item'),
          ...rest
        } = _temp7 === void 0 ? {} : _temp7;
        if (index === undefined) {
          _this.items.push(item);
          index = _this.items.indexOf(item);
        } else {
          _this.items[index] = item;
        }
        const onSelectKey = 'onClick';
        const customClickHandler = onClick;
        const enabledEventHandlers = {
          // onMouseMove is used over onMouseEnter here. onMouseMove
          // is only triggered on actual mouse movement while onMouseEnter
          // can fire on DOM changes, interrupting keyboard navigation
          onMouseMove: callAllEventHandlers(onMouseMove, () => {
            if (index === _this.getState().highlightedIndex) {
              return;
            }
            _this.setHighlightedIndex(index, {
              type: itemMouseEnter
            });

            // We never want to manually scroll when changing state based
            // on `onMouseMove` because we will be moving the element out
            // from under the user which is currently scrolling/moving the
            // cursor
            _this.avoidScrolling = true;
            _this.internalSetTimeout(() => _this.avoidScrolling = false, 250);
          }),
          onMouseDown: callAllEventHandlers(onMouseDown, event => {
            // This prevents the activeElement from being changed
            // to the item so it can remain with the current activeElement
            // which is a more common use case.
            event.preventDefault();
          }),
          [onSelectKey]: callAllEventHandlers(customClickHandler, () => {
            _this.selectItemAtIndex(index, {
              type: clickItem
            });
          })
        };

        // Passing down the onMouseDown handler to prevent redirect
        // of the activeElement if clicking on disabled items
        const eventHandlers = rest.disabled ? {
          onMouseDown: enabledEventHandlers.onMouseDown
        } : enabledEventHandlers;
        return {
          id: _this.getItemId(index),
          role: 'option',
          'aria-selected': _this.getState().highlightedIndex === index,
          ...eventHandlers,
          ...rest
        };
      };
      this.clearItems = () => {
        this.items = [];
      };
      this.reset = function (otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(_ref => {
          let {
            selectedItem
          } = _ref;
          return {
            isOpen: _this.props.defaultIsOpen,
            highlightedIndex: _this.props.defaultHighlightedIndex,
            inputValue: _this.props.itemToString(selectedItem),
            ...otherStateToSet
          };
        }, cb);
      };
      this.toggleMenu = function (otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(_ref2 => {
          let {
            isOpen
          } = _ref2;
          return {
            isOpen: !isOpen,
            ...(isOpen && {
              highlightedIndex: _this.props.defaultHighlightedIndex
            }),
            ...otherStateToSet
          };
        }, () => {
          const {
            isOpen,
            highlightedIndex
          } = _this.getState();
          if (isOpen) {
            if (_this.getItemCount() > 0 && typeof highlightedIndex === 'number') {
              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);
            }
          }
          cbToCb(cb)();
        });
      };
      this.openMenu = cb => {
        this.internalSetState({
          isOpen: true
        }, cb);
      };
      this.closeMenu = cb => {
        this.internalSetState({
          isOpen: false
        }, cb);
      };
      this.updateStatus = debounce(() => {
        const state = this.getState();
        const item = this.items[state.highlightedIndex];
        const resultCount = this.getItemCount();
        const status = this.props.getA11yStatusMessage({
          itemToString: this.props.itemToString,
          previousResultCount: this.previousResultCount,
          resultCount,
          highlightedItem: item,
          ...state
        });
        this.previousResultCount = resultCount;
        setStatus(status, this.props.environment.document);
      }, 200);
      // fancy destructuring + defaults + aliases
      // this basically says each value of state should either be set to
      // the initial value or the default value if the initial value is not provided
      const {
        defaultHighlightedIndex,
        initialHighlightedIndex: _highlightedIndex = defaultHighlightedIndex,
        defaultIsOpen,
        initialIsOpen: _isOpen = defaultIsOpen,
        initialInputValue: _inputValue = '',
        initialSelectedItem: _selectedItem = null
      } = this.props;
      const _state = this.getState({
        highlightedIndex: _highlightedIndex,
        isOpen: _isOpen,
        inputValue: _inputValue,
        selectedItem: _selectedItem
      });
      if (_state.selectedItem != null && this.props.initialInputValue === undefined) {
        _state.inputValue = this.props.itemToString(_state.selectedItem);
      }
      this.state = _state;
    }
    /**
     * Clear all running timeouts
     */
    internalClearTimeouts() {
      this.timeoutIds.forEach(id => {
        clearTimeout(id);
      });
      this.timeoutIds = [];
    }

    /**
     * Gets the state based on internal state or props
     * If a state value is passed via props, then that
     * is the value given, otherwise it's retrieved from
     * stateToMerge
     *
     * @param {Object} stateToMerge defaults to this.state
     * @return {Object} the state
     */
    getState(stateToMerge) {
      if (stateToMerge === void 0) {
        stateToMerge = this.state;
      }
      return getState(stateToMerge, this.props);
    }
    getItemCount() {
      // things read better this way. They're in priority order:
      // 1. `this.itemCount`
      // 2. `this.props.itemCount`
      // 3. `this.items.length`
      let itemCount = this.items.length;
      if (this.itemCount != null) {
        itemCount = this.itemCount;
      } else if (this.props.itemCount !== undefined) {
        itemCount = this.props.itemCount;
      }
      return itemCount;
    }
    getItemNodeFromIndex(index) {
      return this.props.environment.document.getElementById(this.getItemId(index));
    }
    scrollHighlightedItemIntoView() {
      /* istanbul ignore else (react-native) */
      {
        const node = this.getItemNodeFromIndex(this.getState().highlightedIndex);
        this.props.scrollIntoView(node, this._menuNode);
      }
    }
    moveHighlightedIndex(amount, otherStateToSet) {
      const itemCount = this.getItemCount();
      const {
        highlightedIndex
      } = this.getState();
      if (itemCount > 0) {
        const nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));
        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);
      }
    }
    getStateAndHelpers() {
      const {
        highlightedIndex,
        inputValue,
        selectedItem,
        isOpen
      } = this.getState();
      const {
        itemToString
      } = this.props;
      const {
        id
      } = this;
      const {
        getRootProps,
        getToggleButtonProps,
        getLabelProps,
        getMenuProps,
        getInputProps,
        getItemProps,
        openMenu,
        closeMenu,
        toggleMenu,
        selectItem,
        selectItemAtIndex,
        selectHighlightedItem,
        setHighlightedIndex,
        clearSelection,
        clearItems,
        reset,
        setItemCount,
        unsetItemCount,
        internalSetState: setState
      } = this;
      return {
        // prop getters
        getRootProps,
        getToggleButtonProps,
        getLabelProps,
        getMenuProps,
        getInputProps,
        getItemProps,
        // actions
        reset,
        openMenu,
        closeMenu,
        toggleMenu,
        selectItem,
        selectItemAtIndex,
        selectHighlightedItem,
        setHighlightedIndex,
        clearSelection,
        clearItems,
        setItemCount,
        unsetItemCount,
        setState,
        // props
        itemToString,
        // derived
        id,
        // state
        highlightedIndex,
        inputValue,
        isOpen,
        selectedItem
      };
    }

    //////////////////////////// ROOT

    componentDidMount() {
      /* istanbul ignore if (react-native) */
      if (process.env.NODE_ENV !== 'production' && !false && this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
      }

      /* istanbul ignore if (react-native) */
      {
        // this.isMouseDown helps us track whether the mouse is currently held down.
        // This is useful when the user clicks on an item in the list, but holds the mouse
        // down long enough for the list to disappear (because the blur event fires on the input)
        // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should
        // trigger hiding the menu.
        const onMouseDown = () => {
          this.isMouseDown = true;
        };
        const onMouseUp = event => {
          this.isMouseDown = false;
          // if the target element or the activeElement is within a downshift node
          // then we don't want to reset downshift
          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment);
          if (!contextWithinDownshift && this.getState().isOpen) {
            this.reset({
              type: mouseUp
            }, () => this.props.onOuterClick(this.getStateAndHelpers()));
          }
        };
        // Touching an element in iOS gives focus and hover states, but touching out of
        // the element will remove hover, and persist the focus state, resulting in the
        // blur event not being triggered.
        // this.isTouchMove helps us track whether the user is tapping or swiping on a touch screen.
        // If the user taps outside of Downshift, the component should be reset,
        // but not if the user is swiping
        const onTouchStart = () => {
          this.isTouchMove = false;
        };
        const onTouchMove = () => {
          this.isTouchMove = true;
        };
        const onTouchEnd = event => {
          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment, false);
          if (!this.isTouchMove && !contextWithinDownshift && this.getState().isOpen) {
            this.reset({
              type: touchEnd
            }, () => this.props.onOuterClick(this.getStateAndHelpers()));
          }
        };
        const {
          environment
        } = this.props;
        environment.addEventListener('mousedown', onMouseDown);
        environment.addEventListener('mouseup', onMouseUp);
        environment.addEventListener('touchstart', onTouchStart);
        environment.addEventListener('touchmove', onTouchMove);
        environment.addEventListener('touchend', onTouchEnd);
        this.cleanup = () => {
          this.internalClearTimeouts();
          this.updateStatus.cancel();
          environment.removeEventListener('mousedown', onMouseDown);
          environment.removeEventListener('mouseup', onMouseUp);
          environment.removeEventListener('touchstart', onTouchStart);
          environment.removeEventListener('touchmove', onTouchMove);
          environment.removeEventListener('touchend', onTouchEnd);
        };
      }
    }
    shouldScroll(prevState, prevProps) {
      const {
        highlightedIndex: currentHighlightedIndex
      } = this.props.highlightedIndex === undefined ? this.getState() : this.props;
      const {
        highlightedIndex: prevHighlightedIndex
      } = prevProps.highlightedIndex === undefined ? prevState : prevProps;
      const scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;
      const scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;
      return scrollWhenOpen || scrollWhenNavigating;
    }
    componentDidUpdate(prevProps, prevState) {
      if (process.env.NODE_ENV !== 'production') {
        validateControlledUnchanged(this.state, prevProps, this.props);
        /* istanbul ignore if (react-native) */
        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
        }
      }
      if (isControlledProp(this.props, 'selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {
        this.internalSetState({
          type: controlledPropUpdatedSelectedItem,
          inputValue: this.props.itemToString(this.props.selectedItem)
        });
      }
      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {
        this.scrollHighlightedItemIntoView();
      }

      /* istanbul ignore else (react-native) */
      {
        this.updateStatus();
      }
    }
    componentWillUnmount() {
      this.cleanup(); // avoids memory leak
    }

    render() {
      const children = unwrapArray(this.props.children, noop);
      // because the items are rerendered every time we call the children
      // we clear this out each render and it will be populated again as
      // getItemProps is called.
      this.clearItems();
      // we reset this so we know whether the user calls getRootProps during
      // this render. If they do then we don't need to do anything,
      // if they don't then we need to clone the element they return and
      // apply the props for them.
      this.getRootProps.called = false;
      this.getRootProps.refKey = undefined;
      this.getRootProps.suppressRefError = undefined;
      // we do something similar for getMenuProps
      this.getMenuProps.called = false;
      this.getMenuProps.refKey = undefined;
      this.getMenuProps.suppressRefError = undefined;
      // we do something similar for getLabelProps
      this.getLabelProps.called = false;
      // and something similar for getInputProps
      this.getInputProps.called = false;
      const element = unwrapArray(children(this.getStateAndHelpers()));
      if (!element) {
        return null;
      }
      if (this.getRootProps.called || this.props.suppressRefError) {
        if (process.env.NODE_ENV !== 'production' && !this.getRootProps.suppressRefError && !this.props.suppressRefError) {
          validateGetRootPropsCalledCorrectly(element, this.getRootProps);
        }
        return element;
      } else if (isDOMElement(element)) {
        // they didn't apply the root props, but we can clone
        // this and apply the props ourselves
        return /*#__PURE__*/React$2.cloneElement(element, this.getRootProps(getElementProps(element)));
      }

      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        // they didn't apply the root props, but they need to
        // otherwise we can't query around the autocomplete

        throw new Error('downshift: If you return a non-DOM element, you must apply the getRootProps function');
      }

      /* istanbul ignore next */
      return undefined;
    }
  }
  Downshift.defaultProps = {
    defaultHighlightedIndex: null,
    defaultIsOpen: false,
    getA11yStatusMessage: getA11yStatusMessage$1,
    itemToString: i => {
      if (i == null) {
        return '';
      }
      if (process.env.NODE_ENV !== 'production' && isPlainObject(i) && !i.hasOwnProperty('toString')) {
        // eslint-disable-next-line no-console
        console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);
      }
      return String(i);
    },
    onStateChange: noop,
    onInputValueChange: noop,
    onUserAction: noop,
    onChange: noop,
    onSelect: noop,
    onOuterClick: noop,
    selectedItemChanged: (prevItem, item) => prevItem !== item,
    environment: /* istanbul ignore next (ssr) */
    typeof window === 'undefined' ? {} : window,
    stateReducer: (state, stateToSet) => stateToSet,
    suppressRefError: false,
    scrollIntoView
  };
  Downshift.stateChangeTypes = stateChangeTypes$3;
  return Downshift;
})();
process.env.NODE_ENV !== "production" ? Downshift.propTypes = {
  children: propTypes.exports.func,
  defaultHighlightedIndex: propTypes.exports.number,
  defaultIsOpen: propTypes.exports.bool,
  initialHighlightedIndex: propTypes.exports.number,
  initialSelectedItem: propTypes.exports.any,
  initialInputValue: propTypes.exports.string,
  initialIsOpen: propTypes.exports.bool,
  getA11yStatusMessage: propTypes.exports.func,
  itemToString: propTypes.exports.func,
  onChange: propTypes.exports.func,
  onSelect: propTypes.exports.func,
  onStateChange: propTypes.exports.func,
  onInputValueChange: propTypes.exports.func,
  onUserAction: propTypes.exports.func,
  onOuterClick: propTypes.exports.func,
  selectedItemChanged: propTypes.exports.func,
  stateReducer: propTypes.exports.func,
  itemCount: propTypes.exports.number,
  id: propTypes.exports.string,
  environment: propTypes.exports.shape({
    addEventListener: propTypes.exports.func,
    removeEventListener: propTypes.exports.func,
    document: propTypes.exports.shape({
      getElementById: propTypes.exports.func,
      activeElement: propTypes.exports.any,
      body: propTypes.exports.any
    })
  }),
  suppressRefError: propTypes.exports.bool,
  scrollIntoView: propTypes.exports.func,
  // things we keep in state for uncontrolled components
  // but can accept as props for controlled components
  /* eslint-disable react/no-unused-prop-types */
  selectedItem: propTypes.exports.any,
  isOpen: propTypes.exports.bool,
  inputValue: propTypes.exports.string,
  highlightedIndex: propTypes.exports.number,
  labelId: propTypes.exports.string,
  inputId: propTypes.exports.string,
  menuId: propTypes.exports.string,
  getItemId: propTypes.exports.func
  /* eslint-enable react/no-unused-prop-types */
} : void 0;
var Downshift$1 = Downshift;
function validateGetMenuPropsCalledCorrectly(node, _ref3) {
  let {
    refKey
  } = _ref3;
  if (!node) {
    // eslint-disable-next-line no-console
    console.error(`downshift: The ref prop "${refKey}" from getMenuProps was not applied correctly on your menu element.`);
  }
}
function validateGetRootPropsCalledCorrectly(element, _ref4) {
  let {
    refKey
  } = _ref4;
  const refKeySpecified = refKey !== 'ref';
  const isComposite = !isDOMElement(element);
  if (isComposite && !refKeySpecified && !reactIs.exports.isForwardRef(element)) {
    // eslint-disable-next-line no-console
    console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');
  } else if (!isComposite && refKeySpecified) {
    // eslint-disable-next-line no-console
    console.error(`downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified "${refKey}"`);
  }
  if (!reactIs.exports.isForwardRef(element) && !getElementProps(element)[refKey]) {
    // eslint-disable-next-line no-console
    console.error(`downshift: You must apply the ref prop "${refKey}" from getRootProps onto your root element.`);
  }
}

/**
 * Default state reducer that returns the changes.
 *
 * @param {Object} s state.
 * @param {Object} a action with changes.
 * @returns {Object} changes.
 */
function stateReducer(s, a) {
  return a.changes;
}

/**
 * Returns a message to be added to aria-live region when item is selected.
 *
 * @param {Object} selectionParameters Parameters required to build the message.
 * @returns {string} The a11y message.
 */
function getA11ySelectionMessage(selectionParameters) {
  const {
    selectedItem,
    itemToString: itemToStringLocal
  } = selectionParameters;
  return selectedItem ? `${itemToStringLocal(selectedItem)} has been selected.` : '';
}

/**
 * Debounced call for updating the a11y message.
 */
debounce((getA11yMessage, document) => {
  setStatus(getA11yMessage(), document);
}, 200);
function itemToString(item) {
  return item ? String(item) : '';
}
const defaultProps$3 = {
  itemToString,
  stateReducer,
  getA11ySelectionMessage,
  scrollIntoView,
  environment: /* istanbul ignore next (ssr) */
  typeof window === 'undefined' ? {} : window
};
/**
 * Custom hook that checks if getter props are called correctly.
 *
 * @param  {...any} propKeys Getter prop names to be handled.
 * @returns {Function} Setter function called inside getter props to set call information.
 */
/* istanbul ignore next */
if (process.env.NODE_ENV !== 'production') ;
/* istanbul ignore next */
if (process.env.NODE_ENV !== 'production') ;
({
  items: propTypes.exports.array.isRequired,
  itemToString: propTypes.exports.func,
  getA11yStatusMessage: propTypes.exports.func,
  getA11ySelectionMessage: propTypes.exports.func,
  highlightedIndex: propTypes.exports.number,
  defaultHighlightedIndex: propTypes.exports.number,
  initialHighlightedIndex: propTypes.exports.number,
  isOpen: propTypes.exports.bool,
  defaultIsOpen: propTypes.exports.bool,
  initialIsOpen: propTypes.exports.bool,
  selectedItem: propTypes.exports.any,
  initialSelectedItem: propTypes.exports.any,
  defaultSelectedItem: propTypes.exports.any,
  id: propTypes.exports.string,
  labelId: propTypes.exports.string,
  menuId: propTypes.exports.string,
  getItemId: propTypes.exports.func,
  toggleButtonId: propTypes.exports.string,
  stateReducer: propTypes.exports.func,
  onSelectedItemChange: propTypes.exports.func,
  onHighlightedIndexChange: propTypes.exports.func,
  onStateChange: propTypes.exports.func,
  onIsOpenChange: propTypes.exports.func,
  environment: propTypes.exports.shape({
    addEventListener: propTypes.exports.func,
    removeEventListener: propTypes.exports.func,
    document: propTypes.exports.shape({
      getElementById: propTypes.exports.func,
      activeElement: propTypes.exports.any,
      body: propTypes.exports.any
    })
  })
});
/**
 * Default implementation for status message. Only added when menu is open.
 * Will specift if there are results in the list, and if so, how many,
 * and what keys are relevant.
 *
 * @param {Object} param the downshift state and other relevant properties
 * @return {String} the a11y status message
 */
function getA11yStatusMessage(_a) {
  var isOpen = _a.isOpen,
    resultCount = _a.resultCount,
    previousResultCount = _a.previousResultCount;
  if (!isOpen) {
    return '';
  }
  if (!resultCount) {
    return 'No results are available.';
  }
  if (resultCount !== previousResultCount) {
    return "".concat(resultCount, " result").concat(resultCount === 1 ? ' is' : 's are', " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.");
  }
  return '';
}
__assign(__assign({}, defaultProps$3), {
  getA11yStatusMessage: getA11yStatusMessage
});
/* istanbul ignore next */
if (process.env.NODE_ENV !== 'production') ;
process.env.NODE_ENV !== "production" ? '__togglebutton_click__' : 0;
process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_arrow_down__' : 1;
process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_arrow_up__' : 2;
process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_character__' : 3;
process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_escape__' : 4;
process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_home__' : 5;
process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_end__' : 6;
process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_enter__' : 7;
process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_space_button__' : 8;
process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_page_up__' : 9;
process.env.NODE_ENV !== "production" ? '__togglebutton_keydown_page_down__' : 10;
process.env.NODE_ENV !== "production" ? '__togglebutton_blur__' : 11;
process.env.NODE_ENV !== "production" ? '__menu_mouse_leave__' : 12;
process.env.NODE_ENV !== "production" ? '__item_mouse_move__' : 13;
process.env.NODE_ENV !== "production" ? '__item_click__' : 14;
process.env.NODE_ENV !== "production" ? '__function_toggle_menu__' : 15;
process.env.NODE_ENV !== "production" ? '__function_open_menu__' : 16;
process.env.NODE_ENV !== "production" ? '__function_close_menu__' : 17;
process.env.NODE_ENV !== "production" ? '__function_set_highlighted_index__' : 18;
process.env.NODE_ENV !== "production" ? '__function_select_item__' : 19;
process.env.NODE_ENV !== "production" ? '__function_set_input_value__' : 20;
process.env.NODE_ENV !== "production" ? '__function_reset__' : 21;
process.env.NODE_ENV !== "production" ? '__input_keydown_arrow_down__' : 0;
process.env.NODE_ENV !== "production" ? '__input_keydown_arrow_up__' : 1;
process.env.NODE_ENV !== "production" ? '__input_keydown_escape__' : 2;
process.env.NODE_ENV !== "production" ? '__input_keydown_home__' : 3;
process.env.NODE_ENV !== "production" ? '__input_keydown_end__' : 4;
process.env.NODE_ENV !== "production" ? '__input_keydown_page_up__' : 5;
process.env.NODE_ENV !== "production" ? '__input_keydown_page_down__' : 6;
process.env.NODE_ENV !== "production" ? '__input_keydown_enter__' : 7;
process.env.NODE_ENV !== "production" ? '__input_change__' : 8;
process.env.NODE_ENV !== "production" ? '__input_blur__' : 9;
process.env.NODE_ENV !== "production" ? '__input_focus__' : 10;
process.env.NODE_ENV !== "production" ? '__menu_mouse_leave__' : 11;
process.env.NODE_ENV !== "production" ? '__item_mouse_move__' : 12;
process.env.NODE_ENV !== "production" ? '__item_click__' : 13;
process.env.NODE_ENV !== "production" ? '__togglebutton_click__' : 14;
process.env.NODE_ENV !== "production" ? '__function_toggle_menu__' : 15;
process.env.NODE_ENV !== "production" ? '__function_open_menu__' : 16;
process.env.NODE_ENV !== "production" ? '__function_close_menu__' : 17;
process.env.NODE_ENV !== "production" ? '__function_set_highlighted_index__' : 18;
process.env.NODE_ENV !== "production" ? '__function_select_item__' : 19;
process.env.NODE_ENV !== "production" ? '__function_set_input_value__' : 20;
process.env.NODE_ENV !== "production" ? '__function_reset__' : 21;
process.env.NODE_ENV !== "production" ? '__controlled_prop_updated_selected_item__' : 22;
({
  items: propTypes.exports.array.isRequired,
  itemToString: propTypes.exports.func,
  getA11yStatusMessage: propTypes.exports.func,
  getA11ySelectionMessage: propTypes.exports.func,
  highlightedIndex: propTypes.exports.number,
  defaultHighlightedIndex: propTypes.exports.number,
  initialHighlightedIndex: propTypes.exports.number,
  isOpen: propTypes.exports.bool,
  defaultIsOpen: propTypes.exports.bool,
  initialIsOpen: propTypes.exports.bool,
  selectedItem: propTypes.exports.any,
  initialSelectedItem: propTypes.exports.any,
  defaultSelectedItem: propTypes.exports.any,
  inputValue: propTypes.exports.string,
  defaultInputValue: propTypes.exports.string,
  initialInputValue: propTypes.exports.string,
  id: propTypes.exports.string,
  labelId: propTypes.exports.string,
  menuId: propTypes.exports.string,
  getItemId: propTypes.exports.func,
  inputId: propTypes.exports.string,
  toggleButtonId: propTypes.exports.string,
  stateReducer: propTypes.exports.func,
  onSelectedItemChange: propTypes.exports.func,
  onHighlightedIndexChange: propTypes.exports.func,
  onStateChange: propTypes.exports.func,
  onIsOpenChange: propTypes.exports.func,
  onInputValueChange: propTypes.exports.func,
  environment: propTypes.exports.shape({
    addEventListener: propTypes.exports.func,
    removeEventListener: propTypes.exports.func,
    document: propTypes.exports.shape({
      getElementById: propTypes.exports.func,
      activeElement: propTypes.exports.any,
      body: propTypes.exports.any
    })
  })
});
/* istanbul ignore next */
if (process.env.NODE_ENV !== 'production') ;
({
  ...defaultProps$3,
  getA11yStatusMessage: getA11yStatusMessage$1
});

/**
 * Returns a message to be added to aria-live region when item is removed.
 *
 * @param {Object} selectionParameters Parameters required to build the message.
 * @returns {string} The a11y message.
 */
function getA11yRemovalMessage(selectionParameters) {
  const {
    removedSelectedItem,
    itemToString: itemToStringLocal
  } = selectionParameters;
  return `${itemToStringLocal(removedSelectedItem)} has been removed.`;
}
({
  selectedItems: propTypes.exports.array,
  initialSelectedItems: propTypes.exports.array,
  defaultSelectedItems: propTypes.exports.array,
  itemToString: propTypes.exports.func,
  getA11yRemovalMessage: propTypes.exports.func,
  stateReducer: propTypes.exports.func,
  activeIndex: propTypes.exports.number,
  initialActiveIndex: propTypes.exports.number,
  defaultActiveIndex: propTypes.exports.number,
  onActiveIndexChange: propTypes.exports.func,
  onSelectedItemsChange: propTypes.exports.func,
  keyNavigationNext: propTypes.exports.string,
  keyNavigationPrevious: propTypes.exports.string,
  environment: propTypes.exports.shape({
    addEventListener: propTypes.exports.func,
    removeEventListener: propTypes.exports.func,
    document: propTypes.exports.shape({
      getElementById: propTypes.exports.func,
      activeElement: propTypes.exports.any,
      body: propTypes.exports.any
    })
  })
});
({
  itemToString: defaultProps$3.itemToString,
  stateReducer: defaultProps$3.stateReducer,
  environment: defaultProps$3.environment,
  getA11yRemovalMessage,
  keyNavigationNext: 'ArrowRight',
  keyNavigationPrevious: 'ArrowLeft'
});
/* istanbul ignore next */
if (process.env.NODE_ENV !== 'production') ;
process.env.NODE_ENV !== "production" ? '__selected_item_click__' : 0;
process.env.NODE_ENV !== "production" ? '__selected_item_keydown_delete__' : 1;
process.env.NODE_ENV !== "production" ? '__selected_item_keydown_backspace__' : 2;
process.env.NODE_ENV !== "production" ? '__selected_item_keydown_navigation_next__' : 3;
process.env.NODE_ENV !== "production" ? '__selected_item_keydown_navigation_previous__' : 4;
process.env.NODE_ENV !== "production" ? '__dropdown_keydown_navigation_previous__' : 5;
process.env.NODE_ENV !== "production" ? '__dropdown_keydown_backspace__' : 6;
process.env.NODE_ENV !== "production" ? '__dropdown_click__' : 7;
process.env.NODE_ENV !== "production" ? '__function_add_selected_item__' : 8;
process.env.NODE_ENV !== "production" ? '__function_remove_selected_item__' : 9;
process.env.NODE_ENV !== "production" ? '__function_set_selected_items__' : 10;
process.env.NODE_ENV !== "production" ? '__function_set_active_index__' : 11;
process.env.NODE_ENV !== "production" ? '__function_reset__' : 12;

var bn = {exports: {}};

(function (module) {
	(function (module, exports) {

	  // Utils
	  function assert(val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN(number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }
	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;
	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }
	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }
	  BN.BN = BN;
	  BN.wordSize = 26;
	  var Buffer;
	  try {
	    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
	      Buffer = window.Buffer;
	    } else {
	      Buffer = require('buffer').Buffer;
	    }
	  } catch (e) {}
	  BN.isBN = function isBN(num) {
	    if (num instanceof BN) {
	      return true;
	    }
	    return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };
	  BN.max = function max(left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };
	  BN.min = function min(left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };
	  BN.prototype._init = function init(number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }
	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }
	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);
	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	      this.negative = 1;
	    }
	    if (start < number.length) {
	      if (base === 16) {
	        this._parseHex(number, start, endian);
	      } else {
	        this._parseBase(number, base, start);
	        if (endian === 'le') {
	          this._initArray(this.toArray(), base, endian);
	        }
	      }
	    }
	  };
	  BN.prototype._initNumber = function _initNumber(number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [number & 0x3ffffff];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
	      this.length = 3;
	    }
	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };
	  BN.prototype._initArray = function _initArray(number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [0];
	      this.length = 1;
	      return this;
	    }
	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }
	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
	        this.words[j] |= w << off & 0x3ffffff;
	        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
	        this.words[j] |= w << off & 0x3ffffff;
	        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this.strip();
	  };
	  function parseHex4Bits(string, index) {
	    var c = string.charCodeAt(index);
	    // 'A' - 'F'
	    if (c >= 65 && c <= 70) {
	      return c - 55;
	      // 'a' - 'f'
	    } else if (c >= 97 && c <= 102) {
	      return c - 87;
	      // '0' - '9'
	    } else {
	      return c - 48 & 0xf;
	    }
	  }
	  function parseHexByte(string, lowerBound, index) {
	    var r = parseHex4Bits(string, index);
	    if (index - 1 >= lowerBound) {
	      r |= parseHex4Bits(string, index - 1) << 4;
	    }
	    return r;
	  }
	  BN.prototype._parseHex = function _parseHex(number, start, endian) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    // 24-bits chunks
	    var off = 0;
	    var j = 0;
	    var w;
	    if (endian === 'be') {
	      for (i = number.length - 1; i >= start; i -= 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    } else {
	      var parseLength = number.length - start;
	      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    }
	    this.strip();
	  };
	  function parseBase(str, start, end, mul) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;
	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        r += c - 49 + 0xa;

	        // 'A'
	      } else if (c >= 17) {
	        r += c - 17 + 0xa;

	        // '0' - '9'
	      } else {
	        r += c;
	      }
	    }
	    return r;
	  }
	  BN.prototype._parseBase = function _parseBase(number, base, start) {
	    // Initialize as zero
	    this.words = [0];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = limbPow / base | 0;
	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;
	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);
	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }
	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);
	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }
	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }
	    this.strip();
	  };
	  BN.prototype.copy = function copy(dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };
	  BN.prototype.clone = function clone() {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };
	  BN.prototype._expand = function _expand(size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype.strip = function strip() {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };
	  BN.prototype._normSign = function _normSign() {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };
	  BN.prototype.inspect = function inspect() {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  };

	  /*
	   var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];
	   var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }
	   */

	  var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
	  var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
	  var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
	  BN.prototype.toString = function toString(base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;
	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = ((w << off | carry) & 0xffffff).toString(16);
	        carry = w >>> 24 - off & 0xffffff;
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }
	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modn(groupBase).toString(base);
	        c = c.idivn(groupBase);
	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }
	    assert(false, 'Base should be between 2 and 36');
	  };
	  BN.prototype.toNumber = function toNumber() {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + this.words[1] * 0x4000000;
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return this.negative !== 0 ? -ret : ret;
	  };
	  BN.prototype.toJSON = function toJSON() {
	    return this.toString(16);
	  };
	  BN.prototype.toBuffer = function toBuffer(endian, length) {
	    assert(typeof Buffer !== 'undefined');
	    return this.toArrayLike(Buffer, endian, length);
	  };
	  BN.prototype.toArray = function toArray(endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };
	  BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');
	    this.strip();
	    var littleEndian = endian === 'le';
	    var res = new ArrayType(reqLength);
	    var b, i;
	    var q = this.clone();
	    if (!littleEndian) {
	      // Assume big-endian
	      for (i = 0; i < reqLength - byteLength; i++) {
	        res[i] = 0;
	      }
	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);
	        res[reqLength - i - 1] = b;
	      }
	    } else {
	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);
	        res[i] = b;
	      }
	      for (; i < reqLength; i++) {
	        res[i] = 0;
	      }
	    }
	    return res;
	  };
	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits(w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits(w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }
	  BN.prototype._zeroBits = function _zeroBits(w) {
	    // Short-cut
	    if (w === 0) return 26;
	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength() {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };
	  function toBitArray(num) {
	    var w = new Array(num.bitLength());
	    for (var bit = 0; bit < w.length; bit++) {
	      var off = bit / 26 | 0;
	      var wbit = bit % 26;
	      w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
	    }
	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits() {
	    if (this.isZero()) return 0;
	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };
	  BN.prototype.byteLength = function byteLength() {
	    return Math.ceil(this.bitLength() / 8);
	  };
	  BN.prototype.toTwos = function toTwos(width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };
	  BN.prototype.fromTwos = function fromTwos(width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };
	  BN.prototype.isNeg = function isNeg() {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg() {
	    return this.clone().ineg();
	  };
	  BN.prototype.ineg = function ineg() {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }
	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor(num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }
	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }
	    return this.strip();
	  };
	  BN.prototype.ior = function ior(num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or(num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };
	  BN.prototype.uor = function uor(num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand(num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }
	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }
	    this.length = b.length;
	    return this.strip();
	  };
	  BN.prototype.iand = function iand(num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and(num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };
	  BN.prototype.uand = function uand(num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor(num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }
	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }
	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }
	    this.length = a.length;
	    return this.strip();
	  };
	  BN.prototype.ixor = function ixor(num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor(num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };
	  BN.prototype.uxor = function uxor(num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn(width) {
	    assert(typeof width === 'number' && width >= 0);
	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);
	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
	    }

	    // And remove leading zeroes
	    return this.strip();
	  };
	  BN.prototype.notn = function notn(width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn(bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var off = bit / 26 | 0;
	    var wbit = bit % 26;
	    this._expand(off + 1);
	    if (val) {
	      this.words[off] = this.words[off] | 1 << wbit;
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }
	    return this.strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd(num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	      // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }
	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	      // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }
	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add(num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }
	    if (this.length > num.length) return this.clone().iadd(num);
	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub(num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	      // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }
	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }
	    this.length = Math.max(this.length, i);
	    if (a !== this) {
	      this.negative = 1;
	    }
	    return this.strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub(num) {
	    return this.clone().isub(num);
	  };
	  function smallMulTo(self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = self.length + num.length | 0;
	    out.length = len;
	    len = len - 1 | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;
	    var lo = r & 0x3ffffff;
	    var carry = r / 0x4000000 | 0;
	    out.words[0] = lo;
	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += r / 0x4000000 | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }
	    return out.strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo(self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;
	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = mid + Math.imul(ah0, bl0) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = mid + Math.imul(ah1, bl0) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = lo + Math.imul(al0, bl1) | 0;
	    mid = mid + Math.imul(al0, bh1) | 0;
	    mid = mid + Math.imul(ah0, bl1) | 0;
	    hi = hi + Math.imul(ah0, bh1) | 0;
	    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = mid + Math.imul(ah2, bl0) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = lo + Math.imul(al1, bl1) | 0;
	    mid = mid + Math.imul(al1, bh1) | 0;
	    mid = mid + Math.imul(ah1, bl1) | 0;
	    hi = hi + Math.imul(ah1, bh1) | 0;
	    lo = lo + Math.imul(al0, bl2) | 0;
	    mid = mid + Math.imul(al0, bh2) | 0;
	    mid = mid + Math.imul(ah0, bl2) | 0;
	    hi = hi + Math.imul(ah0, bh2) | 0;
	    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = mid + Math.imul(ah3, bl0) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = lo + Math.imul(al2, bl1) | 0;
	    mid = mid + Math.imul(al2, bh1) | 0;
	    mid = mid + Math.imul(ah2, bl1) | 0;
	    hi = hi + Math.imul(ah2, bh1) | 0;
	    lo = lo + Math.imul(al1, bl2) | 0;
	    mid = mid + Math.imul(al1, bh2) | 0;
	    mid = mid + Math.imul(ah1, bl2) | 0;
	    hi = hi + Math.imul(ah1, bh2) | 0;
	    lo = lo + Math.imul(al0, bl3) | 0;
	    mid = mid + Math.imul(al0, bh3) | 0;
	    mid = mid + Math.imul(ah0, bl3) | 0;
	    hi = hi + Math.imul(ah0, bh3) | 0;
	    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = mid + Math.imul(ah4, bl0) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = lo + Math.imul(al3, bl1) | 0;
	    mid = mid + Math.imul(al3, bh1) | 0;
	    mid = mid + Math.imul(ah3, bl1) | 0;
	    hi = hi + Math.imul(ah3, bh1) | 0;
	    lo = lo + Math.imul(al2, bl2) | 0;
	    mid = mid + Math.imul(al2, bh2) | 0;
	    mid = mid + Math.imul(ah2, bl2) | 0;
	    hi = hi + Math.imul(ah2, bh2) | 0;
	    lo = lo + Math.imul(al1, bl3) | 0;
	    mid = mid + Math.imul(al1, bh3) | 0;
	    mid = mid + Math.imul(ah1, bl3) | 0;
	    hi = hi + Math.imul(ah1, bh3) | 0;
	    lo = lo + Math.imul(al0, bl4) | 0;
	    mid = mid + Math.imul(al0, bh4) | 0;
	    mid = mid + Math.imul(ah0, bl4) | 0;
	    hi = hi + Math.imul(ah0, bh4) | 0;
	    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = mid + Math.imul(ah5, bl0) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = lo + Math.imul(al4, bl1) | 0;
	    mid = mid + Math.imul(al4, bh1) | 0;
	    mid = mid + Math.imul(ah4, bl1) | 0;
	    hi = hi + Math.imul(ah4, bh1) | 0;
	    lo = lo + Math.imul(al3, bl2) | 0;
	    mid = mid + Math.imul(al3, bh2) | 0;
	    mid = mid + Math.imul(ah3, bl2) | 0;
	    hi = hi + Math.imul(ah3, bh2) | 0;
	    lo = lo + Math.imul(al2, bl3) | 0;
	    mid = mid + Math.imul(al2, bh3) | 0;
	    mid = mid + Math.imul(ah2, bl3) | 0;
	    hi = hi + Math.imul(ah2, bh3) | 0;
	    lo = lo + Math.imul(al1, bl4) | 0;
	    mid = mid + Math.imul(al1, bh4) | 0;
	    mid = mid + Math.imul(ah1, bl4) | 0;
	    hi = hi + Math.imul(ah1, bh4) | 0;
	    lo = lo + Math.imul(al0, bl5) | 0;
	    mid = mid + Math.imul(al0, bh5) | 0;
	    mid = mid + Math.imul(ah0, bl5) | 0;
	    hi = hi + Math.imul(ah0, bh5) | 0;
	    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = mid + Math.imul(ah6, bl0) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = lo + Math.imul(al5, bl1) | 0;
	    mid = mid + Math.imul(al5, bh1) | 0;
	    mid = mid + Math.imul(ah5, bl1) | 0;
	    hi = hi + Math.imul(ah5, bh1) | 0;
	    lo = lo + Math.imul(al4, bl2) | 0;
	    mid = mid + Math.imul(al4, bh2) | 0;
	    mid = mid + Math.imul(ah4, bl2) | 0;
	    hi = hi + Math.imul(ah4, bh2) | 0;
	    lo = lo + Math.imul(al3, bl3) | 0;
	    mid = mid + Math.imul(al3, bh3) | 0;
	    mid = mid + Math.imul(ah3, bl3) | 0;
	    hi = hi + Math.imul(ah3, bh3) | 0;
	    lo = lo + Math.imul(al2, bl4) | 0;
	    mid = mid + Math.imul(al2, bh4) | 0;
	    mid = mid + Math.imul(ah2, bl4) | 0;
	    hi = hi + Math.imul(ah2, bh4) | 0;
	    lo = lo + Math.imul(al1, bl5) | 0;
	    mid = mid + Math.imul(al1, bh5) | 0;
	    mid = mid + Math.imul(ah1, bl5) | 0;
	    hi = hi + Math.imul(ah1, bh5) | 0;
	    lo = lo + Math.imul(al0, bl6) | 0;
	    mid = mid + Math.imul(al0, bh6) | 0;
	    mid = mid + Math.imul(ah0, bl6) | 0;
	    hi = hi + Math.imul(ah0, bh6) | 0;
	    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = mid + Math.imul(ah7, bl0) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = lo + Math.imul(al6, bl1) | 0;
	    mid = mid + Math.imul(al6, bh1) | 0;
	    mid = mid + Math.imul(ah6, bl1) | 0;
	    hi = hi + Math.imul(ah6, bh1) | 0;
	    lo = lo + Math.imul(al5, bl2) | 0;
	    mid = mid + Math.imul(al5, bh2) | 0;
	    mid = mid + Math.imul(ah5, bl2) | 0;
	    hi = hi + Math.imul(ah5, bh2) | 0;
	    lo = lo + Math.imul(al4, bl3) | 0;
	    mid = mid + Math.imul(al4, bh3) | 0;
	    mid = mid + Math.imul(ah4, bl3) | 0;
	    hi = hi + Math.imul(ah4, bh3) | 0;
	    lo = lo + Math.imul(al3, bl4) | 0;
	    mid = mid + Math.imul(al3, bh4) | 0;
	    mid = mid + Math.imul(ah3, bl4) | 0;
	    hi = hi + Math.imul(ah3, bh4) | 0;
	    lo = lo + Math.imul(al2, bl5) | 0;
	    mid = mid + Math.imul(al2, bh5) | 0;
	    mid = mid + Math.imul(ah2, bl5) | 0;
	    hi = hi + Math.imul(ah2, bh5) | 0;
	    lo = lo + Math.imul(al1, bl6) | 0;
	    mid = mid + Math.imul(al1, bh6) | 0;
	    mid = mid + Math.imul(ah1, bl6) | 0;
	    hi = hi + Math.imul(ah1, bh6) | 0;
	    lo = lo + Math.imul(al0, bl7) | 0;
	    mid = mid + Math.imul(al0, bh7) | 0;
	    mid = mid + Math.imul(ah0, bl7) | 0;
	    hi = hi + Math.imul(ah0, bh7) | 0;
	    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = mid + Math.imul(ah8, bl0) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = lo + Math.imul(al7, bl1) | 0;
	    mid = mid + Math.imul(al7, bh1) | 0;
	    mid = mid + Math.imul(ah7, bl1) | 0;
	    hi = hi + Math.imul(ah7, bh1) | 0;
	    lo = lo + Math.imul(al6, bl2) | 0;
	    mid = mid + Math.imul(al6, bh2) | 0;
	    mid = mid + Math.imul(ah6, bl2) | 0;
	    hi = hi + Math.imul(ah6, bh2) | 0;
	    lo = lo + Math.imul(al5, bl3) | 0;
	    mid = mid + Math.imul(al5, bh3) | 0;
	    mid = mid + Math.imul(ah5, bl3) | 0;
	    hi = hi + Math.imul(ah5, bh3) | 0;
	    lo = lo + Math.imul(al4, bl4) | 0;
	    mid = mid + Math.imul(al4, bh4) | 0;
	    mid = mid + Math.imul(ah4, bl4) | 0;
	    hi = hi + Math.imul(ah4, bh4) | 0;
	    lo = lo + Math.imul(al3, bl5) | 0;
	    mid = mid + Math.imul(al3, bh5) | 0;
	    mid = mid + Math.imul(ah3, bl5) | 0;
	    hi = hi + Math.imul(ah3, bh5) | 0;
	    lo = lo + Math.imul(al2, bl6) | 0;
	    mid = mid + Math.imul(al2, bh6) | 0;
	    mid = mid + Math.imul(ah2, bl6) | 0;
	    hi = hi + Math.imul(ah2, bh6) | 0;
	    lo = lo + Math.imul(al1, bl7) | 0;
	    mid = mid + Math.imul(al1, bh7) | 0;
	    mid = mid + Math.imul(ah1, bl7) | 0;
	    hi = hi + Math.imul(ah1, bh7) | 0;
	    lo = lo + Math.imul(al0, bl8) | 0;
	    mid = mid + Math.imul(al0, bh8) | 0;
	    mid = mid + Math.imul(ah0, bl8) | 0;
	    hi = hi + Math.imul(ah0, bh8) | 0;
	    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = mid + Math.imul(ah9, bl0) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = lo + Math.imul(al8, bl1) | 0;
	    mid = mid + Math.imul(al8, bh1) | 0;
	    mid = mid + Math.imul(ah8, bl1) | 0;
	    hi = hi + Math.imul(ah8, bh1) | 0;
	    lo = lo + Math.imul(al7, bl2) | 0;
	    mid = mid + Math.imul(al7, bh2) | 0;
	    mid = mid + Math.imul(ah7, bl2) | 0;
	    hi = hi + Math.imul(ah7, bh2) | 0;
	    lo = lo + Math.imul(al6, bl3) | 0;
	    mid = mid + Math.imul(al6, bh3) | 0;
	    mid = mid + Math.imul(ah6, bl3) | 0;
	    hi = hi + Math.imul(ah6, bh3) | 0;
	    lo = lo + Math.imul(al5, bl4) | 0;
	    mid = mid + Math.imul(al5, bh4) | 0;
	    mid = mid + Math.imul(ah5, bl4) | 0;
	    hi = hi + Math.imul(ah5, bh4) | 0;
	    lo = lo + Math.imul(al4, bl5) | 0;
	    mid = mid + Math.imul(al4, bh5) | 0;
	    mid = mid + Math.imul(ah4, bl5) | 0;
	    hi = hi + Math.imul(ah4, bh5) | 0;
	    lo = lo + Math.imul(al3, bl6) | 0;
	    mid = mid + Math.imul(al3, bh6) | 0;
	    mid = mid + Math.imul(ah3, bl6) | 0;
	    hi = hi + Math.imul(ah3, bh6) | 0;
	    lo = lo + Math.imul(al2, bl7) | 0;
	    mid = mid + Math.imul(al2, bh7) | 0;
	    mid = mid + Math.imul(ah2, bl7) | 0;
	    hi = hi + Math.imul(ah2, bh7) | 0;
	    lo = lo + Math.imul(al1, bl8) | 0;
	    mid = mid + Math.imul(al1, bh8) | 0;
	    mid = mid + Math.imul(ah1, bl8) | 0;
	    hi = hi + Math.imul(ah1, bh8) | 0;
	    lo = lo + Math.imul(al0, bl9) | 0;
	    mid = mid + Math.imul(al0, bh9) | 0;
	    mid = mid + Math.imul(ah0, bl9) | 0;
	    hi = hi + Math.imul(ah0, bh9) | 0;
	    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = mid + Math.imul(ah9, bl1) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = lo + Math.imul(al8, bl2) | 0;
	    mid = mid + Math.imul(al8, bh2) | 0;
	    mid = mid + Math.imul(ah8, bl2) | 0;
	    hi = hi + Math.imul(ah8, bh2) | 0;
	    lo = lo + Math.imul(al7, bl3) | 0;
	    mid = mid + Math.imul(al7, bh3) | 0;
	    mid = mid + Math.imul(ah7, bl3) | 0;
	    hi = hi + Math.imul(ah7, bh3) | 0;
	    lo = lo + Math.imul(al6, bl4) | 0;
	    mid = mid + Math.imul(al6, bh4) | 0;
	    mid = mid + Math.imul(ah6, bl4) | 0;
	    hi = hi + Math.imul(ah6, bh4) | 0;
	    lo = lo + Math.imul(al5, bl5) | 0;
	    mid = mid + Math.imul(al5, bh5) | 0;
	    mid = mid + Math.imul(ah5, bl5) | 0;
	    hi = hi + Math.imul(ah5, bh5) | 0;
	    lo = lo + Math.imul(al4, bl6) | 0;
	    mid = mid + Math.imul(al4, bh6) | 0;
	    mid = mid + Math.imul(ah4, bl6) | 0;
	    hi = hi + Math.imul(ah4, bh6) | 0;
	    lo = lo + Math.imul(al3, bl7) | 0;
	    mid = mid + Math.imul(al3, bh7) | 0;
	    mid = mid + Math.imul(ah3, bl7) | 0;
	    hi = hi + Math.imul(ah3, bh7) | 0;
	    lo = lo + Math.imul(al2, bl8) | 0;
	    mid = mid + Math.imul(al2, bh8) | 0;
	    mid = mid + Math.imul(ah2, bl8) | 0;
	    hi = hi + Math.imul(ah2, bh8) | 0;
	    lo = lo + Math.imul(al1, bl9) | 0;
	    mid = mid + Math.imul(al1, bh9) | 0;
	    mid = mid + Math.imul(ah1, bl9) | 0;
	    hi = hi + Math.imul(ah1, bh9) | 0;
	    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = mid + Math.imul(ah9, bl2) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = lo + Math.imul(al8, bl3) | 0;
	    mid = mid + Math.imul(al8, bh3) | 0;
	    mid = mid + Math.imul(ah8, bl3) | 0;
	    hi = hi + Math.imul(ah8, bh3) | 0;
	    lo = lo + Math.imul(al7, bl4) | 0;
	    mid = mid + Math.imul(al7, bh4) | 0;
	    mid = mid + Math.imul(ah7, bl4) | 0;
	    hi = hi + Math.imul(ah7, bh4) | 0;
	    lo = lo + Math.imul(al6, bl5) | 0;
	    mid = mid + Math.imul(al6, bh5) | 0;
	    mid = mid + Math.imul(ah6, bl5) | 0;
	    hi = hi + Math.imul(ah6, bh5) | 0;
	    lo = lo + Math.imul(al5, bl6) | 0;
	    mid = mid + Math.imul(al5, bh6) | 0;
	    mid = mid + Math.imul(ah5, bl6) | 0;
	    hi = hi + Math.imul(ah5, bh6) | 0;
	    lo = lo + Math.imul(al4, bl7) | 0;
	    mid = mid + Math.imul(al4, bh7) | 0;
	    mid = mid + Math.imul(ah4, bl7) | 0;
	    hi = hi + Math.imul(ah4, bh7) | 0;
	    lo = lo + Math.imul(al3, bl8) | 0;
	    mid = mid + Math.imul(al3, bh8) | 0;
	    mid = mid + Math.imul(ah3, bl8) | 0;
	    hi = hi + Math.imul(ah3, bh8) | 0;
	    lo = lo + Math.imul(al2, bl9) | 0;
	    mid = mid + Math.imul(al2, bh9) | 0;
	    mid = mid + Math.imul(ah2, bl9) | 0;
	    hi = hi + Math.imul(ah2, bh9) | 0;
	    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = mid + Math.imul(ah9, bl3) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = lo + Math.imul(al8, bl4) | 0;
	    mid = mid + Math.imul(al8, bh4) | 0;
	    mid = mid + Math.imul(ah8, bl4) | 0;
	    hi = hi + Math.imul(ah8, bh4) | 0;
	    lo = lo + Math.imul(al7, bl5) | 0;
	    mid = mid + Math.imul(al7, bh5) | 0;
	    mid = mid + Math.imul(ah7, bl5) | 0;
	    hi = hi + Math.imul(ah7, bh5) | 0;
	    lo = lo + Math.imul(al6, bl6) | 0;
	    mid = mid + Math.imul(al6, bh6) | 0;
	    mid = mid + Math.imul(ah6, bl6) | 0;
	    hi = hi + Math.imul(ah6, bh6) | 0;
	    lo = lo + Math.imul(al5, bl7) | 0;
	    mid = mid + Math.imul(al5, bh7) | 0;
	    mid = mid + Math.imul(ah5, bl7) | 0;
	    hi = hi + Math.imul(ah5, bh7) | 0;
	    lo = lo + Math.imul(al4, bl8) | 0;
	    mid = mid + Math.imul(al4, bh8) | 0;
	    mid = mid + Math.imul(ah4, bl8) | 0;
	    hi = hi + Math.imul(ah4, bh8) | 0;
	    lo = lo + Math.imul(al3, bl9) | 0;
	    mid = mid + Math.imul(al3, bh9) | 0;
	    mid = mid + Math.imul(ah3, bl9) | 0;
	    hi = hi + Math.imul(ah3, bh9) | 0;
	    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = mid + Math.imul(ah9, bl4) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = lo + Math.imul(al8, bl5) | 0;
	    mid = mid + Math.imul(al8, bh5) | 0;
	    mid = mid + Math.imul(ah8, bl5) | 0;
	    hi = hi + Math.imul(ah8, bh5) | 0;
	    lo = lo + Math.imul(al7, bl6) | 0;
	    mid = mid + Math.imul(al7, bh6) | 0;
	    mid = mid + Math.imul(ah7, bl6) | 0;
	    hi = hi + Math.imul(ah7, bh6) | 0;
	    lo = lo + Math.imul(al6, bl7) | 0;
	    mid = mid + Math.imul(al6, bh7) | 0;
	    mid = mid + Math.imul(ah6, bl7) | 0;
	    hi = hi + Math.imul(ah6, bh7) | 0;
	    lo = lo + Math.imul(al5, bl8) | 0;
	    mid = mid + Math.imul(al5, bh8) | 0;
	    mid = mid + Math.imul(ah5, bl8) | 0;
	    hi = hi + Math.imul(ah5, bh8) | 0;
	    lo = lo + Math.imul(al4, bl9) | 0;
	    mid = mid + Math.imul(al4, bh9) | 0;
	    mid = mid + Math.imul(ah4, bl9) | 0;
	    hi = hi + Math.imul(ah4, bh9) | 0;
	    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = mid + Math.imul(ah9, bl5) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = lo + Math.imul(al8, bl6) | 0;
	    mid = mid + Math.imul(al8, bh6) | 0;
	    mid = mid + Math.imul(ah8, bl6) | 0;
	    hi = hi + Math.imul(ah8, bh6) | 0;
	    lo = lo + Math.imul(al7, bl7) | 0;
	    mid = mid + Math.imul(al7, bh7) | 0;
	    mid = mid + Math.imul(ah7, bl7) | 0;
	    hi = hi + Math.imul(ah7, bh7) | 0;
	    lo = lo + Math.imul(al6, bl8) | 0;
	    mid = mid + Math.imul(al6, bh8) | 0;
	    mid = mid + Math.imul(ah6, bl8) | 0;
	    hi = hi + Math.imul(ah6, bh8) | 0;
	    lo = lo + Math.imul(al5, bl9) | 0;
	    mid = mid + Math.imul(al5, bh9) | 0;
	    mid = mid + Math.imul(ah5, bl9) | 0;
	    hi = hi + Math.imul(ah5, bh9) | 0;
	    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = mid + Math.imul(ah9, bl6) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = lo + Math.imul(al8, bl7) | 0;
	    mid = mid + Math.imul(al8, bh7) | 0;
	    mid = mid + Math.imul(ah8, bl7) | 0;
	    hi = hi + Math.imul(ah8, bh7) | 0;
	    lo = lo + Math.imul(al7, bl8) | 0;
	    mid = mid + Math.imul(al7, bh8) | 0;
	    mid = mid + Math.imul(ah7, bl8) | 0;
	    hi = hi + Math.imul(ah7, bh8) | 0;
	    lo = lo + Math.imul(al6, bl9) | 0;
	    mid = mid + Math.imul(al6, bh9) | 0;
	    mid = mid + Math.imul(ah6, bl9) | 0;
	    hi = hi + Math.imul(ah6, bh9) | 0;
	    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = mid + Math.imul(ah9, bl7) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = lo + Math.imul(al8, bl8) | 0;
	    mid = mid + Math.imul(al8, bh8) | 0;
	    mid = mid + Math.imul(ah8, bl8) | 0;
	    hi = hi + Math.imul(ah8, bh8) | 0;
	    lo = lo + Math.imul(al7, bl9) | 0;
	    mid = mid + Math.imul(al7, bh9) | 0;
	    mid = mid + Math.imul(ah7, bl9) | 0;
	    hi = hi + Math.imul(ah7, bh9) | 0;
	    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = mid + Math.imul(ah9, bl8) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = lo + Math.imul(al8, bl9) | 0;
	    mid = mid + Math.imul(al8, bh9) | 0;
	    mid = mid + Math.imul(ah8, bl9) | 0;
	    hi = hi + Math.imul(ah8, bh9) | 0;
	    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = mid + Math.imul(ah9, bl9) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }
	  function bigMulTo(self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;
	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;
	        var lo = r & 0x3ffffff;
	        ncarry = ncarry + (r / 0x4000000 | 0) | 0;
	        lo = lo + rword | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = ncarry + (lo >>> 26) | 0;
	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }
	    return out.strip();
	  }
	  function jumboMulTo(self, num, out) {
	    var fftm = new FFTM();
	    return fftm.mulp(self, num, out);
	  }
	  BN.prototype.mulTo = function mulTo(num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }
	    return res;
	  };

	  // Cooley-Tukey algorithm for FFT
	  // slightly revisited to rely on looping instead of recursion

	  function FFTM(x, y) {
	    this.x = x;
	    this.y = y;
	  }
	  FFTM.prototype.makeRBT = function makeRBT(N) {
	    var t = new Array(N);
	    var l = BN.prototype._countBits(N) - 1;
	    for (var i = 0; i < N; i++) {
	      t[i] = this.revBin(i, l, N);
	    }
	    return t;
	  };

	  // Returns binary-reversed representation of `x`
	  FFTM.prototype.revBin = function revBin(x, l, N) {
	    if (x === 0 || x === N - 1) return x;
	    var rb = 0;
	    for (var i = 0; i < l; i++) {
	      rb |= (x & 1) << l - i - 1;
	      x >>= 1;
	    }
	    return rb;
	  };

	  // Performs "tweedling" phase, therefore 'emulating'
	  // behaviour of the recursive algorithm
	  FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
	    for (var i = 0; i < N; i++) {
	      rtws[i] = rws[rbt[i]];
	      itws[i] = iws[rbt[i]];
	    }
	  };
	  FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
	    this.permute(rbt, rws, iws, rtws, itws, N);
	    for (var s = 1; s < N; s <<= 1) {
	      var l = s << 1;
	      var rtwdf = Math.cos(2 * Math.PI / l);
	      var itwdf = Math.sin(2 * Math.PI / l);
	      for (var p = 0; p < N; p += l) {
	        var rtwdf_ = rtwdf;
	        var itwdf_ = itwdf;
	        for (var j = 0; j < s; j++) {
	          var re = rtws[p + j];
	          var ie = itws[p + j];
	          var ro = rtws[p + j + s];
	          var io = itws[p + j + s];
	          var rx = rtwdf_ * ro - itwdf_ * io;
	          io = rtwdf_ * io + itwdf_ * ro;
	          ro = rx;
	          rtws[p + j] = re + ro;
	          itws[p + j] = ie + io;
	          rtws[p + j + s] = re - ro;
	          itws[p + j + s] = ie - io;

	          /* jshint maxdepth : false */
	          if (j !== l) {
	            rx = rtwdf * rtwdf_ - itwdf * itwdf_;
	            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
	            rtwdf_ = rx;
	          }
	        }
	      }
	    }
	  };
	  FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
	    var N = Math.max(m, n) | 1;
	    var odd = N & 1;
	    var i = 0;
	    for (N = N / 2 | 0; N; N = N >>> 1) {
	      i++;
	    }
	    return 1 << i + 1 + odd;
	  };
	  FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
	    if (N <= 1) return;
	    for (var i = 0; i < N / 2; i++) {
	      var t = rws[i];
	      rws[i] = rws[N - i - 1];
	      rws[N - i - 1] = t;
	      t = iws[i];
	      iws[i] = -iws[N - i - 1];
	      iws[N - i - 1] = -t;
	    }
	  };
	  FFTM.prototype.normalize13b = function normalize13b(ws, N) {
	    var carry = 0;
	    for (var i = 0; i < N / 2; i++) {
	      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
	      ws[i] = w & 0x3ffffff;
	      if (w < 0x4000000) {
	        carry = 0;
	      } else {
	        carry = w / 0x4000000 | 0;
	      }
	    }
	    return ws;
	  };
	  FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
	    var carry = 0;
	    for (var i = 0; i < len; i++) {
	      carry = carry + (ws[i] | 0);
	      rws[2 * i] = carry & 0x1fff;
	      carry = carry >>> 13;
	      rws[2 * i + 1] = carry & 0x1fff;
	      carry = carry >>> 13;
	    }

	    // Pad with zeroes
	    for (i = 2 * len; i < N; ++i) {
	      rws[i] = 0;
	    }
	    assert(carry === 0);
	    assert((carry & ~0x1fff) === 0);
	  };
	  FFTM.prototype.stub = function stub(N) {
	    var ph = new Array(N);
	    for (var i = 0; i < N; i++) {
	      ph[i] = 0;
	    }
	    return ph;
	  };
	  FFTM.prototype.mulp = function mulp(x, y, out) {
	    var N = 2 * this.guessLen13b(x.length, y.length);
	    var rbt = this.makeRBT(N);
	    var _ = this.stub(N);
	    var rws = new Array(N);
	    var rwst = new Array(N);
	    var iwst = new Array(N);
	    var nrws = new Array(N);
	    var nrwst = new Array(N);
	    var niwst = new Array(N);
	    var rmws = out.words;
	    rmws.length = N;
	    this.convert13b(x.words, x.length, rws, N);
	    this.convert13b(y.words, y.length, nrws, N);
	    this.transform(rws, _, rwst, iwst, N, rbt);
	    this.transform(nrws, _, nrwst, niwst, N, rbt);
	    for (var i = 0; i < N; i++) {
	      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
	      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
	      rwst[i] = rx;
	    }
	    this.conjugate(rwst, iwst, N);
	    this.transform(rwst, iwst, rmws, _, N, rbt);
	    this.conjugate(rmws, _, N);
	    this.normalize13b(rmws, N);
	    out.negative = x.negative ^ y.negative;
	    out.length = x.length + y.length;
	    return out.strip();
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul(num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf(num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul(num) {
	    return this.clone().mulTo(num, this);
	  };
	  BN.prototype.imuln = function imuln(num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += w / 0x4000000 | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };
	  BN.prototype.muln = function muln(num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr() {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr() {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow(num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }
	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;
	        res = res.mul(q);
	      }
	    }
	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln(bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
	    var i;
	    if (r !== 0) {
	      var carry = 0;
	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = (this.words[i] | 0) - newCarry << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> 26 - r;
	      }
	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }
	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }
	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }
	      this.length += s;
	    }
	    return this.strip();
	  };
	  BN.prototype.ishln = function ishln(bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn(bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - hint % 26) / 26;
	    } else {
	      h = 0;
	    }
	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
	    var maskedWords = extended;
	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }
	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }
	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = carry << 26 - r | word >>> r;
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }
	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }
	    return this.strip();
	  };
	  BN.prototype.ishrn = function ishrn(bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln(bits) {
	    return this.clone().ishln(bits);
	  };
	  BN.prototype.ushln = function ushln(bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn(bits) {
	    return this.clone().ishrn(bits);
	  };
	  BN.prototype.ushrn = function ushrn(bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn(bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];
	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn(bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    assert(this.negative === 0, 'imaskn works only with positive numbers');
	    if (this.length <= s) {
	      return this;
	    }
	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);
	    if (r !== 0) {
	      var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
	      this.words[this.length - 1] &= mask;
	    }
	    return this.strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn(bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn(num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) < num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }
	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };
	  BN.prototype._iaddn = function _iaddn(num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);
	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn(num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);
	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }
	    this.words[0] -= num;
	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }
	    return this.strip();
	  };
	  BN.prototype.addn = function addn(num) {
	    return this.clone().iaddn(num);
	  };
	  BN.prototype.subn = function subn(num) {
	    return this.clone().isubn(num);
	  };
	  BN.prototype.iabs = function iabs() {
	    this.negative = 0;
	    return this;
	  };
	  BN.prototype.abs = function abs() {
	    return this.clone().iabs();
	  };
	  BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
	    var len = num.length + shift;
	    var i;
	    this._expand(len);
	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - (right / 0x4000000 | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    if (carry === 0) return this.strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;
	    return this.strip();
	  };
	  BN.prototype._wordDiv = function _wordDiv(num, mode) {
	    var shift = this.length - num.length;
	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;
	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }
	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }
	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min(qj / bhi | 0, 0x3ffffff);
	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q.strip();
	    }
	    a.strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }
	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod(num, mode, positive) {
	    assert(!num.isZero());
	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }
	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);
	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }
	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }
	      return {
	        div: div,
	        mod: mod
	      };
	    }
	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);
	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }
	      return {
	        div: div,
	        mod: res.mod
	      };
	    }
	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);
	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }
	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }
	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modn(num.words[0]))
	        };
	      }
	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modn(num.words[0]))
	      };
	    }
	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div(num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod(num) {
	    return this.divmod(num, 'mod', false).mod;
	  };
	  BN.prototype.umod = function umod(num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound(num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;
	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };
	  BN.prototype.modn = function modn(num) {
	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;
	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }
	    return acc;
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn(num) {
	    assert(num <= 0x3ffffff);
	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = w / num | 0;
	      carry = w % num;
	    }
	    return this.strip();
	  };
	  BN.prototype.divn = function divn(num) {
	    return this.clone().idivn(num);
	  };
	  BN.prototype.egcd = function egcd(p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());
	    var x = this;
	    var y = p.clone();
	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);
	    var g = 0;
	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }
	    var yp = y.clone();
	    var xp = x.clone();
	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }
	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }
	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }
	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }
	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }
	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp(p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());
	    var a = this;
	    var b = p.clone();
	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }
	    var x1 = new BN(1);
	    var x2 = new BN(0);
	    var delta = b.clone();
	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }
	          x1.iushrn(1);
	        }
	      }
	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }
	          x2.iushrn(1);
	        }
	      }
	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }
	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }
	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }
	    return res;
	  };
	  BN.prototype.gcd = function gcd(num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();
	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }
	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }
	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }
	      a.isub(b);
	    } while (true);
	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm(num) {
	    return this.egcd(num).a.umod(num);
	  };
	  BN.prototype.isEven = function isEven() {
	    return (this.words[0] & 1) === 0;
	  };
	  BN.prototype.isOdd = function isOdd() {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln(num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn(bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };
	  BN.prototype.isZero = function isZero() {
	    return this.length === 1 && this.words[0] === 0;
	  };
	  BN.prototype.cmpn = function cmpn(num) {
	    var negative = num < 0;
	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;
	    this.strip();
	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }
	      assert(num <= 0x3ffffff, 'Number is too big');
	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp(num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;
	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp(num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;
	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;
	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };
	  BN.prototype.gtn = function gtn(num) {
	    return this.cmpn(num) === 1;
	  };
	  BN.prototype.gt = function gt(num) {
	    return this.cmp(num) === 1;
	  };
	  BN.prototype.gten = function gten(num) {
	    return this.cmpn(num) >= 0;
	  };
	  BN.prototype.gte = function gte(num) {
	    return this.cmp(num) >= 0;
	  };
	  BN.prototype.ltn = function ltn(num) {
	    return this.cmpn(num) === -1;
	  };
	  BN.prototype.lt = function lt(num) {
	    return this.cmp(num) === -1;
	  };
	  BN.prototype.lten = function lten(num) {
	    return this.cmpn(num) <= 0;
	  };
	  BN.prototype.lte = function lte(num) {
	    return this.cmp(num) <= 0;
	  };
	  BN.prototype.eqn = function eqn(num) {
	    return this.cmpn(num) === 0;
	  };
	  BN.prototype.eq = function eq(num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red(num) {
	    return new Red(num);
	  };
	  BN.prototype.toRed = function toRed(ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };
	  BN.prototype.fromRed = function fromRed() {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };
	  BN.prototype._forceRed = function _forceRed(ctx) {
	    this.red = ctx;
	    return this;
	  };
	  BN.prototype.forceRed = function forceRed(ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };
	  BN.prototype.redAdd = function redAdd(num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };
	  BN.prototype.redIAdd = function redIAdd(num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };
	  BN.prototype.redSub = function redSub(num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };
	  BN.prototype.redISub = function redISub(num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };
	  BN.prototype.redShl = function redShl(num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };
	  BN.prototype.redMul = function redMul(num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };
	  BN.prototype.redIMul = function redIMul(num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };
	  BN.prototype.redSqr = function redSqr() {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };
	  BN.prototype.redISqr = function redISqr() {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt() {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };
	  BN.prototype.redInvm = function redInvm() {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg() {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };
	  BN.prototype.redPow = function redPow(num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime(name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);
	    this.tmp = this._tmp();
	  }
	  MPrime.prototype._tmp = function _tmp() {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };
	  MPrime.prototype.ireduce = function ireduce(num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;
	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);
	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      if (r.strip !== undefined) {
	        // r is BN v4 instance
	        r.strip();
	      } else {
	        // r is BN v5 instance
	        r._strip();
	      }
	    }
	    return r;
	  };
	  MPrime.prototype.split = function split(input, out) {
	    input.iushrn(this.n, 0, out);
	  };
	  MPrime.prototype.imulK = function imulK(num) {
	    return num.imul(this.k);
	  };
	  function K256() {
	    MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);
	  K256.prototype.split = function split(input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;
	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;
	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;
	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };
	  K256.prototype.imulK = function imulK(num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + (lo / 0x4000000 | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };
	  function P224() {
	    MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);
	  function P192() {
	    MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);
	  function P25519() {
	    // 2 ^ 255 - 19
	    MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);
	  P25519.prototype.imulK = function imulK(num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;
	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime(name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];
	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;
	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red(m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }
	  Red.prototype._verify1 = function _verify1(a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };
	  Red.prototype._verify2 = function _verify2(a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red, 'red works only with red numbers');
	  };
	  Red.prototype.imod = function imod(a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
	    return a.umod(this.m)._forceRed(this);
	  };
	  Red.prototype.neg = function neg(a) {
	    if (a.isZero()) {
	      return a.clone();
	    }
	    return this.m.sub(a)._forceRed(this);
	  };
	  Red.prototype.add = function add(a, b) {
	    this._verify2(a, b);
	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };
	  Red.prototype.iadd = function iadd(a, b) {
	    this._verify2(a, b);
	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };
	  Red.prototype.sub = function sub(a, b) {
	    this._verify2(a, b);
	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };
	  Red.prototype.isub = function isub(a, b) {
	    this._verify2(a, b);
	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };
	  Red.prototype.shl = function shl(a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };
	  Red.prototype.imul = function imul(a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };
	  Red.prototype.mul = function mul(a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };
	  Red.prototype.isqr = function isqr(a) {
	    return this.imul(a, a.clone());
	  };
	  Red.prototype.sqr = function sqr(a) {
	    return this.mul(a, a);
	  };
	  Red.prototype.sqrt = function sqrt(a) {
	    if (a.isZero()) return a.clone();
	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());
	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);
	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }
	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));
	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }
	    return r;
	  };
	  Red.prototype.invm = function invm(a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };
	  Red.prototype.pow = function pow(a, num) {
	    if (num.isZero()) return new BN(1).toRed(this);
	    if (num.cmpn(1) === 0) return a.clone();
	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }
	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }
	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = word >> j & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }
	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }
	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }
	    return res;
	  };
	  Red.prototype.convertTo = function convertTo(num) {
	    var r = num.umod(this.m);
	    return r === num ? r.clone() : r;
	  };
	  Red.prototype.convertFrom = function convertFrom(num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont(num) {
	    return new Mont(num);
	  };
	  function Mont(m) {
	    Red.call(this, m);
	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - this.shift % 26;
	    }
	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);
	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);
	  Mont.prototype.convertTo = function convertTo(num) {
	    return this.imod(num.ushln(this.shift));
	  };
	  Mont.prototype.convertFrom = function convertFrom(num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };
	  Mont.prototype.imul = function imul(a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }
	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };
	  Mont.prototype.mul = function mul(a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };
	  Mont.prototype.invm = function invm(a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(module, commonjsGlobal);
} (bn));

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
  MAX_SAFE_INTEGER = 9007199254740991,
  MAX_INTEGER = 1.7976931348623157e+308,
  NAN = 0 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
  genTag = '[object GeneratorFunction]',
  symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
  nativeMax = Math.max;

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
    length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject$2(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk$1(array, size, guard) {
  if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
    size = 1;
  } else {
    size = nativeMax(toInteger(size), 0);
  }
  var length = array ? array.length : 0;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
    resIndex = 0,
    result = Array(nativeCeil(length / size));
  while (index < length) {
    result[resIndex++] = baseSlice(array, index, index += size);
  }
  return result;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$2(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$2(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject$2(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$2(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
    remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$2(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var lodash_chunk = chunk$1;

var lodash_isequal = {exports: {}};

/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

(function (module, exports) {
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	  COMPARE_UNORDERED_FLAG = 2;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	  arrayTag = '[object Array]',
	  asyncTag = '[object AsyncFunction]',
	  boolTag = '[object Boolean]',
	  dateTag = '[object Date]',
	  errorTag = '[object Error]',
	  funcTag = '[object Function]',
	  genTag = '[object GeneratorFunction]',
	  mapTag = '[object Map]',
	  numberTag = '[object Number]',
	  nullTag = '[object Null]',
	  objectTag = '[object Object]',
	  promiseTag = '[object Promise]',
	  proxyTag = '[object Proxy]',
	  regexpTag = '[object RegExp]',
	  setTag = '[object Set]',
	  stringTag = '[object String]',
	  symbolTag = '[object Symbol]',
	  undefinedTag = '[object Undefined]',
	  weakMapTag = '[object WeakMap]';
	var arrayBufferTag = '[object ArrayBuffer]',
	  dataViewTag = '[object DataView]',
	  float32Tag = '[object Float32Array]',
	  float64Tag = '[object Float64Array]',
	  int8Tag = '[object Int8Array]',
	  int16Tag = '[object Int16Array]',
	  int32Tag = '[object Int32Array]',
	  uint8Tag = '[object Uint8Array]',
	  uint8ClampedTag = '[object Uint8ClampedArray]',
	  uint16Tag = '[object Uint16Array]',
	  uint32Tag = '[object Uint32Array]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = function () {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}();

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	    length = array == null ? 0 : array.length,
	    resIndex = 0,
	    result = [];
	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	    length = values.length,
	    offset = array.length;
	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	    length = array == null ? 0 : array.length;
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	    result = Array(n);
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function (value) {
	    return func(value);
	  };
	}

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	    result = Array(map.size);
	  map.forEach(function (value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function (arg) {
	    return func(transform(arg));
	  };
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	    result = Array(set.size);
	  set.forEach(function (value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	  funcProto = Function.prototype,
	  objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = function () {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? 'Symbol(src)_1.' + uid : '';
	}();

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	  Symbol = root.Symbol,
	  Uint8Array = root.Uint8Array,
	  propertyIsEnumerable = objectProto.propertyIsEnumerable,
	  splice = arrayProto.splice,
	  symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols,
	  nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	  nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	  Map = getNative(root, 'Map'),
	  Promise = getNative(root, 'Promise'),
	  Set = getNative(root, 'Set'),
	  WeakMap = getNative(root, 'WeakMap'),
	  nativeCreate = getNative(Object, 'create');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	  mapCtorString = toSource(Map),
	  promiseCtorString = toSource(Promise),
	  setCtorString = toSource(Set),
	  weakMapCtorString = toSource(WeakMap);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	  symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	    length = entries == null ? 0 : entries.length;
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	    length = entries == null ? 0 : entries.length;
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	    index = assocIndexOf(data, key);
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	    index = assocIndexOf(data, key);
	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	    index = assocIndexOf(data, key);
	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	    length = entries == null ? 0 : entries.length;
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash(),
	    'map': new (Map || ListCache)(),
	    'string': new Hash()
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	    size = data.size;
	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	    length = values == null ? 0 : values.length;
	  this.__data__ = new MapCache();
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache();
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	    result = data['delete'](key);
	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	    isArg = !isArr && isArguments(value),
	    isBuff = !isArr && !isArg && isBuffer(value),
	    isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	    skipIndexes = isArr || isArg || isBuff || isType,
	    result = skipIndexes ? baseTimes(value.length, String) : [],
	    length = result.length;
	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
	    // Safari 9 has enumerable `arguments.length` in strict mode.
	    key == 'length' ||
	    // Node.js 0.10 has enumerable non-index properties on buffers.
	    isBuff && (key == 'offset' || key == 'parent') ||
	    // PhantomJS 2 has enumerable non-index properties on typed arrays.
	    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
	    // Skip index properties.
	    isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
	}

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	    othIsArr = isArray(other),
	    objTag = objIsArr ? arrayTag : getTag(object),
	    othTag = othIsArr ? arrayTag : getTag(other);
	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;
	  var objIsObj = objTag == objectTag,
	    othIsObj = othTag == objectTag,
	    isSameTag = objTag == othTag;
	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack());
	    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	      othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	        othUnwrapped = othIsWrapped ? other.value() : other;
	      stack || (stack = new Stack());
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack());
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	    arrLength = array.length,
	    othLength = other.length;
	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	    result = true,
	    seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	      othValue = other[index];
	    if (customizer) {
	      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function (othValue, othIndex) {
	        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	          return seen.push(othIndex);
	        }
	      })) {
	        result = false;
	        break;
	      }
	    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;
	    case arrayBufferTag:
	      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;
	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == other + '';
	    case mapTag:
	      var convert = mapToArray;
	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);
	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;
	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	    objProps = getAllKeys(object),
	    objLength = objProps.length,
	    othProps = getAllKeys(other),
	    othLength = othProps.length;
	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);
	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	      othValue = other[key];
	    if (customizer) {
	      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	      othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	    tag = value[symToStringTag];
	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function (symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
	  getTag = function (value) {
	    var result = baseGetTag(value),
	      Ctor = result == objectTag ? value.constructor : undefined,
	      ctorString = Ctor ? toSource(Ctor) : '';
	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString:
	          return dataViewTag;
	        case mapCtorString:
	          return mapTag;
	        case promiseCtorString:
	          return promiseTag;
	        case setCtorString:
	          return setTag;
	        case weakMapCtorString:
	          return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && maskSrcKey in func;
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	    proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
	  return value === proto;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return func + '';
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || value !== value && other !== other;
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function () {
	  return arguments;
	}()) ? baseIsArguments : function (value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}
	module.exports = isEqual;
} (lodash_isequal, lodash_isequal.exports));

// ++  muk
//
// See arvo/sys/hoon.hoon.

const BN$2 = bn.exports;
const ux_FF = new BN$2(0xFF);
const ux_FF00 = new BN$2(0xFF00);
const u_256 = new BN$2(256);

/**
 * Standard murmur3.
 *
 * @param  {Number}  syd
 * @param  {Number}  len
 * @param  {BN}  key
 * @return  {BN}
 */
const muk$1 = (syd, len, key) => {
  const lo = key.and(ux_FF).toNumber();
  const hi = key.and(ux_FF00).div(u_256).toNumber();
  const kee = String.fromCharCode(lo) + String.fromCharCode(hi);
  return new BN$2(murmurhash3_32_gc(kee, syd));
};

// see: https://github.com/garycourt/murmurhash-js
//
// Copyright (c) 2011 Gary Court
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

/**
 * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
 *
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 *
 * @param {string} key ASCII only
 * @param {number} seed Positive integer only
 * @return {number} 32-bit positive integer hash
 **/
const murmurhash3_32_gc = (key, seed) => {
  // eslint-disable-next-line no-unused-vars
  let remainder, bytes, h1, h1b, c1, c2, k1, i;
  remainder = key.length & 3; // key.length % 4
  bytes = key.length - remainder;
  h1 = seed;
  c1 = 0xcc9e2d51;
  c2 = 0x1b873593;
  i = 0;
  while (i < bytes) {
    k1 = key.charCodeAt(i) & 0xff | (key.charCodeAt(++i) & 0xff) << 8 | (key.charCodeAt(++i) & 0xff) << 16 | (key.charCodeAt(++i) & 0xff) << 24;
    ++i;
    k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
    k1 = k1 << 15 | k1 >>> 17;
    k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
    h1 ^= k1;
    h1 = h1 << 13 | h1 >>> 19;
    h1b = (h1 & 0xffff) * 5 + (((h1 >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;
    h1 = (h1b & 0xffff) + 0x6b64 + (((h1b >>> 16) + 0xe654 & 0xffff) << 16);
  }
  k1 = 0;
  switch (remainder) {
    case 3:
      k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
    // eslint-disable-next-line no-fallthrough
    case 2:
      k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
    // eslint-disable-next-line no-fallthrough
    case 1:
      k1 ^= key.charCodeAt(i) & 0xff;
      k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
      h1 ^= k1;
  }
  h1 ^= key.length;
  h1 ^= h1 >>> 16;
  h1 = (h1 & 0xffff) * 0x85ebca6b + (((h1 >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;
  h1 ^= h1 >>> 13;
  h1 = (h1 & 0xffff) * 0xc2b2ae35 + (((h1 >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;
  h1 ^= h1 >>> 16;
  return h1 >>> 0;
};
var muk_1 = {
  muk: muk$1
};

// ++  ob
//
// See arvo/sys/hoon.hoon.

const BN$1 = bn.exports;
const {
  muk
} = muk_1;
const ux_1_0000 = new BN$1('10000', 'hex');
const ux_ffff_ffff = new BN$1('ffffffff', 'hex');
const ux_1_0000_0000 = new BN$1('100000000', 'hex');
const ux_ffff_ffff_ffff_ffff = new BN$1('ffffffffffffffff', 'hex');
const ux_ffff_ffff_0000_0000 = new BN$1('ffffffff00000000', 'hex');
const u_65535 = new BN$1('65535');
const u_65536 = new BN$1('65536');

// a PRF for j in { 0, .., 3 }
const F = (j, arg) => {
  const raku = [0xb76d5eed, 0xee281300, 0x85bcae01, 0x4b387af7];
  return muk(raku[j], 2, arg);
};

/**
 * Conceal structure v3.
 *
 * @param {String, Number, BN} pyn
 * @return  {BN}
 */
const fein = arg => {
  const loop = pyn => {
    const lo = pyn.and(ux_ffff_ffff);
    const hi = pyn.and(ux_ffff_ffff_0000_0000);
    return pyn.gte(ux_1_0000) && pyn.lte(ux_ffff_ffff) ? ux_1_0000.add(feis(pyn.sub(ux_1_0000))) : pyn.gte(ux_1_0000_0000) && pyn.lte(ux_ffff_ffff_ffff_ffff) ? hi.or(loop(lo)) : pyn;
  };
  return loop(new BN$1(arg));
};

/**
 * Restore structure v3.
 *
 * @param  {String, Number, BN}  cry
 * @return  {BN}
 */
const fynd = arg => {
  const loop = cry => {
    const lo = cry.and(ux_ffff_ffff);
    const hi = cry.and(ux_ffff_ffff_0000_0000);
    return cry.gte(ux_1_0000) && cry.lte(ux_ffff_ffff) ? ux_1_0000.add(tail(cry.sub(ux_1_0000))) : cry.gte(ux_1_0000_0000) && cry.lte(ux_ffff_ffff_ffff_ffff) ? hi.or(loop(lo)) : cry;
  };
  return loop(new BN$1(arg));
};

/**
 * Generalised Feistel cipher.
 *
 * See: Black and Rogaway (2002), "Ciphers with arbitrary finite domains."
 *
 * Note that this has been adjusted from the reference paper in order to
 * support some legacy behaviour.
 *
 * @param  {String, Number, BN}
 * @return  {BN}
 */
const feis = arg => Fe(4, u_65535, u_65536, ux_ffff_ffff, F, new BN$1(arg));
const Fe = (r, a, b, k, f, m) => {
  const c = fe(r, a, b, f, m);
  return c.lt(k) ? c : fe(r, a, b, f, c);
};
const fe = (r, a, b, f, m) => {
  const loop = (j, ell, arr) => {
    if (j > r) {
      return r % 2 !== 0 ? a.mul(arr).add(ell) : arr.eq(a) ? a.mul(arr).add(ell) : a.mul(ell).add(arr);
    } else {
      const eff = f(j - 1, arr);
      const tmp = j % 2 !== 0 ? ell.add(eff).mod(a) : ell.add(eff).mod(b);
      return loop(j + 1, arr, tmp);
    }
  };
  const L = m.mod(a);
  const R = m.div(a);
  return loop(1, L, R);
};

/**
 * Reverse 'feis'.
 *
 * See: Black and Rogaway (2002), "Ciphers with arbitrary finite domains."
 *
 * Note that this has been adjusted from the reference paper in order to
 * support some legacy behaviour.
 *
 * @param {Number, String, BN}  arg
 * @return  {BN}
 */
const tail = arg => Fen(4, u_65535, u_65536, ux_ffff_ffff, F, new BN$1(arg));
const Fen = (r, a, b, k, f, m) => {
  const c = fen$1(r, a, b, f, m);
  return c.lt(k) ? c : fen$1(r, a, b, f, c);
};
const fen$1 = (r, a, b, f, m) => {
  const loop = (j, ell, arr) => {
    if (j < 1) {
      return a.mul(arr).add(ell);
    } else {
      const eff = f(j - 1, ell);

      // NB (jtobin):
      //
      // Slight deviation from B&R (2002) here to prevent negative values.  We
      // add 'a' or 'b' to arr as appropriate and reduce 'eff' modulo the same
      // number before performing subtraction.
      //
      const tmp = j % 2 !== 0 ? arr.add(a).sub(eff.mod(a)).mod(a) : arr.add(b).sub(eff.mod(b)).mod(b);
      return loop(j - 1, tmp, ell);
    }
  };
  const ahh = r % 2 !== 0 ? m.div(a) : m.mod(a);
  const ale = r % 2 !== 0 ? m.mod(a) : m.div(a);
  const L = ale.eq(a) ? ahh : ale;
  const R = ale.eq(a) ? ale : ahh;
  return loop(r, L, R);
};
var ob$2 = {
  F,
  fe,
  Fe,
  feis,
  fein,
  fen: fen$1,
  Fen,
  tail,
  fynd
};

// ++  co
//
// See arvo/sys/hoon.hoon.

const BN = bn.exports;
const chunk = lodash_chunk;
const isEqual = lodash_isequal.exports;
const ob$1 = ob$2;
const zero = new BN(0);
const one = new BN(1);
const two = new BN(2);
const three = new BN(3);
const four = new BN(4);
const five = new BN(5);
const pre = `
dozmarbinwansamlitsighidfidlissogdirwacsabwissib\
rigsoldopmodfoglidhopdardorlorhodfolrintogsilmir\
holpaslacrovlivdalsatlibtabhanticpidtorbolfosdot\
losdilforpilramtirwintadbicdifrocwidbisdasmidlop\
rilnardapmolsanlocnovsitnidtipsicropwitnatpanmin\
ritpodmottamtolsavposnapnopsomfinfonbanmorworsip\
ronnorbotwicsocwatdolmagpicdavbidbaltimtasmallig\
sivtagpadsaldivdactansidfabtarmonranniswolmispal\
lasdismaprabtobrollatlonnodnavfignomnibpagsopral\
bilhaddocridmocpacravripfaltodtiltinhapmicfanpat\
taclabmogsimsonpinlomrictapfirhasbosbatpochactid\
havsaplindibhosdabbitbarracparloddosbortochilmac\
tomdigfilfasmithobharmighinradmashalraglagfadtop\
mophabnilnosmilfopfamdatnoldinhatnacrisfotribhoc\
nimlarfitwalrapsarnalmoslandondanladdovrivbacpol\
laptalpitnambonrostonfodponsovnocsorlavmatmipfip\
`;
const suf = `
zodnecbudwessevpersutletfulpensytdurwepserwylsun\
rypsyxdyrnuphebpeglupdepdysputlughecryttyvsydnex\
lunmeplutseppesdelsulpedtemledtulmetwenbynhexfeb\
pyldulhetmevruttylwydtepbesdexsefwycburderneppur\
rysrebdennutsubpetrulsynregtydsupsemwynrecmegnet\
secmulnymtevwebsummutnyxrextebfushepbenmuswyxsym\
selrucdecwexsyrwetdylmynmesdetbetbeltuxtugmyrpel\
syptermebsetdutdegtexsurfeltudnuxruxrenwytnubmed\
lytdusnebrumtynseglyxpunresredfunrevrefmectedrus\
bexlebduxrynnumpyxrygryxfeptyrtustyclegnemfermer\
tenlusnussyltecmexpubrymtucfyllepdebbermughuttun\
bylsudpemdevlurdefbusbeprunmelpexdytbyttyplevmyl\
wedducfurfexnulluclennerlexrupnedlecrydlydfenwel\
nydhusrelrudneshesfetdesretdunlernyrsebhulryllud\
remlysfynwerrycsugnysnyllyndyndemluxfedsedbecmun\
lyrtesmudnytbyrsenwegfyrmurtelreptegpecnelnevfes\
`;
const patp2syls = name => name.replace(/[\^~-]/g, '').match(/.{1,3}/g) || [];
const splitAt = (index, str) => [str.slice(0, index), str.slice(index)];
const prefixes = pre.match(/.{1,3}/g);
const suffixes = suf.match(/.{1,3}/g);
const bex$1 = n => two.pow(n);
const rsh = (a, b, c) => c.div(bex$1(bex$1(a).mul(b)));
const met$1 = (a, b, c = zero) => b.eq(zero) ? c : met$1(a, rsh(a, one, b), c.add(one));
const end = (a, b, c) => c.mod(bex$1(bex$1(a).mul(b)));

/**
 * Convert a hex-encoded string to a @p-encoded string.
 *
 * @param  {String}  hex
 * @return  {String}
 */
const hex2patp = hex => {
  if (hex === null) {
    throw new Error('hex2patp: null input');
  }
  return patp(new BN(hex, 'hex'));
};

/**
 * Convert a @p-encoded string to a hex-encoded string.
 *
 * @param  {String}  name @p
 * @return  {String}
 */
const patp2hex = name => {
  if (isValidPat(name) === false) {
    throw new Error('patp2hex: not a valid @p');
  }
  const syls = patp2syls(name);
  const syl2bin = idx => idx.toString(2).padStart(8, '0');
  const addr = syls.reduce((acc, syl, idx) => idx % 2 !== 0 || syls.length === 1 ? acc + syl2bin(suffixes.indexOf(syl)) : acc + syl2bin(prefixes.indexOf(syl)), '');
  const bn = new BN(addr, 2);
  const hex = ob$1.fynd(bn).toString('hex');
  return hex.length % 2 !== 0 ? hex.padStart(hex.length + 1, '0') : hex;
};

/**
 * Convert a @p-encoded string to a bignum.
 *
 * @param  {String}  name @p
 * @return  {BN}
 */
const patp2bn = name => new BN(patp2hex(name), 'hex');

/**
 * Convert a @p-encoded string to a decimal-encoded string.
 *
 * @param  {String}  name @p
 * @return  {String}
 */
const patp2dec = name => {
  let bn;
  try {
    bn = patp2bn(name);
  } catch (_) {
    throw new Error('patp2dec: not a valid @p');
  }
  return bn.toString();
};

/**
 * Convert a number to a @q-encoded string.
 *
 * @param  {String, Number, BN}  arg
 * @return  {String}
 */
const patq = arg => {
  const bn = new BN(arg);
  const buf = bn.toArrayLike(Buffer);
  return buf2patq(buf);
};

/**
 * Convert a Buffer into a @q-encoded string.
 *
 * @param  {Buffer}  buf
 * @return  {String}
 */
const buf2patq = buf => {
  const chunked = buf.length % 2 !== 0 && buf.length > 1 ? [[buf[0]]].concat(chunk(buf.slice(1), 2)) : chunk(buf, 2);
  const prefixName = byts => byts[1] === undefined ? prefixes[0] + suffixes[byts[0]] : prefixes[byts[0]] + suffixes[byts[1]];
  const name = byts => byts[1] === undefined ? suffixes[byts[0]] : prefixes[byts[0]] + suffixes[byts[1]];
  const alg = pair => pair.length % 2 !== 0 && chunked.length > 1 ? prefixName(pair) : name(pair);
  return chunked.reduce((acc, elem) => acc + (acc === '~' ? '' : '-') + alg(elem), '~');
};

/**
 * Convert a hex-encoded string to a @q-encoded string.
 *
 * Note that this preserves leading zero bytes.
 *
 * @param  {String}  hex
 * @return  {String}
 */
const hex2patq = arg => {
  const hex = arg.length % 2 !== 0 ? arg.padStart(arg.length + 1, '0') : arg;
  const buf = Buffer.from(hex, 'hex');
  return buf2patq(buf);
};

/**
 * Convert a @q-encoded string to a hex-encoded string.
 *
 * Note that this preserves leading zero bytes.
 *
 * @param  {String}  name @q
 * @return  {String}
 */
const patq2hex = name => {
  if (isValidPat(name) === false) {
    throw new Error('patq2hex: not a valid @q');
  }
  const chunks = name.slice(1).split('-');
  const dec2hex = dec => dec.toString(16).padStart(2, '0');
  const splat = chunks.map(chunk => {
    let syls = splitAt(3, chunk);
    return syls[1] === '' ? dec2hex(suffixes.indexOf(syls[0])) : dec2hex(prefixes.indexOf(syls[0])) + dec2hex(suffixes.indexOf(syls[1]));
  });
  return name.length === 0 ? '00' : splat.join('');
};

/**
 * Convert a @q-encoded string to a bignum.
 *
 * @param  {String}  name @q
 * @return  {BN}
 */
const patq2bn = name => new BN(patq2hex(name), 'hex');

/**
 * Convert a @q-encoded string to a decimal-encoded string.
 *
 * @param  {String}  name @q
 * @return  {String}
 */
const patq2dec = name => {
  let bn;
  try {
    bn = patq2bn(name);
  } catch (_) {
    throw new Error('patq2dec: not a valid @q');
  }
  return bn.toString();
};

/**
 * Determine the ship class of a @p value.
 *
 * @param  {String}  @p
 * @return  {String}
 */
const clan = who => {
  let name;
  try {
    name = patp2bn(who);
  } catch (_) {
    throw new Error('clan: not a valid @p');
  }
  const wid = met$1(three, name);
  return wid.lte(one) ? 'galaxy' : wid.eq(two) ? 'star' : wid.lte(four) ? 'planet' : wid.lte(new BN(8)) ? 'moon' : 'comet';
};

/**
 * Determine the parent of a @p value.
 *
 * @param  {String}  @p
 * @return  {String}
 */
const sein = name => {
  let who;
  try {
    who = patp2bn(name);
  } catch (_) {
    throw new Error('sein: not a valid @p');
  }
  let mir;
  try {
    mir = clan(name);
  } catch (_) {
    throw new Error('sein: not a valid @p');
  }
  const res = mir === 'galaxy' ? who : mir === 'star' ? end(three, one, who) : mir === 'planet' ? end(four, one, who) : mir === 'moon' ? end(five, one, who) : zero;
  return patp(res);
};

/**
 * Weakly check if a string is a valid @p or @q value.
 *
 * This is, at present, a pretty weak sanity check.  It doesn't confirm the
 * structure precisely (e.g. dashes), and for @q, it's required that q values
 * of (greater than one) odd bytelength have been zero-padded.  So, for
 * example, '~doznec-binwod' will be considered a valid @q, but '~nec-binwod'
 * will not.
 *
 * @param  {String}  name a @p or @q value
 * @return  {String}
 */
const isValidPat = name => {
  if (typeof name !== 'string') {
    throw new Error('isValidPat: non-string input');
  }
  const leadingTilde = name.slice(0, 1) === '~';
  if (leadingTilde === false || name.length < 4) {
    return false;
  } else {
    const syls = patp2syls(name);
    const wrongLength = syls.length % 2 !== 0 && syls.length !== 1;
    const sylsExist = syls.reduce((acc, syl, index) => acc && (index % 2 !== 0 || syls.length === 1 ? suffixes.includes(syl) : prefixes.includes(syl)), true);
    return !wrongLength && sylsExist;
  }
};

/**
 * Validate a @p string.
 *
 * @param  {String}  str a string
 * @return  {String}
 */
const isValidPatp = str => isValidPat(str) && str === patp(patp2dec(str));

/**
 * Validate a @q string.
 *
 * @param  {String}  str a string
 * @return  {String}
 */
const isValidPatq = str => isValidPat(str) && eqPatq(str, patq(patq2dec(str)));

/**
 * Remove all leading zero bytes from a sliceable value.
 * @param  {String, Buffer, Array}
 * @return  {String}
 */
const removeLeadingZeroBytes = str => str.slice(0, 2) === '00' ? removeLeadingZeroBytes(str.slice(2)) : str;

/**
 * Equality comparison, modulo leading zero bytes.
 * @param  {String, Buffer, Array}
 * @param  {String, Buffer, Array}
 * @return  {Bool}
 */
const eqModLeadingZeroBytes = (s, t) => isEqual(removeLeadingZeroBytes(s), removeLeadingZeroBytes(t));

/**
 * Equality comparison on @q values.
 * @param  {String}  p a @q-encoded string
 * @param  {String}  q a @q-encoded string
 * @return  {Bool}
 */
const eqPatq = (p, q) => {
  let phex;
  try {
    phex = patq2hex(p);
  } catch (_) {
    throw new Error('eqPatq: not a valid @q');
  }
  let qhex;
  try {
    qhex = patq2hex(q);
  } catch (_) {
    throw new Error('eqPatq: not a valid @q');
  }
  return eqModLeadingZeroBytes(phex, qhex);
};

/**
 * Convert a number to a @p-encoded string.
 *
 * @param  {String, Number, BN}  arg
 * @return  {String}
 */
const patp = arg => {
  if (arg === null) {
    throw new Error('patp: null input');
  }
  const n = new BN(arg);
  const sxz = ob$1.fein(n);
  const dyy = met$1(four, sxz);
  const loop = (tsxz, timp, trep) => {
    const log = end(four, one, tsxz);
    const pre = prefixes[rsh(three, one, log)];
    const suf = suffixes[end(three, one, log)];
    const etc = timp.mod(four).eq(zero) ? timp.eq(zero) ? '' : '--' : '-';
    const res = pre + suf + etc + trep;
    return timp.eq(dyy) ? trep : loop(rsh(four, one, tsxz), timp.add(one), res);
  };
  const dyx = met$1(three, sxz);
  return '~' + (dyx.lte(one) ? suffixes[sxz] : loop(sxz, zero, ''));
};
var co$1 = {
  patp,
  patp2hex,
  hex2patp,
  patp2dec,
  sein,
  clan,
  patq,
  patq2hex,
  hex2patq,
  patq2dec,
  eqPatq,
  isValidPat,
  isValidPatp,
  isValidPatq
};

const co = co$1;
const ob = ob$2;
var src = Object.assign(co, ob);

function isUndefined$3(val) {
  return typeof val === 'undefined';
}

/**
 * Calculate a translate matrix
 * @param tx {number} Translation on axis x
 * @param [ty = 0] {number} Translation on axis y
 * @returns {Matrix} Affine Matrix
 */
function translate(tx, ty = 0) {
  return {
    a: 1,
    c: 0,
    e: tx,
    b: 0,
    d: 1,
    f: ty
  };
}

/**
 * Merge multiple matrices into one
 * @param matrices {Matrix[]} Array of affine matrix
 * @returns {Matrix} Affine Matrix
 */
function transform$1(...matrices) {
  matrices = Array.isArray(matrices[0]) ? matrices[0] : matrices;
  const multiply = (m1, m2) => {
    return {
      a: m1.a * m2.a + m1.c * m2.b,
      c: m1.a * m2.c + m1.c * m2.d,
      e: m1.a * m2.e + m1.c * m2.f + m1.e,
      b: m1.b * m2.a + m1.d * m2.b,
      d: m1.b * m2.c + m1.d * m2.d,
      f: m1.b * m2.e + m1.d * m2.f + m1.f
    };
  };
  switch (matrices.length) {
    case 0:
      throw new Error('no matrices provided');
    case 1:
      return matrices[0];
    case 2:
      return multiply(matrices[0], matrices[1]);
    default:
      const [m1, m2, ...rest] = matrices;
      const m = multiply(m1, m2);
      return transform$1(m, ...rest);
  }
}

/**
 * Calculate a scaling matrix
 * @param sx {number} Scaling on axis x
 * @param [sy = sx] {number} Scaling on axis y (default sx)
 * @returns {Matrix} Affine Matrix
 */
function scale(sx, sy = undefined) {
  if (isUndefined$3(sy)) sy = sx;
  return {
    a: sx,
    c: 0,
    e: 0,
    b: 0,
    d: sy,
    f: 0
  };
}

/**
 * Serialize an affine matrix to a string that can be used with CSS or SVG
 * @param matrix {Matrix} Affine Matrix
 * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)
 */

/**
 * Serialize an affine matrix to a string that can be used with CSS or SVG
 * @param matrix {Matrix} Affine Matrix
 * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)
 */
function toString$1(matrix) {
  return `matrix(${matrix.a},${matrix.b},${matrix.c},${matrix.d},${matrix.e},${matrix.f})`;
}

// Generated by PEG.js v0.11.0-master.30f3260, https://pegjs.org/

function peg$subclass(child, parent) {
  function C() {
    this.constructor = child;
  }
  C.prototype = parent.prototype;
  child.prototype = new C();
}
function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError";

  // istanbul ignore next
  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}
peg$subclass(peg$SyntaxError, Error);
peg$SyntaxError.buildMessage = function (expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function (expectation) {
      return "\"" + literalEscape(expectation.text) + "\"";
    },
    class: function (expectation) {
      var escapedParts = expectation.parts.map(function (part) {
        return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
      });
      return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
    },
    any: function () {
      return "any character";
    },
    end: function () {
      return "end of input";
    },
    other: function (expectation) {
      return expectation.description;
    },
    not: function (expectation) {
      return "not " + describeExpectation(expectation.expected);
    }
  };
  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }
  function literalEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return "\\x" + hex(ch);
    });
  }
  function classEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return "\\x" + hex(ch);
    });
  }
  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }
  function describeExpected(expected) {
    var descriptions = expected.map(describeExpectation);
    var i, j;
    descriptions.sort();
    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }
    switch (descriptions.length) {
      case 1:
        return descriptions[0];
      case 2:
        return descriptions[0] + " or " + descriptions[1];
      default:
        return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
    }
  }
  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }
  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */
var NODE_ENV = process.env.NODE_ENV;
var invariant = function (condition, format, a, b, c, d, e, f) {
  if (NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }
  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }
    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};
var invariant_1 = invariant;

var renameKeys = {exports: {}};

(function (module) {
	(function () {

	  function rename(obj, fn) {
	    if (typeof fn !== 'function') {
	      return obj;
	    }
	    var res = {};
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        res[fn(key, obj[key]) || key] = obj[key];
	      }
	    }
	    return res;
	  }
	  if (module.exports) {
	    module.exports = rename;
	  } else {
	    {
	      window.rename = rename;
	    }
	  }
	})();
} (renameKeys));

var eventemitter3 = {exports: {}};

(function (module) {

	var has = Object.prototype.hasOwnProperty,
	  prefix = '~';

	/**
	 * Constructor to create a storage for our `EE` objects.
	 * An `Events` instance is a plain object whose properties are event names.
	 *
	 * @constructor
	 * @api private
	 */
	function Events() {}

	//
	// We try to not inherit from `Object.prototype`. In some engines creating an
	// instance in this way is faster than calling `Object.create(null)` directly.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// character to make sure that the built-in object properties are not
	// overridden or used as an attack vector.
	//
	if (Object.create) {
	  Events.prototype = Object.create(null);

	  //
	  // This hack is needed because the `__proto__` property is still inherited in
	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
	  //
	  if (!new Events().__proto__) prefix = false;
	}

	/**
	 * Representation of a single event listener.
	 *
	 * @param {Function} fn The listener function.
	 * @param {Mixed} context The context to invoke the listener with.
	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
	 * @constructor
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Minimal `EventEmitter` interface that is molded against the Node.js
	 * `EventEmitter` interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() {
	  this._events = new Events();
	  this._eventsCount = 0;
	}

	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @api public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var names = [],
	    events,
	    name;
	  if (this._eventsCount === 0) return names;
	  for (name in events = this._events) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }
	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }
	  return names;
	};

	/**
	 * Return the listeners registered for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Boolean} exists Only check if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event,
	    available = this._events[evt];
	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];
	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }
	  return ee;
	};

	/**
	 * Calls each of the listeners registered for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @returns {Boolean} `true` if the event had listeners, else `false`.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;
	  if (!this._events[evt]) return false;
	  var listeners = this._events[evt],
	    len = arguments.length,
	    args,
	    i;
	  if (listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
	    switch (len) {
	      case 1:
	        return listeners.fn.call(listeners.context), true;
	      case 2:
	        return listeners.fn.call(listeners.context, a1), true;
	      case 3:
	        return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4:
	        return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5:
	        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6:
	        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }
	    for (i = 1, args = new Array(len - 1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }
	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length,
	      j;
	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
	      switch (len) {
	        case 1:
	          listeners[i].fn.call(listeners[i].context);
	          break;
	        case 2:
	          listeners[i].fn.call(listeners[i].context, a1);
	          break;
	        case 3:
	          listeners[i].fn.call(listeners[i].context, a1, a2);
	          break;
	        case 4:
	          listeners[i].fn.call(listeners[i].context, a1, a2, a3);
	          break;
	        default:
	          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }
	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }
	  return true;
	};

	/**
	 * Add a listener for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {Mixed} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this),
	    evt = prefix ? prefix + event : event;
	  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
	  return this;
	};

	/**
	 * Add a one-time listener for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {Mixed} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true),
	    evt = prefix ? prefix + event : event;
	  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
	  return this;
	};

	/**
	 * Remove the listeners of a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn Only remove the listeners that match this function.
	 * @param {Mixed} context Only remove the listeners that have this context.
	 * @param {Boolean} once Only remove one-time listeners.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;
	  if (!this._events[evt]) return this;
	  if (!fn) {
	    if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
	    return this;
	  }
	  var listeners = this._events[evt];
	  if (listeners.fn) {
	    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
	      if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
	    }
	  } else {
	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
	      if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
	        events.push(listeners[i]);
	      }
	    }

	    //
	    // Reset the array, or remove it completely if we have no more listeners.
	    //
	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
	  }
	  return this;
	};

	/**
	 * Remove all listeners, or those of the specified event.
	 *
	 * @param {String|Symbol} [event] The event name.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  var evt;
	  if (event) {
	    evt = prefix ? prefix + event : event;
	    if (this._events[evt]) {
	      if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
	    }
	  } else {
	    this._events = new Events();
	    this._eventsCount = 0;
	  }
	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};

	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;

	//
	// Allow `EventEmitter` to be imported as module namespace.
	//
	EventEmitter.EventEmitter = EventEmitter;

	//
	// Expose the module.
	//
	{
	  module.exports = EventEmitter;
	}
} (eventemitter3));

function _extends$4() {
  _extends$4 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
var toCamelCase = function toCamelCase(s) {
  return s.replace(/-([a-z])/g, function (g) {
    return g[1].toUpperCase();
  });
};
var attributesToProps$3 = function attributesToProps(o) {
  return Object.entries(o).reduce(function (a, _ref) {
    var _extends2;
    var k = _ref[0],
      v = _ref[1];
    if (k === 'class') k = 'className';
    return _extends$4({}, a, (_extends2 = {}, _extends2["" + toCamelCase(k)] = v, _extends2));
  }, {});
};
var reactRenderer = function reactRenderer(node, i) {
  if (i === undefined) i = '';
  return /*#__PURE__*/React$2.createElement(node.name, _extends$4({}, attributesToProps$3(node.attributes), {
    key: "" + i
  }), node.children.map(function (child, j) {
    return reactRenderer(child, i + ":" + j);
  }));
};
var deepClone = function deepClone(v) {
  return JSON.parse(JSON.stringify(v));
};
var chunkStr = function chunkStr(str, size) {
  var r = new RegExp(".{1," + size + "}", 'g');
  return str.match(r);
};
var isUndefined$2 = function isUndefined(v) {
  return typeof v === 'undefined';
};
var bac = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bal = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "32.0072",
      x2: "32.7071",
      y2: "127.3",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64.0072",
      x2: "64.7071",
      y2: "127.3",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "96.0072",
      x2: "96.7071",
      y2: "127.3",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ban = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0C128 70.6924 70.6924 128 -1.52588e-05 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bar = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bat = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0C128 35.3462 99.3462 64 64 64C28.6538 64 0 35.3462 0 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bec = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bel = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ben = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "8",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bep = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 92.6538 64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ber = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0L96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bes = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128C64 92.6538 35.3462 64 0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bet = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0036",
      y1: "15.9965",
      x2: "48.0036",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bex = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0036",
      y1: "15.9965",
      x2: "48.0036",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bic = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C74.9807 96 32 53.0193 32 -4.19629e-06",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bid = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0C32 70.6925 74.9807 128 128 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bil = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9965",
      x2: "112.004",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bin = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bis = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-8.87604e-09",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "96",
      x2: "-8.87604e-09",
      y2: "96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "32",
      x2: "-8.87604e-09",
      y2: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bit = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bol = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-4.37114e-08",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bon = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C92.6538 128 64 99.3462 64 64C64 28.6538 92.6538 4.215e-07 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bor = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 128C4.63574e-06 92.6489 14.3309 60.6449 37.5 37.4807",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128C32 101.492 42.7436 77.4939 60.1138 60.1217",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128C64 110.328 71.1626 94.3287 82.7432 82.7471",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M95.6284 128C95.6284 119.164 99.2097 111.164 105 105.374",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bos = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bot = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "32",
      y1: "2.18557e-08",
      x2: "32",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bud = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M16 64C16 90.5097 37.4903 112 64 112",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bur = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M7.37542e-06 -3.56072e-06C1.19529e-06 70.6924 57.3075 128 128 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var bus = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128C32 110.327 17.6731 96 0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var byl = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M22.1288 22.6299C16.0075 28.7511 8.0234 31.874 0.00134547 31.9986M44.7562 45.2573C32.3866 57.6269 16.2133 63.8747 0.00134277 64.0005M67.3836 67.8847C48.7656 86.5027 24.403 95.8749 0.00134412 96.0012",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var byn = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0C128 35.3511 113.669 67.3551 90.5 90.5193",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0C96 26.5077 85.2564 50.5061 67.8862 67.8783",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0C64 17.6721 56.8374 33.6713 45.2568 45.2529",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32.3716 0C32.3716 8.83603 28.7903 16.8356 23 22.6264",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var byr = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "80",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "80",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var byt = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dab = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.65 47.6499)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dac = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L-5.96046e-08 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dal = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "63.29",
      y2: "63.2929",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "32.0072",
      x2: "32.7071",
      y2: "127.3",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64.0072",
      x2: "64.7071",
      y2: "127.3",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "96.0072",
      x2: "96.7071",
      y2: "127.3",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dan = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "96",
      y1: "2.18557e-08",
      x2: "96",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dap = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9964",
      x2: "112.004",
      y2: "111.996",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dar = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M86.6274 86.6274C99.1242 74.1307 99.1242 53.8694 86.6274 41.3726C74.1306 28.8758 53.8694 28.8758 41.3726 41.3726",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M75.3137 75.3137C81.5621 69.0653 81.5621 58.9347 75.3137 52.6863C69.0653 46.4379 58.9347 46.4379 52.6863 52.6863",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M97.9411 97.9411C116.686 79.1959 116.686 48.804 97.9411 30.0589C79.196 11.3137 48.804 11.3137 30.0589 30.0589",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var das = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dat = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C92.6538 128 64 99.3462 64 64C64 28.6538 92.6538 -1.54503e-06 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dav = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 64C96 46.3269 81.6731 32 64 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var deb = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 -6.35781e-07C64 35.3462 35.3462 64 0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dec = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "112",
      cy: "16",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "112",
      cy: "16",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var def = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 128L128 0",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 94L94 0",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 64L64 0",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 32L32 0",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var deg = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128C64 92.6538 35.3462 64 0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var del = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dem = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 -6.35781e-07C64 35.3462 35.3462 64 0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var den = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.52575e-06 96C53.0193 96 96 53.0193 96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dep = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128C32 101.492 42.7436 77.4939 60.1138 60.1216",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128C64 110.328 71.1626 94.3287 82.7432 82.7471",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M95.6284 128C95.6284 119.164 99.2097 111.164 105 105.374",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var der = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 64L5.59506e-06 0L128 1.11901e-05V64C128 99.3462 99.3462 128 64 128C28.6538 128 -4.6351e-06 99.3462 0 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 128L96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var des = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0L96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var det = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9964",
      y1: "111.996",
      x2: "47.9964",
      y2: "79.9964",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dev = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "96.5",
      y1: "3.07317e-08",
      x2: "96.5",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "32.5",
      y1: "3.07317e-08",
      x2: "32.5",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dex = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dib = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "8.74228e-08",
      y1: "64",
      x2: "128",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "5.25874e-08",
      y1: "32",
      x2: "128",
      y2: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dif = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M60.1244 67.3837C41.5063 48.7657 32.1342 24.4031 32.0079 0.00145601M82.7518 44.7563C70.3822 32.3867 64.1344 16.2134 64.0086 0.00145196M105.379 22.1289C99.258 16.0077 96.1351 8.02351 96.0105 0.00145196",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "16",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "16",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dig = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64.5",
      y1: "-0.5",
      x2: "64.5",
      y2: "127.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0035",
      y1: "15.9965",
      x2: "48.0035",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dil = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0036",
      y1: "79.9964",
      x2: "112.004",
      y2: "111.996",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var din = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "96",
      y1: "2.18557e-08",
      x2: "96",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dir = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 64C96 81.6731 81.6731 96 64 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0035",
      y1: "15.9965",
      x2: "48.0035",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dis = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.0029152 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var div$1 = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-4.19629e-06 96C70.6924 96 128 53.0193 128 5.59506e-06",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-2.79753e-06 64C70.6924 64 128 35.3462 128 5.59506e-06",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var doc = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M127.997 0L-0.00291443 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M86.6274 41.3726C74.1306 28.8758 53.8694 28.8758 41.3726 41.3726C28.8758 53.8694 28.8758 74.1306 41.3726 86.6274",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dol = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-4.19629e-06 16C26.5097 16 48 37.4903 48 64C48 90.5097 26.5097 112 0 112",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var don = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-3.8147e-06 128C-7.24632e-07 92.6538 28.6538 64 64 64C99.3462 64 128 92.6538 128 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dop = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 112C90.5097 112 112 90.5097 112 64C112 37.4903 90.5097 16 64 16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dor = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "63.5",
      x2: "128",
      y2: "63.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dos = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M86.6274 86.6274C99.1242 74.1306 99.1242 53.8693 86.6274 41.3725C74.1306 28.8758 53.8694 28.8758 41.3726 41.3725",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dot = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dov = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.701724 31.9914C25.6281 31.9914 49.4822 42.5913 66.8261 59.7565M-0.701723 63.9914C16.7916 63.9914 32.6456 71.0098 44.1982 82.3844M-0.701722 95.9914C7.955 95.9914 15.8089 99.4288 21.5694 105.013",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 0C35.3511 0 67.3551 14.3309 90.5193 37.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var doz = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128L0 0",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M30.0589 30.0589C48.804 11.3137 79.196 11.3137 97.9411 30.0589C116.686 48.804 116.686 79.196 97.9411 97.9411",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M52.6863 52.6863C58.9347 46.4379 69.0653 46.4379 75.3137 52.6863C81.5621 58.9347 81.5621 69.0653 75.3137 75.3137",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M41.3726 41.3726C53.8694 28.8758 74.1306 28.8758 86.6274 41.3726C99.1242 53.8694 99.1242 74.1306 86.6274 86.6274",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var duc = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32L0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dul = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 16C90.5097 16 112 37.4903 112 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 64L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dun = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M112 64C112 37.4903 90.5097 16 64 16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dur = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 64L5.59506e-06 0L128 1.11901e-05V64C128 99.3462 99.3462 128 64 128C28.6538 128 -4.6351e-06 99.3462 0 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dus = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 -3.05151e-06C32 53.0193 74.9807 96 128 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dut = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dux = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-2.79795e-06 -3.55988e-06C70.6924 -4.40288e-06 128 57.3075 128 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dyl = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M2.03434e-06 128C70.6924 128 128 70.6925 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dyn = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32L0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dyr = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dys = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-3.8147e-06 1.11901e-05C-7.24633e-07 35.3462 28.6538 64 64 64C99.3462 64 128 35.3462 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var dyt = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fab = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fad = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fal = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 128L128 0",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 0C35.3511 0 67.3551 14.3309 90.5193 37.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 32C26.5077 32 50.5061 42.7436 67.8783 60.1138",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 64C17.6721 64 33.6713 71.1626 45.2529 82.7432",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 95.6284C8.83603 95.6284 16.8356 99.2097 22.6264 105",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fam = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-4.37114e-08",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fan = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fas = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var feb = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M7.37542e-06 -3.56072e-06C1.19529e-06 70.6924 57.3075 128 128 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fed = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32L0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fel = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.65 47.6499)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fen = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 128C4.63574e-06 92.6489 14.3309 60.6449 37.5 37.4807",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128C32 101.492 42.7436 77.4939 60.1138 60.1217",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128C64 110.328 71.1626 94.3287 82.7432 82.7471",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M95.6284 128C95.6284 119.164 99.2097 111.164 105 105.374",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fep = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fer = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fes = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fet = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fex = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.6499 47.6499)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fid = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00291443 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fig = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fil = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-4.37114e-08",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "32",
      y1: "2.18557e-08",
      x2: "32",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fin = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "98",
      y1: "2.18557e-08",
      x2: "98",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fip = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fir = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.65 47.6499)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0036",
      y1: "79.9965",
      x2: "112.004",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0035",
      y1: "15.9965",
      x2: "48.0035",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fit = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fod = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fog = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M86.6274 86.6274C99.1242 74.1306 99.1242 53.8694 86.6274 41.3726C74.1306 28.8758 53.8694 28.8758 41.3726 41.3726",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fol = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-4.37114e-08",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fon = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fop = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M16 64C16 90.5097 37.4903 112 64 112",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fos = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0C96 53.0193 53.0193 96 0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0C64 35.3462 35.3462 64 0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0C32 17.6731 17.6731 32 0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fot = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9964",
      y1: "111.997",
      x2: "47.9964",
      y2: "79.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ful = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 96C81.6731 96 96 81.6731 96 64C96 46.3269 81.6731 32 64 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fun = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 64V128H0L2.79753e-06 64C4.34256e-06 28.6538 28.6538 -1.54503e-06 64 0C99.3462 1.54503e-06 128 28.6538 128 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9964",
      y1: "111.997",
      x2: "47.9964",
      y2: "79.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fur = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M86.8823 41.6275C74.3855 29.1307 54.1242 29.1307 41.6274 41.6275C29.1307 54.1243 29.1307 74.3855 41.6274 86.8823",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fus = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128C32 110.327 17.6731 96 0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fyl = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M22.1288 22.6299C16.0075 28.7511 8.0234 31.874 0.00134547 31.9986M44.7562 45.2573C32.3866 57.6269 16.2133 63.8747 0.00134277 64.0005M67.3836 67.8847C48.7656 86.5027 24.403 95.8749 0.00134412 96.0012",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fyn = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var fyr = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00268555 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.6499 47.6499)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hab = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M60.1244 67.3837C41.5063 48.7657 32.1342 24.4031 32.0079 0.00145601M82.7518 44.7563C70.3822 32.3867 64.1344 16.2134 64.0086 0.00145196M105.379 22.1289C99.258 16.0077 96.1351 8.02351 96.0105 0.00145196",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hac = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var had = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hal = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64.5",
      y1: "-0.5",
      x2: "64.5",
      y2: "127.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M16 64C16 90.5097 37.4903 112 64 112",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M112 64C112 37.4903 90.5097 16 64 16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var han = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hap = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var har = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var has = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hat = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "16",
      r: "8",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M48 32C48 40.8366 40.8366 48 32 48C23.1634 48 16 40.8366 16 32C16 23.1634 23.1634 16 32 16C40.8366 16 48 23.1634 48 32ZM32 40C36.4183 40 40 36.4183 40 32C40 27.5817 36.4183 24 32 24C27.5817 24 24 27.5817 24 32C24 36.4183 27.5817 40 32 40Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hav = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "96",
      y1: "2.18557e-08",
      x2: "96",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var heb = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M2.03434e-06 128C70.6924 128 128 70.6925 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hec = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hep = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.00285417",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hes = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M48 96C48 104.837 40.8366 112 32 112C23.1634 112 16 104.837 16 96C16 87.1634 23.1634 80 32 80C40.8366 80 48 87.1634 48 96ZM32 104C36.4183 104 40 100.418 40 96C40 91.5817 36.4183 88 32 88C27.5817 88 24 91.5817 24 96C24 100.418 27.5817 104 32 104Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var het = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 128L96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hex = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hid = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M2.03434e-06 128C70.6924 128 128 70.6925 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.52575e-06 96C53.0193 96 96 53.0193 96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.01717e-06 64C35.3462 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M5.08584e-07 32C17.6731 32 32 17.6731 32 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hil = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "8.74228e-08",
      y1: "64",
      x2: "128",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hin = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "32",
      y1: "2.18557e-08",
      x2: "32",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M48 64C48 72.8366 40.8366 80 32 80C23.1634 80 16 72.8366 16 64C16 55.1634 23.1634 48 32 48C40.8366 48 48 55.1634 48 64ZM32 72C36.4183 72 40 68.4183 40 64C40 59.5817 36.4183 56 32 56C27.5817 56 24 59.5817 24 64C24 68.4183 27.5817 72 32 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hob = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 64V128H0L2.79753e-06 64C4.34256e-06 28.6538 28.6538 -1.54503e-06 64 0C99.3462 1.54503e-06 128 28.6538 128 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-4.37114e-08",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hoc = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.65 47.6499)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hod = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hol = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-4.37114e-08",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hop = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 96C81.6731 96 96 81.6731 96 64C96 46.3269 81.6731 32 64 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hos = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0036",
      y1: "79.9965",
      x2: "112.004",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0036",
      y1: "15.9965",
      x2: "48.0036",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "48",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "48",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "47",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "47",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "81",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "81",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "80",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "80",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hul = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hus = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 96C46.3269 96 32 81.6731 32 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var hut = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lab = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.65 47.6499)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9964",
      y1: "111.997",
      x2: "47.9964",
      y2: "79.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lac = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 -9.40976e-06C64 70.6924 92.6538 128 128 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 -7.63193e-07C32 70.6924 74.9807 128 128 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lad = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "95.35",
      y1: "32.7071",
      x2: "32.0571",
      y2: "96",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lag = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 112C90.5097 112 112 90.5097 112 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lan = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "32",
      y1: "2.18557e-08",
      x2: "32",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lap = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M112 64C112 37.4903 90.5097 16 64 16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "112",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "112",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lar = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "2.78181e-08",
      y1: "64",
      x2: "128",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var las = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lat = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M2.03434e-06 128C70.6924 128 128 70.6925 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.52575e-06 96C53.0193 96 96 53.0193 96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.01717e-06 64C35.3462 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M5.08584e-07 32C17.6731 32 32 17.6731 32 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lav = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C92.6489 128 60.6449 113.669 37.4807 90.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C101.492 96 77.4939 85.2564 60.1217 67.8862",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C110.328 64 94.3287 56.8374 82.7471 45.2568",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32.3716C119.164 32.3716 111.164 28.7903 105.374 23",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var leb = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-1.64036e-05 32C53.0193 32 96 74.9807 96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lec = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var led = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var leg = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M7.63192e-07 32C17.6731 32 32 46.3269 32 64C32 81.6731 17.6731 96 0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var len = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lep = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C110.327 96 96 110.327 96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ler = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lev = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lex = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9965",
      y1: "111.997",
      x2: "47.9965",
      y2: "79.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lib$3 = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 92.6538 64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lid = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0036",
      y1: "15.9965",
      x2: "48.0036",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lig = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lin = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "128",
      x2: "64",
      y2: "-6.55671e-08",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "64",
      r: "8",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lis = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-4.70488e-06 64C35.3462 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lit = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00286865 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0C128 35.3511 113.669 67.3551 90.5 90.5193",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0C96 26.5077 85.2564 50.5061 67.8862 67.8783",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0C64 17.6721 56.8374 33.6713 45.2568 45.2529",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32.3716 0C32.3716 8.83603 28.7903 16.8356 23 22.6264",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var liv = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-5.21346e-06 32C70.6924 32 128 17.6731 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M3.4331e-06 96C70.6924 96 128 53.0193 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var loc = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C74.9807 96 32 53.0193 32 -4.19629e-06",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lod = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M16 64C16 90.5097 37.4903 112 64 112",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lom = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lon = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M2.03434e-06 128C70.6924 128 128 70.6925 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.52575e-06 96C53.0193 96 96 53.0193 96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.01717e-06 64C35.3462 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M5.08584e-07 32C17.6731 32 32 17.6731 32 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lop = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-8.87604e-09",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "32",
      x2: "-8.87604e-09",
      y2: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lor = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var los = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var luc = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-8.87604e-09",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96L0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lud = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0L96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lug = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 -7.62939e-06L64 -2.03434e-06C99.3462 1.05573e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lun = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lup = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 -7.62939e-06L64 -2.03434e-06C99.3462 1.05573e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 16C90.5097 16 112 37.4903 112 64C112 90.5097 90.5097 112 64 112",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-8.87604e-09",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lur = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0L96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lus = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lut = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lux = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lyd = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lyn = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lyr = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00268555 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "48",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "48",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lys = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lyt = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9965",
      x2: "112.003",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var lyx = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mac = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mag = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mal = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9964",
      x2: "112.004",
      y2: "111.996",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var map$1 = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0036",
      y1: "79.9965",
      x2: "112.004",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mar = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.0029152 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 64L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M86.6274 86.6274C99.1242 74.1307 99.1242 53.8694 86.6274 41.3726C74.1306 28.8758 53.8694 28.8758 41.3726 41.3726",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M75.3137 75.3137C81.5621 69.0653 81.5621 58.9347 75.3137 52.6863C69.0653 46.4379 58.9347 46.4379 52.6863 52.6863",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M97.9411 97.9411C116.686 79.1959 116.686 48.804 97.9411 30.0589C79.196 11.3137 48.804 11.3137 30.0589 30.0589",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mas = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mat = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32C110.327 32 96 17.6731 96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var meb = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 -3.05151e-06C32 53.0193 74.9807 96 128 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mec = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9965",
      x2: "112.003",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var med = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var meg = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 92.6538 64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mel = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9964",
      y1: "111.997",
      x2: "47.9964",
      y2: "79.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mep = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96L0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32L0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mer = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mes = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9964",
      y1: "111.996",
      x2: "47.9964",
      y2: "79.9964",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var met = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128L32 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mev = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mex = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mic = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-2.09815e-06 80C26.5097 80 48 101.49 48 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mid = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-4.37114e-08",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 92.6538 64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mig = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0036",
      y1: "79.9965",
      x2: "112.004",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mil = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-4.37114e-08",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "32",
      x2: "-4.37114e-08",
      y2: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "96",
      x2: "-4.37114e-08",
      y2: "96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var min = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mip = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C92.6538 128 64 99.3462 64 64C64 28.6538 92.6538 4.215e-07 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mir = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0036",
      y1: "15.9964",
      x2: "48.0036",
      y2: "47.9964",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 64C96 46.3269 81.6731 32 64 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mis = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 92.6538 64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00286865 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mit = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var moc = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96L0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32L0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mod = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 96L128 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0035",
      y1: "15.9965",
      x2: "48.0035",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mog = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mol = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-4.37114e-08",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M112 64C112 90.5097 90.5097 112 64 112C37.4903 112 16 90.5097 16 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M112 0C112 26.5097 90.5097 48 64 48C37.4903 48 16 26.5097 16 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mon = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mop = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mor = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0035",
      y1: "15.9964",
      x2: "48.0035",
      y2: "47.9964",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9964",
      y1: "111.996",
      x2: "47.9964",
      y2: "79.9964",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mos = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mot = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C110.327 96 96 81.6731 96 64C96 46.3269 110.327 32 128 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mud = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "80",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "80",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mug = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 96C81.6731 96 96 81.6731 96 64C96 46.3269 81.6731 32 64 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mul = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9964",
      x2: "112.003",
      y2: "111.996",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M112 64C112 37.4903 90.5097 16 64 16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mun = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mur = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mus = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 128C96 74.9807 53.0193 32 0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var mut = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var myl = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0035",
      y1: "15.9965",
      x2: "48.0035",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "16",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "16",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var myn = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 1.52638e-06C57.3076 -7.74381e-06 9.2702e-06 57.3075 0 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32C74.9807 32 32 74.9807 32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 92.6538 64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C110.327 96 96 110.327 96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var myr = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nac = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nal = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M2.82114e-06 110C60.7513 110 110 60.7513 110 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-5.09828e-06 73C40.3168 73 73 40.3168 73 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-6.63647e-07 37C20.4345 37 37 20.4345 37 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nam = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "8.74228e-08",
      y1: "64",
      x2: "128",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "112",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "112",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nap = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nar = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "8",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nat = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-1.52588e-05 128C-9.07866e-06 57.3075 57.3076 1.44926e-06 128 7.62939e-06",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nav = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C101.492 96 77.4939 85.2564 60.1217 67.8862",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C110.328 64 94.3287 56.8374 82.7471 45.2568",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32.3716C119.164 32.3716 111.164 28.7903 105.374 23",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var neb = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32C74.9807 32 32 74.9807 32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nec = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ned = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nel = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00268555 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 1.90735e-06C96 53.0193 53.0193 96 0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nem = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 92.6538 64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nep = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C57.3076 128 3.09007e-06 70.6925 0 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C74.9807 96 32 53.0193 32 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32C110.327 32 96 17.6731 96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ner = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9965",
      y1: "111.997",
      x2: "47.9965",
      y2: "79.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nes = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var net = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 64L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nev = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nex = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 -7.62939e-06L64 -2.03434e-06C99.3462 1.05573e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9964",
      x2: "112.003",
      y2: "111.996",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nib = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96L0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nid = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C92.6538 128 64 70.6925 64 7.63192e-07",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nil = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-8.87604e-09",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "32",
      x2: "-8.87604e-09",
      y2: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nim = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 64V128H0L2.79753e-06 64C4.34256e-06 28.6538 28.6538 -1.54503e-06 64 0C99.3462 1.54503e-06 128 28.6538 128 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nis = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32C74.9807 32 32 74.9807 32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00285435 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var noc = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nod = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nol = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "1.51277e-05",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nom = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nop = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.65 47.65)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nor = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 96C46.3269 96 32 81.6731 32 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nos = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nov = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M2.03434e-06 128C70.6924 128 128 70.6925 128 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.52575e-06 96C53.0193 96 96 53.0193 96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.01717e-06 64C35.3462 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M5.08584e-07 32C17.6731 32 32 17.6731 32 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nub = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nul = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var num = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nup = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 -7.62939e-06L64 -2.03434e-06C99.3462 1.05573e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 16C90.5097 16 112 37.4903 112 64C112 90.5097 90.5097 112 64 112",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nus = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0.000105172 128C35.3582 128 67.3679 113.664 90.5332 90.4863",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "31",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "31",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nut = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9964",
      x2: "112.003",
      y2: "111.996",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.6499 47.6499)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nux = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96L0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32L0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nyd = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nyl = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 128C4.63574e-06 92.6489 14.3309 60.6449 37.5 37.4807",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128C32 101.492 42.7436 77.4939 60.1138 60.1217",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128C64 110.328 71.1626 94.3287 82.7432 82.7471",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M95.6284 128C95.6284 119.164 99.2097 111.164 105 105.374",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nym = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0L96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nyr = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00268555 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M95.9984 0C95.9984 26.3298 85.3985 50.1839 68.2332 67.5278M63.9983 0C63.9983 17.4933 56.9799 33.3473 45.6054 44.8999M31.9983 0C31.9983 8.65672 28.5609 16.5106 22.9766 22.2711",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nys = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nyt = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 32C81.6731 32 96 46.3269 96 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 16C90.5097 16 112 37.4903 112 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var nyx = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pac = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pad = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pag = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9964",
      y1: "111.997",
      x2: "47.9964",
      y2: "79.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pal = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C101.492 96 77.4939 85.2564 60.1217 67.8862",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C110.328 64 94.3287 56.8374 82.7471 45.2568",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32.3716C119.164 32.3716 111.164 28.7903 105.374 23",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pan = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M41.3726 86.6274C28.8758 74.1306 28.8758 53.8693 41.3726 41.3725C53.8694 28.8758 74.1306 28.8758 86.6274 41.3725",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var par = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.693 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pas = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0L96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pat = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 -2.67054e-06C32 53.0193 74.9807 96 128 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 -1.78036e-06C64 35.3462 92.6538 64 128 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 -8.9018e-07C96 17.6731 110.327 32 128 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pec = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ped = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var peg = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0C96 17.6731 81.6731 32 64 32C46.3269 32 32 17.6731 32 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pel = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M112 64C112 37.4903 90.5097 16 64 16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pem = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128C64 92.6538 35.3462 64 0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pen = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0C96 17.6731 81.6731 32 64 32C46.3269 32 32 17.6731 32 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var per = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 64L5.59506e-06 0L128 1.11901e-05V64C128 99.3462 99.3462 128 64 128C28.6538 128 -4.6351e-06 99.3462 0 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pes = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 112C90.5097 112 112 90.5097 112 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.00285417",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pet = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9964",
      x2: "112.003",
      y2: "111.996",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pex = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pic = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 128C96 74.9807 53.0193 32 0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128C64 92.6538 35.3462 64 0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128C32 110.327 17.6731 96 0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pid = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pil = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pin = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pit = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var poc = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64.5",
      y1: "-0.5",
      x2: "64.5",
      y2: "127.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "96.5",
      y1: "-0.5",
      x2: "96.5",
      y2: "127.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "32.5",
      y1: "-0.5",
      x2: "32.5",
      y2: "127.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pod = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "96",
      x2: "-8.87604e-09",
      y2: "96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pol = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "32",
      x2: "-8.87604e-09",
      y2: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pon = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pos = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pub = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pun = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M112 64C112 37.4903 90.5097 16 64 16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 64C96 46.3269 81.6731 32 64 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M80 64C80 55.1634 72.8366 48 64 48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pur = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M3.73284e-05 64C17.6633 64 33.6554 56.8445 45.2356 45.2741",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var put = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pyl = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-5.59506e-06 128C35.3462 128 64 99.3462 64 64C64 28.6538 35.3462 1.54503e-06 0 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var pyx = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rab = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9965",
      y1: "111.997",
      x2: "47.9964",
      y2: "79.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rac = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rad = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rag = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0036",
      y1: "15.9965",
      x2: "48.0036",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ral = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ram = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ran = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00291443 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rap = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "-1.29797e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rav = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32L0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var reb = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 -9.40976e-06C57.3075 -6.31969e-06 -3.09007e-06 57.3075 0 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rec = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var red = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ref = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var reg = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C110.327 96 96 81.6731 96 64C96 46.3269 110.327 32 128 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rel = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96L0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32L0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rem = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ren = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9965",
      x2: "112.003",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rep = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128C32 74.9807 74.9807 32 128 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var res = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9965",
      x2: "112.003",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ret = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rev = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9965",
      y1: "111.997",
      x2: "53.9965",
      y2: "73.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rex = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rib = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "8.74228e-08",
      y1: "64",
      x2: "128",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ric = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 128C96 74.9807 53.0193 32 0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rid = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0L96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rig = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ril = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.693 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rin = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "32",
      y1: "2.18557e-08",
      x2: "32",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rip = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 64C96 46.3269 81.6731 32 64 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ris = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0C128 35.3511 113.669 67.3551 90.5 90.5193",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0C96 26.5077 85.2564 50.5061 67.8862 67.8783",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0C64 17.6721 56.8374 33.6713 45.2568 45.2529",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32.3716 0C32.3716 8.83603 28.7903 16.8356 23 22.6264",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rit = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var riv = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var roc = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "112",
      cy: "16",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "112",
      cy: "16",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rol = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 16C90.5097 16 112 37.4903 112 64C112 90.5097 90.5097 112 64 112",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ron = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0C128 70.6924 70.6925 128 0 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rop = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M112 64C112 37.4903 90.5097 16 64 16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ros = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rov = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0C128 35.3511 113.669 67.3551 90.5 90.5193",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0C96 26.5077 85.2564 50.5061 67.8862 67.8783",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0C64 17.6721 56.8374 33.6713 45.2568 45.2529",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32.3716 0C32.3716 8.83603 28.7903 16.8356 23 22.6264",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ruc = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32L0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rud = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rul = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9964",
      x2: "112.003",
      y2: "111.996",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rum = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M5.08584e-07 32C17.6731 32 32 17.6731 32 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var run = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0L96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rup = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 112C90.5097 112 112 90.5097 112 64C112 37.4903 90.5097 16 64 16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rus = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128C64 92.6538 35.3462 64 0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rut = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rux = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 64C32 81.6731 46.3269 96 64 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ryc = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96L0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ryd = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 64C96 81.6731 81.6731 96 64 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ryg = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-2.79795e-06 -3.55988e-06C70.6924 -4.40288e-06 128 57.3075 128 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0035",
      y1: "15.9965",
      x2: "48.0035",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ryl = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C92.6489 128 60.6449 113.669 37.4807 90.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C101.492 96 77.4939 85.2564 60.1217 67.8862",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C110.328 64 94.3287 56.8374 82.7471 45.2568",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32.3716C119.164 32.3716 111.164 28.7903 105.374 23",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rym = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96L0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ryn = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C57.3075 128 -3.09007e-06 70.6925 0 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ryp = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var rys = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.52575e-06 96C53.0193 96 96 53.0193 96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ryt = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 -7.62939e-06L64 -2.03434e-06C99.3462 1.05573e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ryx = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sab = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.65 47.65)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sal = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 128L128 0",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.701724 31.9914C25.6281 31.9914 49.4822 42.5913 66.8261 59.7565M-0.701723 63.9914C16.7916 63.9914 32.6456 71.0098 44.1982 82.3844M-0.701722 95.9914C7.955 95.9914 15.8089 99.4288 21.5694 105.013",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sam = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var san = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sap = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-4.37114e-08",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "8",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sar = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sat = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 0 0 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sav = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 64C96 46.3269 81.6731 32 64 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var seb = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sec = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sed = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sef = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var seg = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128C32 110.327 46.3269 96 64 96C81.6731 96 96 110.327 96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sel = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "8",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sem = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.01717e-06 64C35.3462 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sen = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 128C96 110.327 81.6731 96 64 96C46.3269 96 32 110.327 32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sep = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128L64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128L32 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 128L96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ser = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 64L5.59506e-06 0L128 1.11901e-05V64C128 99.3462 99.3462 128 64 128C28.6538 128 -4.6351e-06 99.3462 0 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var set$1 = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 64L128 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sev = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sib = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 9.40976e-06C64 35.3462 92.6538 64 128 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sic = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sid = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C110.327 128 96 113.673 96 96C96 78.3269 110.327 64 128 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sig = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sil = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "16.0036",
      y1: "15.9965",
      x2: "48.0036",
      y2: "47.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sim = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 64V128H0L2.79753e-06 64C4.34256e-06 28.6538 28.6538 -1.54503e-06 64 0C99.3462 1.54503e-06 128 28.6538 128 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sip = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M16 64C16 37.4903 37.4903 16 64 16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sit = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var siv = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96L0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var soc = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "16",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "16",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sog = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 96C81.6731 96 96 81.6731 96 64C96 46.3269 81.6731 32 64 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sol = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L-5.96046e-08 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var som = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var son = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "127.553",
      y1: "128.224",
      x2: "63.5528",
      y2: "0.223598",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sop = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sor = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0C128 35.3511 113.669 67.3551 90.5 90.5193",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0C96 26.5077 85.2564 50.5061 67.8862 67.8783",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0C64 17.6721 56.8374 33.6713 45.2568 45.2529",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32.3716 0C32.3716 8.83603 28.7903 16.8356 23 22.6264",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sov = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 128L128 0",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C92.6489 128 60.6449 113.669 37.4807 90.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C101.492 96 77.4939 85.2564 60.1217 67.8862",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C110.328 64 94.3287 56.8374 82.7471 45.2568",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32.3716C119.164 32.3716 111.164 28.7903 105.374 23",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sub = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sud = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-8.87604e-09",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sug = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sul = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 96C46.3269 96 32 81.6731 32 64C32 46.3269 46.3269 32 64 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sum = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.01717e-06 64C35.3462 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sun = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "80",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "80",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "48",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "48",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "48",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "48",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "80",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "80",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sup$1 = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 112C90.5097 112 112 90.5097 112 64C112 37.4903 90.5097 16 64 16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sur = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M3.73284e-05 64.0001C17.6633 64.0001 33.6554 56.8446 45.2356 45.2742",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0.000105172 128C35.3582 128 67.3679 113.664 90.5332 90.4863",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sut = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var syd = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 16C37.4903 16 16 37.4903 16 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var syl = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var sym = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "96.5",
      y1: "3.07317e-08",
      x2: "96.5",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var syn = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 0C35.3511 0 67.3551 14.3309 90.5193 37.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 32C26.5077 32 50.5061 42.7436 67.8783 60.1138",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 64C17.6721 64 33.6713 71.1626 45.2529 82.7432",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 95.6284C8.83603 95.6284 16.8356 99.2097 22.6264 105",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var syp = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.01717e-06 64C35.3462 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var syr = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var syt = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var syx = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 128C4.63574e-06 92.6488 14.3309 60.6449 37.5 37.4807",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128C32 101.492 42.7436 77.4939 60.1138 60.1216",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128C64 110.328 71.1626 94.3287 82.7432 82.7471",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M95.6284 128C95.6284 119.164 99.2097 111.164 105 105.374",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tab$1 = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "8",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tac = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tad = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tag = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0036",
      y1: "79.9964",
      x2: "112.004",
      y2: "111.996",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tal = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "0.5",
      y1: "-0.5",
      x2: "181.5",
      y2: "-0.5",
      transform: "matrix(-0.707107 0.707107 0.707107 0.707107 128.71 0)",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 128C96 74.9807 53.0193 32 0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tam = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "96",
      x2: "-8.87604e-09",
      y2: "96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "32",
      x2: "-8.87604e-09",
      y2: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tan = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 128C96 74.9807 53.0193 32 0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 128C64 92.6538 35.3462 64 0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M48 128C48 101.49 26.5097 80 0 80",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 128C32 110.327 17.6731 96 0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M16 128C16 119.163 8.83656 112 0 112",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C128 57.3075 70.6925 0 0 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tap = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-8.87604e-09",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 32C81.6731 32 96 46.3269 96 64C96 81.6731 81.6731 96 64 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tar = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tas = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 32C81.6731 32 96 46.3269 96 64C96 81.6731 81.6731 96 64 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var teb = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.52575e-06 96C53.0193 96 96 53.0193 96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tec = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9965",
      x2: "112.003",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ted = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var teg = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 80C119.163 80 112 72.8366 112 64C112 55.1634 119.163 48 128 48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tel = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "15",
      cy: "112",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "15",
      cy: "112",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 0L127.986 127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L128 96",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L128 64",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 0L128 32",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tem = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 92.6538 64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.00285417",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ten = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "48",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "48",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "48",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "48",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "80",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "80",
      cy: "80",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "80",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "48",
      cy: "80",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tep = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.14479e-06 96C53.0193 96 96 53.0193 96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ter = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 64L5.59506e-06 0L128 1.11901e-05V64C128 99.3462 99.3462 128 64 128C28.6538 128 -4.6351e-06 99.3462 0 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "96.5",
      y1: "3.07317e-08",
      x2: "96.5",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.01717e-06 64C35.3462 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tes = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tev = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tex = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9965",
      y1: "111.997",
      x2: "47.9965",
      y2: "79.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tic = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32C110.327 32 96 17.6731 96 -1.39876e-06",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tid = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "96",
      y1: "2.18557e-08",
      x2: "96",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M112 32C112 40.8366 104.837 48 96 48C87.1634 48 80 40.8366 80 32C80 23.1634 87.1634 16 96 16C104.837 16 112 23.1634 112 32ZM96 40C100.418 40 104 36.4183 104 32C104 27.5817 100.418 24 96 24C91.5817 24 88 27.5817 88 32C88 36.4183 91.5817 40 96 40Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var til = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0036",
      y1: "79.9965",
      x2: "112.004",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tim = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 64V128H0L2.79753e-06 64C4.34256e-06 28.6538 28.6538 -1.54503e-06 64 0C99.3462 1.54503e-06 128 28.6538 128 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00291443 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tin = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "32",
      y1: "2.18557e-08",
      x2: "32",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tip = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 0L64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tir = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tob = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 64V128H0L2.79753e-06 64C4.34256e-06 28.6538 28.6538 -1.54503e-06 64 0C99.3462 1.54503e-06 128 28.6538 128 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96L0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var toc = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "96",
      x2: "-8.87604e-09",
      y2: "96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tod = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tog = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 96C46.3269 96 32 81.6731 32 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tol = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "128",
      y1: "64",
      x2: "-4.37114e-08",
      y2: "64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M16 128C16 101.49 37.4903 80 64 80C90.5097 80 112 101.49 112 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tom = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var ton = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32C74.9807 32 32 74.9807 32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 92.6538 64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C110.327 96 96 110.327 96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var top = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "16",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tor = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tuc = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96L0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tud = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tug = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32L0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tul = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tun = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 64V128H0L2.79753e-06 64C4.34256e-06 28.6538 28.6538 -1.54503e-06 64 0C99.3462 1.54503e-06 128 28.6538 128 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tus = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tux = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tyc = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tyd = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00280762 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.65 47.6499)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "15.9964",
      y1: "111.997",
      x2: "47.9964",
      y2: "79.9965",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tyl = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M7.37542e-06 -3.56072e-06C1.19529e-06 70.6924 57.3075 128 128 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tyn = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 -2.28831e-06C57.3076 -3.13131e-06 8.42999e-07 57.3075 0 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var typ = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M96 1.90735e-06C96 53.0193 53.0193 96 0 96",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tyr = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 0L128 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 64C35.3462 64 64 92.6538 64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var tyv = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M256 0L128 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wac = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "11.5",
      fill: "@BG",
      stroke: "@BG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "112",
      r: "9",
      fill: "@FG",
      stroke: "@FG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wal = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64.5",
      y1: "-0.5",
      x2: "64.5",
      y2: "127.5",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "32",
      y1: "2.18557e-08",
      x2: "32",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wan = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wat = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var web = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 128C128 57.3075 70.6925 0 0 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wed = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var weg = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M79.5254 0C79.5254 8.83656 72.3619 16 63.5254 16C54.6888 16 47.5254 8.83656 47.5254 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wel = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32C74.9807 32 32 74.9807 32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64C92.6538 64 64 92.6538 64 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C110.327 96 96 110.327 96 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wen = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.01717e-06 64C35.3462 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wep = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wer = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 64L5.59506e-06 0L128 1.11901e-05V64C128 99.3462 99.3462 128 64 128C28.6538 128 -4.6351e-06 99.3462 0 64Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 0L32 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wes = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "80.0035",
      y1: "79.9965",
      x2: "112.003",
      y2: "111.997",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "112",
      cy: "112",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "112",
      cy: "112",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wet = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 64H0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wex = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wic = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 0C57.3075 8.42999e-07 -8.42999e-07 57.3075 0 128H128V0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wid = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "48.0035",
      y1: "80.0036",
      x2: "16.0035",
      y2: "112.004",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M80 64C80 72.8366 72.8366 80 64 80C55.1634 80 48 72.8366 48 64C48 55.1634 55.1634 48 64 48C72.8366 48 80 55.1634 80 64ZM64 72C68.4183 72 72 68.4183 72 64C72 59.5817 68.4183 56 64 56C59.5817 56 56 59.5817 56 64C56 68.4183 59.5817 72 64 72Z",
      fill: "@BG"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var win = {
  children: [{
    name: "rect",
    attributes: {
      width: "128",
      height: "128",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wis = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 0C0 70.6925 57.3075 128 128 128V0H0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 64L0 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 32L0 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wit = {
  children: [{
    name: "path",
    attributes: {
      d: "M0 127.946C0.0292286 57.2783 57.3256 3.08928e-06 128 0C128 70.6823 70.7089 127.984 0.0305092 128C0.0203397 128 0.01017 128 2.36469e-09 128L0 127.946Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "64",
      y1: "2.18557e-08",
      x2: "64",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "32",
      y1: "2.18557e-08",
      x2: "32",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "96",
      y1: "2.18557e-08",
      x2: "96",
      y2: "128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wol = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M0 64L128 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 96C110.327 96 96 81.6731 96 64C96 46.3269 110.327 32 128 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wor = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      y1: "-0.5",
      x2: "45.2548",
      y2: "-0.5",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 79.65 47.65)",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "line",
    attributes: {
      x1: "-0.0029152",
      x2: "127.983",
      y2: "127.986",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M64 96C46.3269 96 32 81.6731 32 64",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wyc = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wyd = {
  children: [{
    name: "path",
    attributes: {
      d: "M0.0541 0C70.7217 0.0292317 128 57.3256 128 128C57.3177 128 0.0164917 70.7089 7.62806e-06 0.0305091C7.62851e-06 0.0203397 -4.44317e-10 0.01017 0 0H0.0541Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M32 64C32 46.3269 46.3269 32 64 32",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wyl = {
  children: [{
    name: "path",
    attributes: {
      d: "M128 128C128 57.3076 70.6925 6.18013e-06 1.11901e-05 0L0 128L128 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-3.8147e-06 128C-7.24633e-07 92.6538 28.6538 64 64 64C99.3462 64 128 92.6538 128 128",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wyn = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.52575e-06 96C53.0193 96 96 53.0193 96 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M1.01717e-06 64C35.3462 64 64 35.3462 64 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M5.08584e-07 32C17.6731 32 32 17.6731 32 0",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wyt = {
  children: [{
    name: "path",
    attributes: {
      d: "M64 128H0L5.59506e-06 0L64 5.59506e-06C99.3462 8.68512e-06 128 28.6538 128 64C128 99.3462 99.3462 128 64 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M128 0L0 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "48",
      stroke: "@BG",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "16",
      cy: "64",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var wyx = {
  children: [{
    name: "path",
    attributes: {
      d: "M5.59506e-06 128C70.6925 128 128 70.6925 128 0L0 5.59506e-06L5.59506e-06 128Z",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }, {
    name: "path",
    attributes: {
      d: "M-0.00292969 0L127.997 128",
      stroke: "@BG",
      "stroke-linecap": "square",
      fill: "none"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "96",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "32",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "11.5",
      fill: "@FG",
      stroke: "@FG"
    },
    children: []
  }, {
    name: "circle",
    attributes: {
      cx: "96",
      cy: "32",
      r: "9",
      fill: "@BG",
      stroke: "@BG",
      "stroke-width": "2"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var zod = {
  children: [{
    name: "circle",
    attributes: {
      cx: "64",
      cy: "64",
      r: "64",
      fill: "@FG",
      stroke: "@BG",
      "stroke-width": "0.5",
      dataisgeon: "true"
    },
    children: []
  }],
  name: "g",
  attributes: {
    fill: "none"
  }
};
var index = {
  bac: bac,
  bal: bal,
  ban: ban,
  bar: bar,
  bat: bat,
  bec: bec,
  bel: bel,
  ben: ben,
  bep: bep,
  ber: ber,
  bes: bes,
  bet: bet,
  bex: bex,
  bic: bic,
  bid: bid,
  bil: bil,
  bin: bin,
  bis: bis,
  bit: bit,
  bol: bol,
  bon: bon,
  bor: bor,
  bos: bos,
  bot: bot,
  bud: bud,
  bur: bur,
  bus: bus,
  byl: byl,
  byn: byn,
  byr: byr,
  byt: byt,
  dab: dab,
  dac: dac,
  dal: dal,
  dan: dan,
  dap: dap,
  dar: dar,
  das: das,
  dat: dat,
  dav: dav,
  deb: deb,
  dec: dec,
  def: def,
  deg: deg,
  del: del,
  dem: dem,
  den: den,
  dep: dep,
  der: der,
  des: des,
  det: det,
  dev: dev,
  dex: dex,
  dib: dib,
  dif: dif,
  dig: dig,
  dil: dil,
  din: din,
  dir: dir,
  dis: dis,
  div: div$1,
  doc: doc,
  dol: dol,
  don: don,
  dop: dop,
  dor: dor,
  dos: dos,
  dot: dot,
  dov: dov,
  doz: doz,
  duc: duc,
  dul: dul,
  dun: dun,
  dur: dur,
  dus: dus,
  dut: dut,
  dux: dux,
  dyl: dyl,
  dyn: dyn,
  dyr: dyr,
  dys: dys,
  dyt: dyt,
  fab: fab,
  fad: fad,
  fal: fal,
  fam: fam,
  fan: fan,
  fas: fas,
  feb: feb,
  fed: fed,
  fel: fel,
  fen: fen,
  fep: fep,
  fer: fer,
  fes: fes,
  fet: fet,
  fex: fex,
  fid: fid,
  fig: fig,
  fil: fil,
  fin: fin,
  fip: fip,
  fir: fir,
  fit: fit,
  fod: fod,
  fog: fog,
  fol: fol,
  fon: fon,
  fop: fop,
  "for": {
    children: [{
      name: "path",
      attributes: {
        d: "M64 0H128V128H64C28.6538 128 0 99.3462 0 64C0 28.6538 28.6538 0 64 0Z",
        fill: "@FG",
        stroke: "@BG",
        "stroke-width": "0.5",
        dataisgeon: "true"
      },
      children: []
    }, {
      name: "line",
      attributes: {
        x1: "96",
        y1: "2.18557e-08",
        x2: "96",
        y2: "128",
        stroke: "@BG",
        fill: "none"
      },
      children: []
    }, {
      name: "circle",
      attributes: {
        cx: "64",
        cy: "64",
        r: "11.5",
        fill: "@FG",
        stroke: "@FG"
      },
      children: []
    }, {
      name: "circle",
      attributes: {
        cx: "64",
        cy: "64",
        r: "9",
        fill: "@BG",
        stroke: "@BG",
        "stroke-width": "2"
      },
      children: []
    }],
    name: "g",
    attributes: {
      fill: "none"
    }
  },
  fos: fos,
  fot: fot,
  ful: ful,
  fun: fun,
  fur: fur,
  fus: fus,
  fyl: fyl,
  fyn: fyn,
  fyr: fyr,
  hab: hab,
  hac: hac,
  had: had,
  hal: hal,
  han: han,
  hap: hap,
  har: har,
  has: has,
  hat: hat,
  hav: hav,
  heb: heb,
  hec: hec,
  hep: hep,
  hes: hes,
  het: het,
  hex: hex,
  hid: hid,
  hil: hil,
  hin: hin,
  hob: hob,
  hoc: hoc,
  hod: hod,
  hol: hol,
  hop: hop,
  hos: hos,
  hul: hul,
  hus: hus,
  hut: hut,
  lab: lab,
  lac: lac,
  lad: lad,
  lag: lag,
  lan: lan,
  lap: lap,
  lar: lar,
  las: las,
  lat: lat,
  lav: lav,
  leb: leb,
  lec: lec,
  led: led,
  leg: leg,
  len: len,
  lep: lep,
  ler: ler,
  "let": {
    children: [{
      name: "circle",
      attributes: {
        cx: "64",
        cy: "64",
        r: "64",
        fill: "@FG",
        stroke: "@BG",
        "stroke-width": "0.5",
        dataisgeon: "true"
      },
      children: []
    }, {
      name: "path",
      attributes: {
        d: "M64 0L64 128",
        stroke: "@BG",
        fill: "none"
      },
      children: []
    }],
    name: "g",
    attributes: {
      fill: "none"
    }
  },
  lev: lev,
  lex: lex,
  lib: lib$3,
  lid: lid,
  lig: lig,
  lin: lin,
  lis: lis,
  lit: lit,
  liv: liv,
  loc: loc,
  lod: lod,
  lom: lom,
  lon: lon,
  lop: lop,
  lor: lor,
  los: los,
  luc: luc,
  lud: lud,
  lug: lug,
  lun: lun,
  lup: lup,
  lur: lur,
  lus: lus,
  lut: lut,
  lux: lux,
  lyd: lyd,
  lyn: lyn,
  lyr: lyr,
  lys: lys,
  lyt: lyt,
  lyx: lyx,
  mac: mac,
  mag: mag,
  mal: mal,
  map: map$1,
  mar: mar,
  mas: mas,
  mat: mat,
  meb: meb,
  mec: mec,
  med: med,
  meg: meg,
  mel: mel,
  mep: mep,
  mer: mer,
  mes: mes,
  met: met,
  mev: mev,
  mex: mex,
  mic: mic,
  mid: mid,
  mig: mig,
  mil: mil,
  min: min,
  mip: mip,
  mir: mir,
  mis: mis,
  mit: mit,
  moc: moc,
  mod: mod,
  mog: mog,
  mol: mol,
  mon: mon,
  mop: mop,
  mor: mor,
  mos: mos,
  mot: mot,
  mud: mud,
  mug: mug,
  mul: mul,
  mun: mun,
  mur: mur,
  mus: mus,
  mut: mut,
  myl: myl,
  myn: myn,
  myr: myr,
  nac: nac,
  nal: nal,
  nam: nam,
  nap: nap,
  nar: nar,
  nat: nat,
  nav: nav,
  neb: neb,
  nec: nec,
  ned: ned,
  nel: nel,
  nem: nem,
  nep: nep,
  ner: ner,
  nes: nes,
  net: net,
  nev: nev,
  nex: nex,
  nib: nib,
  nid: nid,
  nil: nil,
  nim: nim,
  nis: nis,
  noc: noc,
  nod: nod,
  nol: nol,
  nom: nom,
  nop: nop,
  nor: nor,
  nos: nos,
  nov: nov,
  nub: nub,
  nul: nul,
  num: num,
  nup: nup,
  nus: nus,
  nut: nut,
  nux: nux,
  nyd: nyd,
  nyl: nyl,
  nym: nym,
  nyr: nyr,
  nys: nys,
  nyt: nyt,
  nyx: nyx,
  pac: pac,
  pad: pad,
  pag: pag,
  pal: pal,
  pan: pan,
  par: par,
  pas: pas,
  pat: pat,
  pec: pec,
  ped: ped,
  peg: peg,
  pel: pel,
  pem: pem,
  pen: pen,
  per: per,
  pes: pes,
  pet: pet,
  pex: pex,
  pic: pic,
  pid: pid,
  pil: pil,
  pin: pin,
  pit: pit,
  poc: poc,
  pod: pod,
  pol: pol,
  pon: pon,
  pos: pos,
  pub: pub,
  pun: pun,
  pur: pur,
  put: put,
  pyl: pyl,
  pyx: pyx,
  rab: rab,
  rac: rac,
  rad: rad,
  rag: rag,
  ral: ral,
  ram: ram,
  ran: ran,
  rap: rap,
  rav: rav,
  reb: reb,
  rec: rec,
  red: red,
  ref: ref,
  reg: reg,
  rel: rel,
  rem: rem,
  ren: ren,
  rep: rep,
  res: res,
  ret: ret,
  rev: rev,
  rex: rex,
  rib: rib,
  ric: ric,
  rid: rid,
  rig: rig,
  ril: ril,
  rin: rin,
  rip: rip,
  ris: ris,
  rit: rit,
  riv: riv,
  roc: roc,
  rol: rol,
  ron: ron,
  rop: rop,
  ros: ros,
  rov: rov,
  ruc: ruc,
  rud: rud,
  rul: rul,
  rum: rum,
  run: run,
  rup: rup,
  rus: rus,
  rut: rut,
  rux: rux,
  ryc: ryc,
  ryd: ryd,
  ryg: ryg,
  ryl: ryl,
  rym: rym,
  ryn: ryn,
  ryp: ryp,
  rys: rys,
  ryt: ryt,
  ryx: ryx,
  sab: sab,
  sal: sal,
  sam: sam,
  san: san,
  sap: sap,
  sar: sar,
  sat: sat,
  sav: sav,
  seb: seb,
  sec: sec,
  sed: sed,
  sef: sef,
  seg: seg,
  sel: sel,
  sem: sem,
  sen: sen,
  sep: sep,
  ser: ser,
  set: set$1,
  sev: sev,
  sib: sib,
  sic: sic,
  sid: sid,
  sig: sig,
  sil: sil,
  sim: sim,
  sip: sip,
  sit: sit,
  siv: siv,
  soc: soc,
  sog: sog,
  sol: sol,
  som: som,
  son: son,
  sop: sop,
  sor: sor,
  sov: sov,
  sub: sub,
  sud: sud,
  sug: sug,
  sul: sul,
  sum: sum,
  sun: sun,
  sup: sup$1,
  sur: sur,
  sut: sut,
  syd: syd,
  syl: syl,
  sym: sym,
  syn: syn,
  syp: syp,
  syr: syr,
  syt: syt,
  syx: syx,
  tab: tab$1,
  tac: tac,
  tad: tad,
  tag: tag,
  tal: tal,
  tam: tam,
  tan: tan,
  tap: tap,
  tar: tar,
  tas: tas,
  teb: teb,
  tec: tec,
  ted: ted,
  teg: teg,
  tel: tel,
  tem: tem,
  ten: ten,
  tep: tep,
  ter: ter,
  tes: tes,
  tev: tev,
  tex: tex,
  tic: tic,
  tid: tid,
  til: til,
  tim: tim,
  tin: tin,
  tip: tip,
  tir: tir,
  tob: tob,
  toc: toc,
  tod: tod,
  tog: tog,
  tol: tol,
  tom: tom,
  ton: ton,
  top: top,
  tor: tor,
  tuc: tuc,
  tud: tud,
  tug: tug,
  tul: tul,
  tun: tun,
  tus: tus,
  tux: tux,
  tyc: tyc,
  tyd: tyd,
  tyl: tyl,
  tyn: tyn,
  typ: typ,
  tyr: tyr,
  tyv: tyv,
  wac: wac,
  wal: wal,
  wan: wan,
  wat: wat,
  web: web,
  wed: wed,
  weg: weg,
  wel: wel,
  wen: wen,
  wep: wep,
  wer: wer,
  wes: wes,
  wet: wet,
  wex: wex,
  wic: wic,
  wid: wid,
  win: win,
  wis: wis,
  wit: wit,
  wol: wol,
  wor: wor,
  wyc: wyc,
  wyd: wyd,
  wyl: wyl,
  wyn: wyn,
  wyt: wyt,
  wyx: wyx,
  zod: zod
};
var FG = 1;
var BG = 0;
var COLOR_CODES = {
  FG: '@FG',
  BG: '@BG'
};
var UNIT_GRIDS = {
  4: [{
    x: 0,
    y: 0
  }, {
    x: 128,
    y: 0
  }, {
    x: 0,
    y: 128
  }, {
    x: 128,
    y: 128
  }],
  2: [{
    x: 0,
    y: 0
  }, {
    x: 128,
    y: 0
  }],
  1: [{
    x: 0,
    y: 0
  }]
};
var TILEMAP = {
  4: {
    x: 2,
    y: 2
  },
  2: {
    x: 2,
    y: 1
  },
  1: {
    x: 1,
    y: 1
  }
}; // class ConfigError extends Error {}
// apply color preference

var paint = function paint(node, colors, strokeWidth) {
  var fillIndex = node.attributes.fill === COLOR_CODES.FG ? FG : BG;
  var strokeIndex = node.attributes.stroke === COLOR_CODES.FG ? FG : BG;
  if (node.attributes.fill !== undefined && node.attributes.fill !== 'none') {
    node.attributes.fill = colors[fillIndex];
  }
  if (node.attributes.stroke !== undefined && node.attributes.stroke !== 'none') {
    node.attributes.stroke = colors[strokeIndex];
    node.attributes['stroke-width'] = strokeWidth + 'px';
    node.attributes['stroke-linecap'] = 'square'; // non-scaling-stroke is used to prevent the stroke from scaling when a scaling transformation is applied by sigil()

    node.attributes['vector-effect'] = 'non-scaling-stroke';
  }
  return _extends$4({
    name: node.name,
    attributes: node.attributes,
    children: node.children.map(function (n) {
      return paint(n, colors, strokeWidth);
    })
  }, node);
};
var sigil = function sigil(props) {
  props = _extends$4({}, props); // Set default values from config

  if (typeof props.colors === 'undefined') {
    props.colors = ['#000', '#fff'];
  }
  if (typeof props.attributes === 'undefined') {
    props.attributes = {};
  }
  if (typeof props.style === 'undefined') {
    props.style = {};
  }
  if (typeof props["class"] === 'undefined') {
    props["class"] = '';
  } // if props.size is defined, set width and height

  if (!(typeof props.size === 'undefined')) {
    props.width = props.size;
    props.height = props.size;
  } // if width and height are undefined, set default size

  if (typeof props.width === 'undefined' || typeof props.height === 'undefined') {
    props.width = 128;
    props.height = 128;
  }
  if (typeof props.margin === 'undefined') {
    props.margin = true;
  }
  if (props.icon === true) {
    props.margin = false;
  } // get phonemes as array from patp input and split into array

  var phonemes = chunkStr(props.patp.replace(/[\^~-]/g, ''), 3);
  !Array.isArray(phonemes) ? process.env.NODE_ENV !== "production" ? invariant_1(false, "Invalid patp argument") : invariant_1(false) : void 0; // Throw an error if the phoneme length is not a 32, 16 or 8 bit point.

  var phonemeLengthDidPass = phonemes.length === 1 || phonemes.length === 2 || phonemes.length === 4;
  !phonemeLengthDidPass ? process.env.NODE_ENV !== "production" ? invariant_1(false, "@tlon/sigil-js cannot render @p of length " + phonemes.length + ". Only lengths of 1 (galaxy), 2 (star), and 4 (planet) are supported at this time.") : invariant_1(false) : void 0; // get symbols and clone them. If no symbol is found, the @p prop was invalid.

  var patpDidPass;
  var symbols = phonemes.map(function (phoneme) {
    // @ts-ignore
    var ast = index[phoneme];
    if (isUndefined$2(ast)) {
      patpDidPass = false;
      return {};
    } else {
      patpDidPass = true;
      return deepClone(ast);
    }
  });
  !patpDidPass ? process.env.NODE_ENV !== "production" ? invariant_1(false, "@tlon/sigil-js  needs a valid patp (point name). Patp field is invalid. Recieved " + props.patp) : invariant_1(false) : void 0;
  if (props.icon === true) {
    symbols = symbols.map(function (s) {
      return _extends$4({}, s, {
        children: s.children.filter(function (c) {
          return c.attributes['dataisgeon'];
        })
      });
    });
  }
  var tier = symbols.length === 4 ? 4 : symbols.length === 2 ? 2 : 1; // get a grid according to the point's tier (planet, start, galaxy)

  var grid = UNIT_GRIDS[tier]; // Move each symbol into it's new x/y position on a unit rectangle sized 256 by 256.

  for (var i = 0; i < grid.length; i++) {
    var positionTransform = toString$1(translate(grid[i].x, grid[i].y));
    if (symbols[i].attributes === undefined) {
      symbols[i].attributes = {};
    }
    symbols[i].attributes.transform = positionTransform;
  } // Create a variable that will store a ratio used to scale the symbolsGroup to its final size driven primarily by props.size, or props.width fallback.

  var resizeRatio;
  if (tier === 1) {
    // If there is only 1 symbol being drawn
    if (props.margin === true) {
      // If this symbol will be drawn with a margin
      resizeRatio = 0.5 * 0.8;
    } else {
      // If this symbol will be drawn without a margin
      resizeRatio = 1;
    }
  } else {
    // If the sigils is 2 symbols wide
    if (props.margin === true) {
      // If this symbol will be drawn with a margin
      resizeRatio = 0.5 * 0.8;
    } else {
      // If this symbol will be drawn without a margin
      resizeRatio = 0.5;
    }
  } // Calculate the size of each symbol - IE, for planets, there are four symbols.

  var symbolSize = {
    x: props.width * resizeRatio,
    y: props.height * resizeRatio
  }; // Calculate the left and top margins that will be used to transform the symbolsGroup.

  var marginPx = {
    x: (props.width - TILEMAP[tier].x * symbolSize.x) / 2,
    y: (props.height - TILEMAP[tier].y * symbolSize.y) / 2
  };
  if (props.margin === false || props.icon === true) {
    marginPx.x = 0;
    if (props.icon !== true) {
      marginPx.y = 0;
    }
  } // Calculate how much the symbolsGroups should change in scale. 128 is the unit size of the SVGs as drawn in their source file.

  var symbolsGroupScale = symbolSize.x / 128; // First translate the symbols group to a centered x/y position, then scale the group to it's final size.

  var scaleAndCenteringTransform = toString$1(transform$1(translate(marginPx.x, marginPx.y), scale(symbolsGroupScale, symbolsGroupScale))); // Create a SVG AST group and assign the transformation and child symbols to it.

  var symbolsGroup = {
    name: 'g',
    type: '',
    value: '',
    attributes: {
      transform: scaleAndCenteringTransform
    },
    children: symbols
  };
  if (props.style === undefined) {
    props.style = {};
  }
  if (props.style.width === undefined) {
    props.style.width = props.width + "px";
  }
  if (props.style.height === undefined) {
    props.style.height = props.height + "px";
  }
  var wrapped = {
    name: 'svg',
    type: '',
    value: '',
    attributes: _extends$4({
      style: _extends$4({
        // prevent bottom margin on svg tag
        display: 'block'
      }, props.style),
      viewBox: "0 0 " + props.width + " " + props.height,
      version: '1.1',
      xmlns: 'http://www.w3.org/2000/svg',
      "class": props["class"]
    }, props.attributes),
    children: [
    // Background rectangle
    {
      name: 'rect',
      type: '',
      value: '',
      attributes: {
        fill: COLOR_CODES.BG,
        width: props.width + "px",
        height: props.height + "px",
        x: 0 + 'px',
        y: 0 + 'px'
      },
      children: []
    }, symbolsGroup]
  }; // Calculate a strokeWidth based on props.size

  var strokeWidth;
  if (props.strokeScalingFunction) {
    strokeWidth = props.strokeScalingFunction(props.size);
  } else {
    strokeWidth = props.width / 128 + 0.33;
  }
  if (props.icon === true) {
    strokeWidth = 0.8;
  } // Recursively apply color and other style attributes.

  var out = paint(wrapped, props.colors, strokeWidth); // If a renderer function has been provided, call this renderer with provided AST. If there is no renderer, return the AST.

  return props.renderer === undefined ? out : props.renderer(out);
};

const foregroundFromBackground = background => {
  const rgb = {
    r: parseInt(background.slice(1, 3), 16),
    g: parseInt(background.slice(3, 5), 16),
    b: parseInt(background.slice(5, 7), 16)
  };
  const brightness = (299 * rgb.r + 587 * rgb.g + 114 * rgb.b) / 1000;
  const whiteBrightness = 255;
  return whiteBrightness - brightness < 50 ? "black" : "white";
};
const Sigil = ({
  patp,
  size,
  color = "#24201E",
  icon
}) => {
  if (patp.length > 14) {
    return /*#__PURE__*/React__default["default"].createElement("div", null);
  }
  const foreground = foregroundFromBackground(color);
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: icon ? "p-1" : "",
    style: {
      backgroundColor: icon ? color || "black" : "transparent"
    }
  }, sigil({
    patp: patp,
    renderer: reactRenderer,
    size: icon ? size / 2 : size,
    colors: [color, foreground],
    icon: icon || false
  }));
};

function devSearch(query) {
  return `/api/dev-search?q=${encodeURIComponent(query)}`;
}
function urbitOrgSearch(query) {
  return `/api/urbit-org-search?q=${encodeURIComponent(query)}`;
}
function roadmapSearch(query) {
  return `/api/roadmap-search?q=${encodeURIComponent(query)}`;
}
function opsSearch(query) {
  return `/api/ops-search?q=${encodeURIComponent(query)}`;
}
function patpSearch(query) {
  return src.isValidPatp(`~${deSig(query.toLowerCase())}`) && `~${deSig(query.toLowerCase())}`.length < 15 || !isNaN(query) && query <= 4294967295;
}
function deSig(string) {
  return string.startsWith("~") ? string.substring(1) : string;
}
const Search = ({
  showSearch,
  closeSearch,
  order = ["org", "dev", "ops", "roadmap"],
  ourSite = "https://urbit.org"
}) => {
  const [results, setResults] = React__default["default"].useState([]);
  const router$1 = router.useRouter();
  function onSelect(item) {
    setResults([]);
    if (item.url) {
      router$1.push(item.url);
      return closeSearch();
    }
  }
  const onInputValueChange = lodash_debounce(async query => {
    if (query?.length) {
      const patp = patpSearch(query) ? !isNaN(query) ? src.patp(query) : src.patp(src.patp2dec(`~${deSig(query)}`)) : null;
      const patpResult = patpSearch(query) ? [{
        type: "PATP",
        content: {
          patp: patp,
          slug: `https://urbit.org/ids/${patp}`
        }
      }] : [];
      const siteFetch = (search, source, query) => fetch(search(query)).then(res => res.json()).then(res => {
        return [...res.glossary.map(item => ({
          type: "GLOSSARY",
          content: item,
          source
        })), ...res.results.map(item => ({
          type: "RESULT",
          content: item,
          source,
          url: source + "/" + item.slug
        }))];
      });
      const urbFetch = siteFetch(urbitOrgSearch, "https://urbit.org", query);
      const devFetch = siteFetch(devSearch, "https://developers.urbit.org", query);
      const opsFetch = siteFetch(opsSearch, "https://operators.urbit.org", query);
      const roadmapFetch = siteFetch(roadmapSearch, "https://roadmap.urbit.org", query);
      const [urbitOrgResults, devResults, opsResults, roadmapResults] = await Promise.all([urbFetch, devFetch, opsFetch, roadmapFetch]);
      const list = [...patpResult, ...order.map(entry => {
        switch (entry) {
          case "org":
            return urbitOrgResults;
          case "dev":
            return devResults;
          case "ops":
            return opsResults;
          case "roadmap":
            return roadmapResults;
        }
      })].flat().sort((a, b) => {
        const aNum = a?.type === "GLOSSARY" ? 1 : -1;
        const bNum = b?.type === "GLOSSARY" ? 1 : -1;
        return bNum - aNum;
      });
      console.log(results);
      setResults(list);
    } else {
      setResults([]);
    }
  }, 250);
  return showSearch ? /*#__PURE__*/React__default["default"].createElement(Downshift$1, {
    onSelect: sel => onSelect(sel),
    onInputValueChange: evt => onInputValueChange(evt),
    itemToString: item => item ? item.slug : "",
    defaultHighlightedIndex: 0
  }, ({
    getInputProps,
    getItemProps,
    getMenuProps,
    isOpen,
    highlightedIndex,
    getRootProps
  }) => /*#__PURE__*/React__default["default"].createElement("div", {
    className: "fixed w-screen h-screen z-50 flex flex-col items-center p-4"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    onClick: event => closeSearch(event),
    className: "top-0 left-0 fixed w-screen h-screen bg-washedWall"
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "relative flex flex-col max-w-screen-lg md:my-32 w-full md:w-10/12 lg:w-8/12 xl:w-6/12 rounded-xl bg-white min-h-0 overflow-hidden"
  }, /*#__PURE__*/React__default["default"].createElement("div", _extends$6({
    className: "inline-block"
  }, getRootProps({}, {
    suppressRefError: true
  })), /*#__PURE__*/React__default["default"].createElement("input", _extends$6({
    autoFocus: true,
    className: "text-lg md:text-xl lg:text-2xl font-medium text-green-400 bg-transparent py-2 px-4 outline-none relative w-full",
    placeholder: "Search...",
    type: "text",
    onClick: e => e.stopPropagation()
  }, getInputProps({
    onKeyDown: event => {
      if (event.key === "Escape") {
        // Prevent Downshift's default 'Escape' behavior.
        event.nativeEvent.preventDownshiftDefault = true;
        closeSearch(event);
      }
    }
  })))), /*#__PURE__*/React__default["default"].createElement("ul", _extends$6({}, getMenuProps(), {
    className: "overflow-y-scroll"
  }), isOpen ? results.map((item, index) => {
    const selected = highlightedIndex === index;
    if (item.type === "PATP") {
      return /*#__PURE__*/React__default["default"].createElement("li", _extends$6({
        className: `cursor-pointer p-2 flex space-x-2 items-center text-left w-full ${selected ? "bg-green-400" : ""}`
      }, getItemProps({
        key: item.content.slug + "-" + index,
        index,
        item: item.content,
        selected: highlightedIndex === index
      })), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "rounded-md overflow-hidden"
      }, /*#__PURE__*/React__default["default"].createElement(Sigil, {
        patp: item.content.patp,
        size: 25,
        icon: true
      })), /*#__PURE__*/React__default["default"].createElement("p", {
        className: "font-mono"
      }, item.content.patp));
    }
    if (item.type === "GLOSSARY") {
      return /*#__PURE__*/React__default["default"].createElement("li", _extends$6({
        className: `cursor-pointer flex text-left w-full ${selected ? "bg-green-400" : ""}`
      }, getItemProps({
        key: item.content.slug + "-" + index,
        index,
        item: item.content,
        selected: highlightedIndex === index
      })), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "font-semibold p-3"
      }, /*#__PURE__*/React__default["default"].createElement("p", {
        className: `text-base ${selected ? "text-white" : "text-wall-600"}`
      }, item.content.symbol.length > 0 && /*#__PURE__*/React__default["default"].createElement("code", {
        className: `mr-1 rounded px-1 py-0.5 ${selected ? "bg-washedWhite" : "bg-wall-100"}`
      }, item.content.symbol), item.content.name), /*#__PURE__*/React__default["default"].createElement("p", {
        className: `font-normal text-base mt-1 ${selected ? "text-white" : "text-wall-600"}`,
        dangerouslySetInnerHTML: {
          __html: item.content.desc
        }
      })));
    }
    if (item.type === "RESULT") {
      const our = item.source === ourSite;
      const prelude = our ? "" : `${item.source.substring(8)} / `;
      return /*#__PURE__*/React__default["default"].createElement("li", _extends$6({
        className: `cursor-pointer flex text-left w-full ${selected ? "bg-green-400" : ""}`
      }, getItemProps({
        key: item.content.link + "-" + index,
        index,
        item,
        selected
      })), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "p-3"
      }, /*#__PURE__*/React__default["default"].createElement("p", {
        className: `font-medium text-base ${selected ? "text-white" : "text-wall-600"}`
      }, /*#__PURE__*/React__default["default"].createElement("span", {
        className: classNames({
          "text-wall-400": !our
        })
      }, item.content.parent !== "Content" ? `${prelude}${item.content.parent} / ` : prelude + " "), item.content.title), /*#__PURE__*/React__default["default"].createElement("p", {
        className: `text-base font-regular text-small ${selected ? "text-midWhite" : "text-wall-500"}`
      }, item.content.content, item?.content?.foundOnPage && /*#__PURE__*/React__default["default"].createElement("span", {
        className: "italic block"
      }, "Found in page content"))));
    }
  }) : null)))) : null;
};

var dynamic$3 = {exports: {}};

var dynamic$2 = {exports: {}};

var _extends$3 = {};

Object.defineProperty(_extends$3, "__esModule", {
  value: true
});
_extends$3.default = _extends$2;
function _extends$2() {
  return extends_.apply(this, arguments);
}
function extends_() {
  extends_ = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return extends_.apply(this, arguments);
}

var _interop_require_default$2 = {};

Object.defineProperty(_interop_require_default$2, "__esModule", {
  value: true
});
_interop_require_default$2.default = _interopRequireDefault;
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var loadable = {};

var loadableContext = {};

Object.defineProperty(loadableContext, "__esModule", {
  value: true
});
loadableContext.LoadableContext = void 0;
var _interop_require_default$1 = _interop_require_default$2.default;
var _react$1 = _interop_require_default$1(React__default["default"]);
const LoadableContext = _react$1.default.createContext(null);
loadableContext.LoadableContext = LoadableContext;
if (process.env.NODE_ENV !== 'production') {
  LoadableContext.displayName = 'LoadableContext';
}

var shim = {exports: {}};

var useSyncExternalStoreShim_production_min = {};

/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredUseSyncExternalStoreShim_production_min;

function requireUseSyncExternalStoreShim_production_min () {
	if (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;
	hasRequiredUseSyncExternalStoreShim_production_min = 1;

	var e = React__default["default"];
	function h(a, b) {
	  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
	}
	var k = "function" === typeof Object.is ? Object.is : h,
	  l = e.useState,
	  m = e.useEffect,
	  n = e.useLayoutEffect,
	  p = e.useDebugValue;
	function q(a, b) {
	  var d = b(),
	    f = l({
	      inst: {
	        value: d,
	        getSnapshot: b
	      }
	    }),
	    c = f[0].inst,
	    g = f[1];
	  n(function () {
	    c.value = d;
	    c.getSnapshot = b;
	    r(c) && g({
	      inst: c
	    });
	  }, [a, d, b]);
	  m(function () {
	    r(c) && g({
	      inst: c
	    });
	    return a(function () {
	      r(c) && g({
	        inst: c
	      });
	    });
	  }, [a]);
	  p(d);
	  return d;
	}
	function r(a) {
	  var b = a.getSnapshot;
	  a = a.value;
	  try {
	    var d = b();
	    return !k(a, d);
	  } catch (f) {
	    return !0;
	  }
	}
	function t(a, b) {
	  return b();
	}
	var u = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t : q;
	useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u;
	return useSyncExternalStoreShim_production_min;
}

var useSyncExternalStoreShim_development = {};

/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredUseSyncExternalStoreShim_development;

function requireUseSyncExternalStoreShim_development () {
	if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
	hasRequiredUseSyncExternalStoreShim_development = 1;

	if (process.env.NODE_ENV !== "production") {
	  (function () {

	    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
	      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
	    }
	    var React = React__default["default"];
	    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
	    function error(format) {
	      {
	        {
	          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	            args[_key2 - 1] = arguments[_key2];
	          }
	          printWarning('error', format, args);
	        }
	      }
	    }
	    function printWarning(level, format, args) {
	      // When changing this logic, you might want to also
	      // update consoleWithStackDev.www.js as well.
	      {
	        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
	        var stack = ReactDebugCurrentFrame.getStackAddendum();
	        if (stack !== '') {
	          format += '%s';
	          args = args.concat([stack]);
	        } // eslint-disable-next-line react-internal/safe-string-coercion

	        var argsWithFormat = args.map(function (item) {
	          return String(item);
	        }); // Careful: RN currently depends on this prefix

	        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
	        // breaks IE9: https://github.com/facebook/react/issues/13610
	        // eslint-disable-next-line react-internal/no-production-logging

	        Function.prototype.apply.call(console[level], console, argsWithFormat);
	      }
	    }

	    /**
	     * inlined Object.is polyfill to avoid requiring consumers ship their own
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	     */
	    function is(x, y) {
	      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
	      ;
	    }

	    var objectIs = typeof Object.is === 'function' ? Object.is : is;

	    // dispatch for CommonJS interop named imports.

	    var useState = React.useState,
	      useEffect = React.useEffect,
	      useLayoutEffect = React.useLayoutEffect,
	      useDebugValue = React.useDebugValue;
	    var didWarnOld18Alpha = false;
	    var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works
	    // because of a very particular set of implementation details and assumptions
	    // -- change any one of them and it will break. The most important assumption
	    // is that updates are always synchronous, because concurrent rendering is
	    // only available in versions of React that also have a built-in
	    // useSyncExternalStore API. And we only use this shim when the built-in API
	    // does not exist.
	    //
	    // Do not assume that the clever hacks used by this hook also work in general.
	    // The point of this shim is to replace the need for hacks by other libraries.

	    function useSyncExternalStore(subscribe, getSnapshot,
	    // Note: The shim does not use getServerSnapshot, because pre-18 versions of
	    // React do not expose a way to check if we're hydrating. So users of the shim
	    // will need to track that themselves and return the correct value
	    // from `getSnapshot`.
	    getServerSnapshot) {
	      {
	        if (!didWarnOld18Alpha) {
	          if (React.startTransition !== undefined) {
	            didWarnOld18Alpha = true;
	            error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');
	          }
	        }
	      } // Read the current snapshot from the store on every render. Again, this
	      // breaks the rules of React, and only works here because of specific
	      // implementation details, most importantly that updates are
	      // always synchronous.

	      var value = getSnapshot();
	      {
	        if (!didWarnUncachedGetSnapshot) {
	          var cachedValue = getSnapshot();
	          if (!objectIs(value, cachedValue)) {
	            error('The result of getSnapshot should be cached to avoid an infinite loop');
	            didWarnUncachedGetSnapshot = true;
	          }
	        }
	      } // Because updates are synchronous, we don't queue them. Instead we force a
	      // re-render whenever the subscribed state changes by updating an some
	      // arbitrary useState hook. Then, during render, we call getSnapshot to read
	      // the current value.
	      //
	      // Because we don't actually use the state returned by the useState hook, we
	      // can save a bit of memory by storing other stuff in that slot.
	      //
	      // To implement the early bailout, we need to track some things on a mutable
	      // object. Usually, we would put that in a useRef hook, but we can stash it in
	      // our useState hook instead.
	      //
	      // To force a re-render, we call forceUpdate({inst}). That works because the
	      // new object always fails an equality check.

	      var _useState = useState({
	          inst: {
	            value: value,
	            getSnapshot: getSnapshot
	          }
	        }),
	        inst = _useState[0].inst,
	        forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated
	      // in the layout phase so we can access it during the tearing check that
	      // happens on subscribe.

	      useLayoutEffect(function () {
	        inst.value = value;
	        inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
	        // commit phase if there was an interleaved mutation. In concurrent mode
	        // this can happen all the time, but even in synchronous mode, an earlier
	        // effect may have mutated the store.

	        if (checkIfSnapshotChanged(inst)) {
	          // Force a re-render.
	          forceUpdate({
	            inst: inst
	          });
	        }
	      }, [subscribe, value, getSnapshot]);
	      useEffect(function () {
	        // Check for changes right before subscribing. Subsequent changes will be
	        // detected in the subscription handler.
	        if (checkIfSnapshotChanged(inst)) {
	          // Force a re-render.
	          forceUpdate({
	            inst: inst
	          });
	        }
	        var handleStoreChange = function () {
	          // TODO: Because there is no cross-renderer API for batching updates, it's
	          // up to the consumer of this library to wrap their subscription event
	          // with unstable_batchedUpdates. Should we try to detect when this isn't
	          // the case and print a warning in development?
	          // The store changed. Check if the snapshot changed since the last time we
	          // read from the store.
	          if (checkIfSnapshotChanged(inst)) {
	            // Force a re-render.
	            forceUpdate({
	              inst: inst
	            });
	          }
	        }; // Subscribe to the store and return a clean-up function.

	        return subscribe(handleStoreChange);
	      }, [subscribe]);
	      useDebugValue(value);
	      return value;
	    }
	    function checkIfSnapshotChanged(inst) {
	      var latestGetSnapshot = inst.getSnapshot;
	      var prevValue = inst.value;
	      try {
	        var nextValue = latestGetSnapshot();
	        return !objectIs(prevValue, nextValue);
	      } catch (error) {
	        return true;
	      }
	    }
	    function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
	      // Note: The shim does not use getServerSnapshot, because pre-18 versions of
	      // React do not expose a way to check if we're hydrating. So users of the shim
	      // will need to track that themselves and return the correct value
	      // from `getSnapshot`.
	      return getSnapshot();
	    }
	    var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
	    var isServerEnvironment = !canUseDOM;
	    var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
	    var useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;
	    useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
	    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
	      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
	    }
	  })();
	}
	return useSyncExternalStoreShim_development;
}

var hasRequiredShim;

function requireShim () {
	if (hasRequiredShim) return shim.exports;
	hasRequiredShim = 1;
	(function (module) {

		if (process.env.NODE_ENV === 'production') {
		  module.exports = requireUseSyncExternalStoreShim_production_min();
		} else {
		  module.exports = requireUseSyncExternalStoreShim_development();
		}
} (shim));
	return shim.exports;
}

Object.defineProperty(loadable, "__esModule", {
  value: true
});
loadable.default = void 0;
var _extends$1 = _extends$3.default;
var _interop_require_default = _interop_require_default$2.default;
var _react = _interop_require_default(React__default["default"]);
var _loadableContext = loadableContext;
const {
  useSyncExternalStore
} = process.env.__NEXT_REACT_ROOT ? React__default["default"] : requireShim();
const ALL_INITIALIZERS = [];
const READY_INITIALIZERS = [];
let initialized = false;
function load$1(loader) {
  let promise = loader();
  let state = {
    loading: true,
    loaded: null,
    error: null
  };
  state.promise = promise.then(loaded => {
    state.loading = false;
    state.loaded = loaded;
    return loaded;
  }).catch(err => {
    state.loading = false;
    state.error = err;
    throw err;
  });
  return state;
}
function resolve$1(obj) {
  return obj && obj.__esModule ? obj.default : obj;
}
function createLoadableComponent(loadFn, options) {
  let opts = Object.assign({
    loader: null,
    loading: null,
    delay: 200,
    timeout: null,
    webpack: null,
    modules: null,
    suspense: false
  }, options);
  if (opts.suspense) {
    opts.lazy = _react.default.lazy(opts.loader);
  }
  /** @type LoadableSubscription */
  let subscription = null;
  function init() {
    if (!subscription) {
      const sub = new LoadableSubscription(loadFn, opts);
      subscription = {
        getCurrentValue: sub.getCurrentValue.bind(sub),
        subscribe: sub.subscribe.bind(sub),
        retry: sub.retry.bind(sub),
        promise: sub.promise.bind(sub)
      };
    }
    return subscription.promise();
  }
  // Server only
  if (typeof window === 'undefined') {
    ALL_INITIALIZERS.push(init);
  }
  // Client only
  if (!initialized && typeof window !== 'undefined') {
    // require.resolveWeak check is needed for environments that don't have it available like Jest
    const moduleIds = opts.webpack && typeof commonjsRequire.resolveWeak === 'function' ? opts.webpack() : opts.modules;
    if (moduleIds) {
      READY_INITIALIZERS.push(ids => {
        for (const moduleId of moduleIds) {
          if (ids.indexOf(moduleId) !== -1) {
            return init();
          }
        }
      });
    }
  }
  function useLoadableModule() {
    init();
    const context = _react.default.useContext(_loadableContext.LoadableContext);
    if (context && Array.isArray(opts.modules)) {
      opts.modules.forEach(moduleName => {
        context(moduleName);
      });
    }
  }
  function LoadableImpl(props, ref) {
    useLoadableModule();
    const state = useSyncExternalStore(subscription.subscribe, subscription.getCurrentValue, subscription.getCurrentValue);
    _react.default.useImperativeHandle(ref, () => ({
      retry: subscription.retry
    }), []);
    return _react.default.useMemo(() => {
      if (state.loading || state.error) {
        return _react.default.createElement(opts.loading, {
          isLoading: state.loading,
          pastDelay: state.pastDelay,
          timedOut: state.timedOut,
          error: state.error,
          retry: subscription.retry
        });
      } else if (state.loaded) {
        return _react.default.createElement(resolve$1(state.loaded), props);
      } else {
        return null;
      }
    }, [props, state]);
  }
  function LazyImpl(props, ref) {
    useLoadableModule();
    return _react.default.createElement(opts.lazy, _extends$1({}, props, {
      ref
    }));
  }
  const LoadableComponent = opts.suspense ? LazyImpl : LoadableImpl;
  LoadableComponent.preload = () => init();
  LoadableComponent.displayName = 'LoadableComponent';
  return _react.default.forwardRef(LoadableComponent);
}
class LoadableSubscription {
  promise() {
    return this._res.promise;
  }
  retry() {
    this._clearTimeouts();
    this._res = this._loadFn(this._opts.loader);
    this._state = {
      pastDelay: false,
      timedOut: false
    };
    const {
      _res: res,
      _opts: opts
    } = this;
    if (res.loading) {
      if (typeof opts.delay === 'number') {
        if (opts.delay === 0) {
          this._state.pastDelay = true;
        } else {
          this._delay = setTimeout(() => {
            this._update({
              pastDelay: true
            });
          }, opts.delay);
        }
      }
      if (typeof opts.timeout === 'number') {
        this._timeout = setTimeout(() => {
          this._update({
            timedOut: true
          });
        }, opts.timeout);
      }
    }
    this._res.promise.then(() => {
      this._update({});
      this._clearTimeouts();
    }).catch(_err => {
      this._update({});
      this._clearTimeouts();
    });
    this._update({});
  }
  _update(partial) {
    this._state = _extends$1({}, this._state, {
      error: this._res.error,
      loaded: this._res.loaded,
      loading: this._res.loading
    }, partial);
    this._callbacks.forEach(callback => callback());
  }
  _clearTimeouts() {
    clearTimeout(this._delay);
    clearTimeout(this._timeout);
  }
  getCurrentValue() {
    return this._state;
  }
  subscribe(callback) {
    this._callbacks.add(callback);
    return () => {
      this._callbacks.delete(callback);
    };
  }
  constructor(loadFn, opts) {
    this._loadFn = loadFn;
    this._opts = opts;
    this._callbacks = new Set();
    this._delay = null;
    this._timeout = null;
    this.retry();
  }
}
function Loadable(opts) {
  return createLoadableComponent(load$1, opts);
}
function flushInitializers(initializers, ids) {
  let promises = [];
  while (initializers.length) {
    let init = initializers.pop();
    promises.push(init(ids));
  }
  return Promise.all(promises).then(() => {
    if (initializers.length) {
      return flushInitializers(initializers, ids);
    }
  });
}
Loadable.preloadAll = () => {
  return new Promise((resolveInitializers, reject) => {
    flushInitializers(ALL_INITIALIZERS).then(resolveInitializers, reject);
  });
};
Loadable.preloadReady = (ids = []) => {
  return new Promise(resolvePreload => {
    const res = () => {
      initialized = true;
      return resolvePreload();
    };
    // We always will resolve, errors should be handled within loading UIs.
    flushInitializers(READY_INITIALIZERS, ids).then(res, res);
  });
};
if (typeof window !== 'undefined') {
  window.__NEXT_PRELOADREADY = Loadable.preloadReady;
}
var _default = Loadable;
loadable.default = _default;

(function (module, exports) {
	"client";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = dynamic;
	exports.noSSR = noSSR;
	var _extends = _extends$3.default;
	var _interop_require_default = _interop_require_default$2.default;
	var _react = _interop_require_default(React__default["default"]);
	var _loadable = _interop_require_default(loadable);
	function dynamic(dynamicOptions, options) {
	  let loadableFn = _loadable.default;
	  let loadableOptions = (options == null ? void 0 : options.suspense) ? {} : {
	    // A loading component is not required, so we default it
	    loading: ({
	      error,
	      isLoading,
	      pastDelay
	    }) => {
	      if (!pastDelay) return null;
	      if (process.env.NODE_ENV === 'development') {
	        if (isLoading) {
	          return null;
	        }
	        if (error) {
	          return /*#__PURE__*/_react.default.createElement("p", null, error.message, /*#__PURE__*/_react.default.createElement("br", null), error.stack);
	        }
	      }
	      return null;
	    }
	  };
	  // Support for direct import(), eg: dynamic(import('../hello-world'))
	  // Note that this is only kept for the edge case where someone is passing in a promise as first argument
	  // The react-loadable babel plugin will turn dynamic(import('../hello-world')) into dynamic(() => import('../hello-world'))
	  // To make sure we don't execute the import without rendering first
	  if (dynamicOptions instanceof Promise) {
	    loadableOptions.loader = () => dynamicOptions;
	    // Support for having import as a function, eg: dynamic(() => import('../hello-world'))
	  } else if (typeof dynamicOptions === 'function') {
	    loadableOptions.loader = dynamicOptions;
	    // Support for having first argument being options, eg: dynamic({loader: import('../hello-world')})
	  } else if (typeof dynamicOptions === 'object') {
	    loadableOptions = _extends({}, loadableOptions, dynamicOptions);
	  }
	  // Support for passing options, eg: dynamic(import('../hello-world'), {loading: () => <p>Loading something</p>})
	  loadableOptions = _extends({}, loadableOptions, options);
	  // Error if Fizz rendering is not enabled and `suspense` option is set to true
	  if (!process.env.__NEXT_REACT_ROOT && loadableOptions.suspense) {
	    throw new Error(`Invalid suspense option usage in next/dynamic. Read more: https://nextjs.org/docs/messages/invalid-dynamic-suspense`);
	  }
	  if (loadableOptions.suspense) {
	    if (process.env.NODE_ENV !== 'production') {
	      /**
	      * TODO: Currently, next/dynamic will opt-in to React.lazy if { suspense: true } is used
	      * React 18 will always resolve the Suspense boundary on the server-side, effectively ignoring the ssr option
	      *
	      * In the future, when React Suspense with third-party libraries is stable, we can implement a custom version of
	      * React.lazy that can suspense on the server-side while only loading the component on the client-side
	      */
	      if (loadableOptions.ssr === false) {
	        console.warn(`"ssr: false" is ignored by next/dynamic because you can not enable "suspense" while disabling "ssr" at the same time. Read more: https://nextjs.org/docs/messages/invalid-dynamic-suspense`);
	      }
	      if (loadableOptions.loading != null) {
	        console.warn(`"loading" is ignored by next/dynamic because you have enabled "suspense". Place your loading element in your suspense boundary's "fallback" prop instead. Read more: https://nextjs.org/docs/messages/invalid-dynamic-suspense`);
	      }
	    }
	    delete loadableOptions.ssr;
	    delete loadableOptions.loading;
	  }
	  // coming from build/babel/plugins/react-loadable-plugin.js
	  if (loadableOptions.loadableGenerated) {
	    loadableOptions = _extends({}, loadableOptions, loadableOptions.loadableGenerated);
	    delete loadableOptions.loadableGenerated;
	  }
	  // support for disabling server side rendering, eg: dynamic(import('../hello-world'), {ssr: false}).
	  // skip `ssr` for suspense mode and opt-in React.lazy directly
	  if (typeof loadableOptions.ssr === 'boolean' && !loadableOptions.suspense) {
	    if (!loadableOptions.ssr) {
	      delete loadableOptions.ssr;
	      return noSSR(loadableFn, loadableOptions);
	    }
	    delete loadableOptions.ssr;
	  }
	  return loadableFn(loadableOptions);
	}
	const isServerSide = typeof window === 'undefined';
	function noSSR(LoadableInitializer, loadableOptions) {
	  // Removing webpack and modules means react-loadable won't try preloading
	  delete loadableOptions.webpack;
	  delete loadableOptions.modules;
	  // This check is necessary to prevent react-loadable from initializing on the server
	  if (!isServerSide) {
	    return LoadableInitializer(loadableOptions);
	  }
	  const Loading = loadableOptions.loading;
	  // This will only be rendered on the server side
	  return () => /*#__PURE__*/_react.default.createElement(Loading, {
	    error: null,
	    isLoading: true,
	    pastDelay: false,
	    timedOut: false
	  });
	}
	if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
	  Object.defineProperty(exports.default, '__esModule', {
	    value: true
	  });
	  Object.assign(exports.default, exports);
	  module.exports = exports.default;
	}
} (dynamic$2, dynamic$2.exports));

(function (module) {
	module.exports = dynamic$2.exports;
} (dynamic$3));

var dynamic$1 = /*@__PURE__*/getDefaultExportFromCjs(dynamic$3.exports);

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = target => __defProp(target, "__esModule", {
  value: true
});
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = {
    exports: {}
  }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all) __defProp(target, name, {
    get: all[name],
    enumerable: true
  });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module)) if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
      get: () => module[key],
      enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable
    });
  }
  return target;
};
var __toModule = module => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {
    get: () => module.default,
    enumerable: true
  } : {
    value: module,
    enumerable: true
  })), module);
};

// src/grammar/tag.js
var require_tag = __commonJS({
  "src/grammar/tag.js"(exports, module) {

    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function (expected, found, location) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function (expectation) {
          var escapedParts = expectation.parts.map(function (part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function () {
          return "any character";
        },
        end: function () {
          return "end of input";
        },
        other: function (expectation) {
          return expectation.description;
        },
        not: function (expectation) {
          return "not " + describeExpectation(expectation.expected);
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$startRuleFunctions = {
        Top: peg$parseTop
      };
      var peg$startRuleFunction = peg$parseTop;
      var peg$c0 = "/";
      var peg$c1 = ".";
      var peg$c2 = "#";
      var peg$c3 = "=";
      var peg$c4 = "(";
      var peg$c5 = ")";
      var peg$c6 = ",";
      var peg$c7 = "[";
      var peg$c8 = "]";
      var peg$c9 = "null";
      var peg$c10 = "true";
      var peg$c11 = "false";
      var peg$c12 = "{";
      var peg$c13 = "}";
      var peg$c14 = ":";
      var peg$c16 = '"';
      var peg$c17 = "\\";
      var peg$r0 = /^[$@]/;
      var peg$r1 = /^[0-9]/;
      var peg$r2 = /^[^\0-\x1F"\\]/;
      var peg$r3 = /^[a-zA-Z0-9_\-]/;
      var peg$r4 = /^[ \n\t]/;
      var peg$e0 = peg$literalExpectation("/", false);
      var peg$e1 = peg$otherExpectation("tag name");
      var peg$e2 = peg$otherExpectation("class");
      var peg$e3 = peg$otherExpectation("id");
      var peg$e4 = peg$literalExpectation("=", false);
      var peg$e5 = peg$literalExpectation("(", false);
      var peg$e6 = peg$literalExpectation(")", false);
      var peg$e7 = peg$literalExpectation(",", false);
      var peg$e8 = peg$otherExpectation("variable");
      var peg$e9 = peg$otherExpectation("null");
      var peg$e10 = peg$otherExpectation("boolean");
      var peg$e11 = peg$literalExpectation("[", false);
      var peg$e12 = peg$literalExpectation("]", false);
      var peg$e13 = peg$literalExpectation("{", false);
      var peg$e14 = peg$literalExpectation("}", false);
      var peg$e15 = peg$literalExpectation(":", false);
      var peg$e16 = peg$otherExpectation("number");
      var peg$e17 = peg$otherExpectation("string");
      var peg$e18 = peg$otherExpectation("identifier");
      var peg$e19 = peg$otherExpectation("whitespace");
      var peg$f0 = function (variable) {
        return {
          type: "variable",
          meta: {
            variable
          }
        };
      };
      var peg$f1 = function (attributes) {
        return {
          type: "annotation",
          meta: {
            attributes
          }
        };
      };
      var peg$f2 = function (tag, value) {
        return value;
      };
      var peg$f3 = function (tag, primary, attributes, close) {
        if (primary) {
          attributes = attributes || [];
          attributes.unshift({
            type: "attribute",
            name: "primary",
            value: primary
          });
        }
        const [type, nesting] = close ? ["tag", 0] : ["tag_open", 1];
        return {
          type,
          nesting,
          meta: {
            tag,
            attributes
          }
        };
      };
      var peg$f4 = function (tag) {
        return {
          type: "tag_close",
          nesting: -1,
          meta: {
            tag
          }
        };
      };
      var peg$f5 = function (head, tail) {
        return !head ? [] : [head, ...tail];
      };
      var peg$f6 = function (item2) {
        return item2;
      };
      var peg$f7 = function (ids) {
        return ids;
      };
      var peg$f8 = function (classes) {
        return classes;
      };
      var peg$f9 = function (attribute) {
        return attribute;
      };
      var peg$f10 = function (name) {
        return {
          type: "class",
          name,
          value: true
        };
      };
      var peg$f11 = function (value) {
        return {
          type: "attribute",
          name: "id",
          value
        };
      };
      var peg$f12 = function (name, value) {
        return {
          type: "attribute",
          name,
          value
        };
      };
      var peg$f13 = function (name, head, tail) {
        return head ? [head, ...tail] : [];
      };
      var peg$f14 = function (name, params) {
        let parameters = {};
        for (let [index, {
          name: name2,
          value
        }] of params.entries()) parameters[name2 || index] = value;
        return new Function3(name, parameters);
      };
      var peg$f15 = function (name) {
        return name;
      };
      var peg$f16 = function (name, value) {
        return {
          name,
          value
        };
      };
      var peg$f17 = function (value) {
        return value;
      };
      var peg$f18 = function (prefix, head, tail) {
        if (prefix === "@") return [head, ...tail];
        return new Variable2([head, ...tail]);
      };
      var peg$f19 = function () {
        return null;
      };
      var peg$f20 = function () {
        return true;
      };
      var peg$f21 = function () {
        return false;
      };
      var peg$f22 = function (head, tail) {
        return [head, ...tail];
      };
      var peg$f23 = function (value) {
        return value || [];
      };
      var peg$f24 = function (head, tail) {
        return Object.assign(head, ...tail);
      };
      var peg$f25 = function (value) {
        return value || {};
      };
      var peg$f26 = function (key, value) {
        return key === "$$mdtype" ? {} : {
          [key]: value
        };
      };
      var peg$f27 = function () {
        return parseFloat(text2());
      };
      var peg$f28 = function (value) {
        return value.join("");
      };
      var peg$f29 = function (sequence) {
        return sequence;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{
        line: 1,
        column: 1
      }];
      var peg$expected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text2() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function peg$literalExpectation(text3, ignoreCase) {
        return {
          type: "literal",
          text: text3,
          ignoreCase
        };
      }
      function peg$endExpectation() {
        return {
          type: "end"
        };
      }
      function peg$otherExpectation(description) {
        return {
          type: "other",
          description
        };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      var peg$VALIDFILENAME = typeof options.filename === "string" && options.filename.length > 0;
      function peg$computeLocation(startPos, endPos) {
        var loc = {};
        if (peg$VALIDFILENAME) loc.filename = options.filename;
        var startPosDetails = peg$computePosDetails(startPos);
        loc.start = {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        };
        var endPosDetails = peg$computePosDetails(endPos);
        loc.end = {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        };
        return loc;
      }
      function peg$begin() {
        peg$expected.push({
          pos: peg$currPos,
          variants: []
        });
      }
      function peg$expect(expected2) {
        var top = peg$expected[peg$expected.length - 1];
        if (peg$currPos < top.pos) {
          return;
        }
        if (peg$currPos > top.pos) {
          top.pos = peg$currPos;
          top.variants = [];
        }
        top.variants.push(expected2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found, location2), expected2, found, location2);
      }
      function peg$buildError() {
        var expected2 = peg$expected[0];
        var failPos = expected2.pos;
        return peg$buildStructuredError(expected2.variants, failPos < input.length ? input.charAt(failPos) : null, failPos < input.length ? peg$computeLocation(failPos, failPos + 1) : peg$computeLocation(failPos, failPos));
      }
      function peg$parseTop() {
        var s0;
        s0 = peg$parseTopLevelValue();
        if (s0 === peg$FAILED) {
          s0 = peg$parseAnnotation();
          if (s0 === peg$FAILED) {
            s0 = peg$parseTagOpen();
            if (s0 === peg$FAILED) {
              s0 = peg$parseTagClose();
            }
          }
        }
        return s0;
      }
      function peg$parseTopLevelValue() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 === peg$FAILED) {
          s1 = peg$parseFunction();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseAnnotation() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseTagAttributes();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f1(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagOpen() {
        var s0, s1, s2, s3, s4, s5, s6;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagName();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          s3 = peg$currPos;
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            peg$savedPos = s3;
            s3 = peg$f2(s1, s4);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = peg$parseTagAttributes();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          s5 = [];
          s6 = peg$parse_();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parse_();
          }
          rule$expects(peg$e0);
          if (input.charCodeAt(peg$currPos) === 47) {
            s6 = peg$c0;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
          }
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s3, s4, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagClose() {
        var s0, s1, s2;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e0);
        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseTagName();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagName() {
        var s0;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        rule$expects(peg$e1);
        peg$silentFails++;
        s0 = peg$parseIdentifier();
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagAttributes() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseTagAttributesItem();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseTagAttributesTail();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseTagAttributesTail();
          }
          peg$savedPos = s0;
          s0 = peg$f5(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagAttributesTail() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseTagAttributesItem();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagAttributesItem() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseTagShortcutId();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f7(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseTagShortcutClass();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseTagAttribute();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f9(s1);
            }
            s0 = s1;
          }
        }
        return s0;
      }
      function peg$parseTagShortcutClass() {
        var s0, s1, s2;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        rule$expects(peg$e2);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f10(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagShortcutId() {
        var s0, s1, s2;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        rule$expects(peg$e3);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagAttribute() {
        var s0, s1, s2, s3;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e4);
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c3;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseValue();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f12(s1, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunction() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e5);
          if (input.charCodeAt(peg$currPos) === 40) {
            s2 = peg$c4;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            s4 = peg$currPos;
            s5 = peg$parseFunctionParameter();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            s6 = [];
            s7 = peg$parseFunctionParameterTail();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parseFunctionParameterTail();
            }
            peg$savedPos = s4;
            s4 = peg$f13(s1, s5, s6);
            rule$expects(peg$e6);
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c5;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f14(s1, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunctionParameter() {
        var s0, s1, s2, s3;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseIdentifier();
        if (s2 !== peg$FAILED) {
          rule$expects(peg$e4);
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c3;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f15(s2);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$parseValue();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f16(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunctionParameterTail() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseFunctionParameter();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTrailingComma() {
        var s0, s1, s2;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        return s0;
      }
      function peg$parseVariable() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        rule$expects(peg$e8);
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseVariableTail();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseVariableTail();
            }
            peg$savedPos = s0;
            s0 = peg$f18(s1, s2, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseVariableTail() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseValueNumber();
            if (s2 === peg$FAILED) {
              s2 = peg$parseValueString();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c8;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f17(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseValue() {
        var s0;
        s0 = peg$parseValueNull();
        if (s0 === peg$FAILED) {
          s0 = peg$parseValueBoolean();
          if (s0 === peg$FAILED) {
            s0 = peg$parseValueString();
            if (s0 === peg$FAILED) {
              s0 = peg$parseValueNumber();
              if (s0 === peg$FAILED) {
                s0 = peg$parseValueArray();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseValueHash();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseFunction();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseVariable();
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parseValueNull() {
        var s0, s1;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        rule$expects(peg$e9);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c9) {
          s1 = peg$c9;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f19();
        }
        s0 = s1;
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueBoolean() {
        var s0, s1;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        rule$expects(peg$e10);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c10) {
          s1 = peg$c10;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f20();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c11) {
            s1 = peg$c11;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f21();
          }
          s0 = s1;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueArray() {
        var s0, s1, s2, s3, s4, s5, s6;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e11);
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          s3 = peg$currPos;
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseValueArrayTail();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseValueArrayTail();
            }
            s6 = peg$parseTrailingComma();
            peg$savedPos = s3;
            s3 = peg$f22(s4, s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          rule$expects(peg$e12);
          if (input.charCodeAt(peg$currPos) === 93) {
            s5 = peg$c8;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueArrayTail() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHash() {
        var s0, s1, s2, s3, s4, s5, s6;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e13);
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          s3 = peg$currPos;
          s4 = peg$parseValueHashItem();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseValueHashTail();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseValueHashTail();
            }
            s6 = peg$parseTrailingComma();
            peg$savedPos = s3;
            s3 = peg$f24(s4, s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          rule$expects(peg$e14);
          if (input.charCodeAt(peg$currPos) === 125) {
            s5 = peg$c13;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHashTail() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseValueHashItem();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHashItem() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 === peg$FAILED) {
          s1 = peg$parseValueString();
        }
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e15);
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c14;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            s4 = peg$parseValue();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f26(s1, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueNumber() {
        var s0, s2, s3, s4, s5, s6;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        rule$expects(peg$e16);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          peg$currPos++;
        }
        s2 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c1;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f27();
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueString() {
        var s0, s1, s2, s3;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        rule$expects(peg$e17);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseValueStringChars();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseValueStringChars();
          }
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c16;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f28(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueStringChars() {
        var s0;
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseValueStringEscapes();
        }
        return s0;
      }
      function peg$parseValueStringEscapes() {
        var s0, s1, s2;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c17;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c16;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 92) {
              s2 = peg$c17;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseIdentifier() {
        var s0, s1, s2;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        rule$expects(peg$e18);
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parse_() {
        var s0;
        var rule$expects = function (expected2) {
          if (peg$silentFails === 0) peg$expect(expected2);
        };
        rule$expects(peg$e19);
        peg$silentFails++;
        if (peg$r4.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      const {
        Variable: Variable2,
        Function: Function3
      } = options;
      peg$begin();
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$expect(peg$endExpectation());
        }
        throw peg$buildError();
      }
    }
    module.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});

// node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/entities/lib/maps/entities.json"(exports, module) {
    module.exports = {
      Aacute: "\xC1",
      aacute: "\xE1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\xC6",
      aelig: "\xE6",
      af: "\u2061",
      Afr: "\u{1D504}",
      afr: "\u{1D51E}",
      Agrave: "\xC0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      amp: "&",
      AMP: "&",
      andand: "\u2A55",
      And: "\u2A53",
      and: "\u2227",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angmsd: "\u2221",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\u{1D538}",
      aopf: "\u{1D552}",
      apacir: "\u2A6F",
      ap: "\u2248",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\xC5",
      aring: "\xE5",
      Ascr: "\u{1D49C}",
      ascr: "\u{1D4B6}",
      Assign: "\u2254",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\xC3",
      atilde: "\xE3",
      Auml: "\xC4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      barwed: "\u2305",
      Barwed: "\u2306",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      because: "\u2235",
      Because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\u{1D505}",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\u{1D539}",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxdl: "\u2510",
      boxdL: "\u2555",
      boxDl: "\u2556",
      boxDL: "\u2557",
      boxdr: "\u250C",
      boxdR: "\u2552",
      boxDr: "\u2553",
      boxDR: "\u2554",
      boxh: "\u2500",
      boxH: "\u2550",
      boxhd: "\u252C",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxHD: "\u2566",
      boxhu: "\u2534",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxHU: "\u2569",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxul: "\u2518",
      boxuL: "\u255B",
      boxUl: "\u255C",
      boxUL: "\u255D",
      boxur: "\u2514",
      boxuR: "\u2558",
      boxUr: "\u2559",
      boxUR: "\u255A",
      boxv: "\u2502",
      boxV: "\u2551",
      boxvh: "\u253C",
      boxvH: "\u256A",
      boxVh: "\u256B",
      boxVH: "\u256C",
      boxvl: "\u2524",
      boxvL: "\u2561",
      boxVl: "\u2562",
      boxVL: "\u2563",
      boxvr: "\u251C",
      boxvR: "\u255E",
      boxVr: "\u255F",
      boxVR: "\u2560",
      bprime: "\u2035",
      breve: "\u02D8",
      Breve: "\u02D8",
      brvbar: "\xA6",
      bscr: "\u{1D4B7}",
      Bscr: "\u212C",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsolb: "\u29C5",
      bsol: "\\",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      cap: "\u2229",
      Cap: "\u22D2",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\xB8",
      Cedilla: "\xB8",
      cemptyv: "\u29B2",
      cent: "\xA2",
      centerdot: "\xB7",
      CenterDot: "\xB7",
      cfr: "\u{1D520}",
      Cfr: "\u212D",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\xAE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cir: "\u25CB",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      colon: ":",
      Colon: "\u2237",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      conint: "\u222E",
      Conint: "\u222F",
      ContourIntegral: "\u222E",
      copf: "\u{1D554}",
      Copf: "\u2102",
      coprod: "\u2210",
      Coproduct: "\u2210",
      copy: "\xA9",
      COPY: "\xA9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      cross: "\u2717",
      Cross: "\u2A2F",
      Cscr: "\u{1D49E}",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      cupbrcap: "\u2A48",
      cupcap: "\u2A46",
      CupCap: "\u224D",
      cup: "\u222A",
      Cup: "\u22D3",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      dagger: "\u2020",
      Dagger: "\u2021",
      daleth: "\u2138",
      darr: "\u2193",
      Darr: "\u21A1",
      dArr: "\u21D3",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DD: "\u2145",
      dd: "\u2146",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\xB0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\u{1D507}",
      dfr: "\u{1D521}",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      diamond: "\u22C4",
      Diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      Dopf: "\u{1D53B}",
      dopf: "\u{1D555}",
      Dot: "\xA8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrowBar: "\u2913",
      downarrow: "\u2193",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVectorBar: "\u2956",
      DownLeftVector: "\u21BD",
      DownRightTeeVector: "\u295F",
      DownRightVectorBar: "\u2957",
      DownRightVector: "\u21C1",
      DownTeeArrow: "\u21A7",
      DownTee: "\u22A4",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\u{1D49F}",
      dscr: "\u{1D4B9}",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\xC9",
      eacute: "\xE9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      ecir: "\u2256",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      edot: "\u0117",
      eDot: "\u2251",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\u{1D508}",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      Egrave: "\xC8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp13: "\u2004",
      emsp14: "\u2005",
      emsp: "\u2003",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\u{1D53C}",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "=",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      escr: "\u212F",
      Escr: "\u2130",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\xD0",
      eth: "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      exponentiale: "\u2147",
      ExponentialE: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\u{1D509}",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\u{1D53D}",
      fopf: "\u{1D557}",
      forall: "\u2200",
      ForAll: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      fscr: "\u{1D4BB}",
      Fscr: "\u2131",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      ge: "\u2265",
      gE: "\u2267",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      gescc: "\u2AA9",
      ges: "\u2A7E",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\u{1D50A}",
      gfr: "\u{1D524}",
      gg: "\u226B",
      Gg: "\u22D9",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gla: "\u2AA5",
      gl: "\u2277",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gne: "\u2A88",
      gnE: "\u2269",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\u{1D53E}",
      gopf: "\u{1D558}",
      grave: "`",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gt: ">",
      GT: ">",
      Gt: "\u226B",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      harrcir: "\u2948",
      harr: "\u2194",
      hArr: "\u21D4",
      harrw: "\u21AD",
      Hat: "^",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      hfr: "\u{1D525}",
      Hfr: "\u210C",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      hopf: "\u{1D559}",
      Hopf: "\u210D",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      hscr: "\u{1D4BD}",
      Hscr: "\u210B",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\xCD",
      iacute: "\xED",
      ic: "\u2063",
      Icirc: "\xCE",
      icirc: "\xEE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\xA1",
      iff: "\u21D4",
      ifr: "\u{1D526}",
      Ifr: "\u2111",
      Igrave: "\xCC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      Im: "\u2111",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      incare: "\u2105",
      in: "\u2208",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      intcal: "\u22BA",
      int: "\u222B",
      Int: "\u222C",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\u{1D540}",
      iopf: "\u{1D55A}",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\xBF",
      iscr: "\u{1D4BE}",
      Iscr: "\u2110",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\xCF",
      iuml: "\xEF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\u{1D50D}",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      Jopf: "\u{1D541}",
      jopf: "\u{1D55B}",
      Jscr: "\u{1D4A5}",
      jscr: "\u{1D4BF}",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\u{1D50E}",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\u{1D542}",
      kopf: "\u{1D55C}",
      Kscr: "\u{1D4A6}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      lang: "\u27E8",
      Lang: "\u27EA",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\xAB",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larr: "\u2190",
      Larr: "\u219E",
      lArr: "\u21D0",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      latail: "\u2919",
      lAtail: "\u291B",
      lat: "\u2AAB",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lbarr: "\u290C",
      lBarr: "\u290E",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      le: "\u2264",
      lE: "\u2266",
      LeftAngleBracket: "\u27E8",
      LeftArrowBar: "\u21E4",
      leftarrow: "\u2190",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVectorBar: "\u2959",
      LeftDownVector: "\u21C3",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      leftrightarrow: "\u2194",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTeeArrow: "\u21A4",
      LeftTee: "\u22A3",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangleBar: "\u29CF",
      LeftTriangle: "\u22B2",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVectorBar: "\u2958",
      LeftUpVector: "\u21BF",
      LeftVectorBar: "\u2952",
      LeftVector: "\u21BC",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      lescc: "\u2AA8",
      les: "\u2A7D",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\u{1D50F}",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      llarr: "\u21C7",
      ll: "\u226A",
      Ll: "\u22D8",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoustache: "\u23B0",
      lmoust: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lne: "\u2A87",
      lnE: "\u2268",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      longleftarrow: "\u27F5",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftrightarrow: "\u27F7",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longmapsto: "\u27FC",
      longrightarrow: "\u27F6",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\u{1D543}",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      lscr: "\u{1D4C1}",
      Lscr: "\u2112",
      lsh: "\u21B0",
      Lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      lt: "<",
      LT: "<",
      Lt: "\u226A",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micro: "\xB5",
      midast: "*",
      midcir: "\u2AF0",
      mid: "\u2223",
      middot: "\xB7",
      minusb: "\u229F",
      minus: "\u2212",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\u{1D544}",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      mscr: "\u{1D4C2}",
      Mscr: "\u2133",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natural: "\u266E",
      naturals: "\u2115",
      natur: "\u266E",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      nearhk: "\u2924",
      nearr: "\u2197",
      neArr: "\u21D7",
      nearrow: "\u2197",
      ne: "\u2260",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\u{1D511}",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nharr: "\u21AE",
      nhArr: "\u21CE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlarr: "\u219A",
      nlArr: "\u21CD",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nleftarrow: "\u219A",
      nLeftarrow: "\u21CD",
      nleftrightarrow: "\u21AE",
      nLeftrightarrow: "\u21CE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      nopf: "\u{1D55F}",
      Nopf: "\u2115",
      Not: "\u2AEC",
      not: "\xAC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangle: "\u22EB",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      nparallel: "\u2226",
      npar: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      npre: "\u2AAF\u0338",
      nrarrc: "\u2933\u0338",
      nrarr: "\u219B",
      nrArr: "\u21CF",
      nrarrw: "\u219D\u0338",
      nrightarrow: "\u219B",
      nRightarrow: "\u21CF",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\u{1D4A9}",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nvdash: "\u22AC",
      nvDash: "\u22AD",
      nVdash: "\u22AE",
      nVDash: "\u22AF",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwarr: "\u2196",
      nwArr: "\u21D6",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\xD3",
      oacute: "\xF3",
      oast: "\u229B",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      ocir: "\u229A",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\u{1D512}",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      Ograve: "\xD2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\u{1D546}",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      orarr: "\u21BB",
      Or: "\u2A54",
      or: "\u2228",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\u{1D4AA}",
      oscr: "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      osol: "\u2298",
      Otilde: "\xD5",
      otilde: "\xF5",
      otimesas: "\u2A36",
      Otimes: "\u2A37",
      otimes: "\u2297",
      Ouml: "\xD6",
      ouml: "\xF6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      para: "\xB6",
      parallel: "\u2225",
      par: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\u{1D513}",
      pfr: "\u{1D52D}",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plus: "+",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      popf: "\u{1D561}",
      Popf: "\u2119",
      pound: "\xA3",
      prap: "\u2AB7",
      Pr: "\u2ABB",
      pr: "\u227A",
      prcue: "\u227C",
      precapprox: "\u2AB7",
      prec: "\u227A",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      pre: "\u2AAF",
      prE: "\u2AB3",
      precsim: "\u227E",
      prime: "\u2032",
      Prime: "\u2033",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportional: "\u221D",
      Proportion: "\u2237",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\u{1D4AB}",
      pscr: "\u{1D4C5}",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\u{1D514}",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      qopf: "\u{1D562}",
      Qopf: "\u211A",
      qprime: "\u2057",
      Qscr: "\u{1D4AC}",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      quot: '"',
      QUOT: '"',
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      rang: "\u27E9",
      Rang: "\u27EB",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\xBB",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarr: "\u2192",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      ratail: "\u291A",
      rAtail: "\u291C",
      ratio: "\u2236",
      rationals: "\u211A",
      rbarr: "\u290D",
      rBarr: "\u290F",
      RBarr: "\u2910",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      Re: "\u211C",
      rect: "\u25AD",
      reg: "\xAE",
      REG: "\xAE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      rfr: "\u{1D52F}",
      Rfr: "\u211C",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrowBar: "\u21E5",
      rightarrow: "\u2192",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVectorBar: "\u2955",
      RightDownVector: "\u21C2",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTeeArrow: "\u21A6",
      RightTee: "\u22A2",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangleBar: "\u29D0",
      RightTriangle: "\u22B3",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVectorBar: "\u2954",
      RightUpVector: "\u21BE",
      RightVectorBar: "\u2953",
      RightVector: "\u21C0",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoustache: "\u23B1",
      rmoust: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      ropf: "\u{1D563}",
      Ropf: "\u211D",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      rscr: "\u{1D4C7}",
      Rscr: "\u211B",
      rsh: "\u21B1",
      Rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      Sc: "\u2ABC",
      sc: "\u227B",
      sccue: "\u227D",
      sce: "\u2AB0",
      scE: "\u2AB4",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdotb: "\u22A1",
      sdot: "\u22C5",
      sdote: "\u2A66",
      searhk: "\u2925",
      searr: "\u2198",
      seArr: "\u21D8",
      searrow: "\u2198",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\u{1D516}",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\xAD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      solbar: "\u233F",
      solb: "\u29C4",
      sol: "/",
      Sopf: "\u{1D54A}",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      square: "\u25A1",
      Square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squ: "\u25A1",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\u{1D4AE}",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      sub: "\u2282",
      Sub: "\u22D0",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      subset: "\u2282",
      Subset: "\u22D0",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succapprox: "\u2AB8",
      succ: "\u227B",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      sum: "\u2211",
      Sum: "\u2211",
      sung: "\u266A",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      sup: "\u2283",
      Sup: "\u22D1",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      supset: "\u2283",
      Supset: "\u22D1",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swarr: "\u2199",
      swArr: "\u21D9",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\xDF",
      Tab: "	",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\u{1D517}",
      tfr: "\u{1D531}",
      there4: "\u2234",
      therefore: "\u2234",
      Therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      ThinSpace: "\u2009",
      thinsp: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\xDE",
      thorn: "\xFE",
      tilde: "\u02DC",
      Tilde: "\u223C",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      timesbar: "\u2A31",
      timesb: "\u22A0",
      times: "\xD7",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      topbot: "\u2336",
      topcir: "\u2AF1",
      top: "\u22A4",
      Topf: "\u{1D54B}",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      trade: "\u2122",
      TRADE: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\u{1D4AF}",
      tscr: "\u{1D4C9}",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\xDA",
      uacute: "\xFA",
      uarr: "\u2191",
      Uarr: "\u219F",
      uArr: "\u21D1",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\u{1D518}",
      ufr: "\u{1D532}",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\xA8",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\u{1D54C}",
      uopf: "\u{1D566}",
      UpArrowBar: "\u2912",
      uparrow: "\u2191",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      UpArrowDownArrow: "\u21C5",
      updownarrow: "\u2195",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      upsi: "\u03C5",
      Upsi: "\u03D2",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTeeArrow: "\u21A5",
      UpTee: "\u22A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\u{1D4B0}",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\xDC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      varr: "\u2195",
      vArr: "\u21D5",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      vBar: "\u2AE8",
      Vbar: "\u2AEB",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      vdash: "\u22A2",
      vDash: "\u22A8",
      Vdash: "\u22A9",
      VDash: "\u22AB",
      Vdashl: "\u2AE6",
      veebar: "\u22BB",
      vee: "\u2228",
      Vee: "\u22C1",
      veeeq: "\u225A",
      vellip: "\u22EE",
      verbar: "|",
      Verbar: "\u2016",
      vert: "|",
      Vert: "\u2016",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\u{1D54D}",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\u{1D4B1}",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      wedge: "\u2227",
      Wedge: "\u22C0",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\u{1D51A}",
      wfr: "\u{1D534}",
      Wopf: "\u{1D54E}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\u{1D4B2}",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\u{1D51B}",
      xfr: "\u{1D535}",
      xharr: "\u27F7",
      xhArr: "\u27FA",
      Xi: "\u039E",
      xi: "\u03BE",
      xlarr: "\u27F5",
      xlArr: "\u27F8",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\u{1D54F}",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrarr: "\u27F6",
      xrArr: "\u27F9",
      Xscr: "\u{1D4B3}",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\xDD",
      yacute: "\xFD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\xA5",
      Yfr: "\u{1D51C}",
      yfr: "\u{1D536}",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\u{1D550}",
      yopf: "\u{1D56A}",
      Yscr: "\u{1D4B4}",
      yscr: "\u{1D4CE}",
      YUcy: "\u042E",
      yucy: "\u044E",
      yuml: "\xFF",
      Yuml: "\u0178",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      zfr: "\u{1D537}",
      Zfr: "\u2128",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      zopf: "\u{1D56B}",
      Zopf: "\u2124",
      Zscr: "\u{1D4B5}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    };
  }
});

// node_modules/markdown-it/lib/common/entities.js
var require_entities2 = __commonJS({
  "node_modules/markdown-it/lib/common/entities.js"(exports, module) {

    module.exports = require_entities();
  }
});

// node_modules/uc.micro/categories/P/regex.js
var require_regex = __commonJS({
  "node_modules/uc.micro/categories/P/regex.js"(exports, module) {
    module.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});

// node_modules/mdurl/encode.js
var require_encode = __commonJS({
  "node_modules/mdurl/encode.js"(exports, module) {

    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i,
        ch,
        cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i = 0; i < exclude.length; i++) {
        cache[exclude.charCodeAt(i)] = exclude[i];
      }
      return cache;
    }
    function encode(string, exclude, keepEscaped) {
      var i,
        l,
        code2,
        nextCode,
        cache,
        result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache(exclude);
      for (i = 0, l = string.length; i < l; i++) {
        code2 = string.charCodeAt(i);
        if (keepEscaped && code2 === 37 && i + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
            result += string.slice(i, i + 3);
            i += 2;
            continue;
          }
        }
        if (code2 < 128) {
          result += cache[code2];
          continue;
        }
        if (code2 >= 55296 && code2 <= 57343) {
          if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
            nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i] + string[i + 1]);
              i++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i]);
      }
      return result;
    }
    encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode.componentChars = "-_.!~*'()";
    module.exports = encode;
  }
});

// node_modules/mdurl/decode.js
var require_decode = __commonJS({
  "node_modules/mdurl/decode.js"(exports, module) {

    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i,
        ch,
        cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        cache.push(ch);
      }
      for (i = 0; i < exclude.length; i++) {
        ch = exclude.charCodeAt(i);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode(string, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode.defaultChars;
      }
      cache = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
        var i,
          l,
          b1,
          b2,
          b3,
          b4,
          chr,
          result = "";
        for (i = 0, l = seq.length; i < l; i += 3) {
          b1 = parseInt(seq.slice(i + 1, i + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i + 3 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i + 6 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "\uFFFD\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i + 9 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            b4 = parseInt(seq.slice(i + 10, i + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "\uFFFD\uFFFD\uFFFD\uFFFD";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i += 9;
              continue;
            }
          }
          result += "\uFFFD";
        }
        return result;
      });
    }
    decode.defaultChars = ";/?:@&=+$,#";
    decode.componentChars = "";
    module.exports = decode;
  }
});

// node_modules/mdurl/format.js
var require_format = __commonJS({
  "node_modules/mdurl/format.js"(exports, module) {

    module.exports = function format2(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
  }
});

// node_modules/mdurl/parse.js
var require_parse = __commonJS({
  "node_modules/mdurl/parse.js"(exports, module) {

    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function (url, slashesDenoteHost) {
      var i,
        l,
        lowerProto,
        hec,
        slashes,
        rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i = 0; i < hostEndingChars.length; i++) {
          hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i = 0; i < nonHostChars.length; i++) {
          hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function (host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module.exports = urlParse;
  }
});

// node_modules/mdurl/index.js
var require_mdurl = __commonJS({
  "node_modules/mdurl/index.js"(exports, module) {

    module.exports.encode = require_encode();
    module.exports.decode = require_decode();
    module.exports.format = require_format();
    module.exports.parse = require_parse();
  }
});

// node_modules/uc.micro/properties/Any/regex.js
var require_regex2 = __commonJS({
  "node_modules/uc.micro/properties/Any/regex.js"(exports, module) {
    module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});

// node_modules/uc.micro/categories/Cc/regex.js
var require_regex3 = __commonJS({
  "node_modules/uc.micro/categories/Cc/regex.js"(exports, module) {
    module.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});

// node_modules/uc.micro/categories/Cf/regex.js
var require_regex4 = __commonJS({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports, module) {
    module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});

// node_modules/uc.micro/categories/Z/regex.js
var require_regex5 = __commonJS({
  "node_modules/uc.micro/categories/Z/regex.js"(exports, module) {
    module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});

// node_modules/uc.micro/index.js
var require_uc = __commonJS({
  "node_modules/uc.micro/index.js"(exports) {

    exports.Any = require_regex2();
    exports.Cc = require_regex3();
    exports.Cf = require_regex4();
    exports.P = require_regex();
    exports.Z = require_regex5();
  }
});

// node_modules/markdown-it/lib/common/utils.js
var require_utils = __commonJS({
  "node_modules/markdown-it/lib/common/utils.js"(exports) {

    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function (source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function (key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c) {
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10),
          surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    var entities = require_entities2();
    function replaceEntityPattern(match, name) {
      var code2 = 0;
      if (has(entities, name)) {
        return entities[name];
      }
      if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
        code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
        if (isValidEntityCode(code2)) {
          return fromCodePoint(code2);
        }
      }
      return match;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml2(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code2) {
      switch (code2) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code2) {
      if (code2 >= 8192 && code2 <= 8202) {
        return true;
      }
      switch (code2) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("\u1E9E".toLowerCase() === "\u1E7E") {
        str = str.replace(/ẞ/g, "\xDF");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign;
    exports.isString = isString;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint;
    exports.escapeHtml = escapeHtml2;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module) {

    module.exports = function parseLinkLabel(state, start, disableNested) {
      var level,
        found,
        marker,
        prevPos,
        labelEnd = -1,
        max2 = state.posMax,
        oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max2) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module) {

    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkDestination(str, pos, max2) {
      var code2,
        level,
        lines = 0,
        start = pos,
        result = {
          ok: false,
          pos: 0,
          lines: 0,
          str: ""
        };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max2) {
          code2 = str.charCodeAt(pos);
          if (code2 === 10) {
            return result;
          }
          if (code2 === 60) {
            return result;
          }
          if (code2 === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code2 === 92 && pos + 1 < max2) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max2) {
        code2 = str.charCodeAt(pos);
        if (code2 === 32) {
          break;
        }
        if (code2 < 32 || code2 === 127) {
          break;
        }
        if (code2 === 92 && pos + 1 < max2) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code2 === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code2 === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str.slice(start, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module) {

    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkTitle(str, pos, max2) {
      var code2,
        marker,
        lines = 0,
        start = pos,
        result = {
          ok: false,
          pos: 0,
          lines: 0,
          str: ""
        };
      if (pos >= max2) {
        return result;
      }
      marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max2) {
        code2 = str.charCodeAt(pos);
        if (code2 === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code2 === 40 && marker === 41) {
          return result;
        } else if (code2 === 10) {
          lines++;
        } else if (code2 === 92 && pos + 1 < max2) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/markdown-it/lib/helpers/index.js"(exports) {

    exports.parseLinkLabel = require_parse_link_label();
    exports.parseLinkDestination = require_parse_link_destination();
    exports.parseLinkTitle = require_parse_link_title();
  }
});

// node_modules/markdown-it/lib/renderer.js
var require_renderer = __commonJS({
  "node_modules/markdown-it/lib/renderer.js"(exports, module) {

    var assign = require_utils().assign;
    var unescapeAll = require_utils().unescapeAll;
    var escapeHtml2 = require_utils().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function (tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml2(tokens[idx].content) + "</code>";
    };
    default_rules.code_block = function (tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml2(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function (tokens, idx, options, env, slf) {
      var token = tokens[idx],
        info = token.info ? unescapeAll(token.info).trim() : "",
        langName = "",
        langAttrs = "",
        highlighted,
        i,
        arr,
        tmpAttrs,
        tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml2(token.content);
      } else {
        highlighted = escapeHtml2(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i] = tmpAttrs[i].slice();
          tmpAttrs[i][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function (tokens, idx, options, env, slf) {
      var token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function (tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function (tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function (tokens, idx) {
      return escapeHtml2(tokens[idx].content);
    };
    default_rules.html_block = function (tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function (tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i, l, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i = 0, l = token.attrs.length; i < l; i++) {
        result += " " + escapeHtml2(token.attrs[i][0]) + '="' + escapeHtml2(token.attrs[i][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken,
        result = "",
        needLf = false,
        token = tokens[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function (tokens, options, env) {
      var type,
        result = "",
        rules = this.rules;
      for (var i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
      var result = "";
      for (var i = 0, len = tokens.length; i < len; i++) {
        if (tokens[i].type === "text") {
          result += tokens[i].content;
        } else if (tokens[i].type === "image") {
          result += this.renderInlineAsText(tokens[i].children, options, env);
        } else if (tokens[i].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer.prototype.render = function (tokens, options, env) {
      var i,
        len,
        type,
        result = "",
        rules = this.rules;
      for (i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (type === "inline") {
          result += this.renderInline(tokens[i].children, options, env);
        } else if (typeof rules[type] !== "undefined") {
          result += rules[tokens[i].type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options, env);
        }
      }
      return result;
    };
    module.exports = Renderer;
  }
});

// node_modules/markdown-it/lib/ruler.js
var require_ruler = __commonJS({
  "node_modules/markdown-it/lib/ruler.js"(exports, module) {

    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function (name) {
      for (var i = 0; i < this.__rules__.length; i++) {
        if (this.__rules__[i].name === name) {
          return i;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function () {
      var self = this;
      var chains = [""];
      self.__rules__.forEach(function (rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function (altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self.__cache__ = {};
      chains.forEach(function (chain) {
        self.__cache__[chain] = [];
        self.__rules__.forEach(function (rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function (name, fn, options) {
      var index = this.__find__(name);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
      var index = this.__find__(beforeName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function (afterName, ruleName, fn, options) {
      var index = this.__find__(afterName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function (ruleName, fn, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function (list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function (name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function (list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      this.__rules__.forEach(function (rule) {
        rule.enabled = false;
      });
      this.enable(list2, ignoreInvalid);
    };
    Ruler.prototype.disable = function (list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function (name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function (chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module.exports = Ruler;
  }
});

// node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize = __commonJS({
  "node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module) {

    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module.exports = function normalize(state) {
      var str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "\uFFFD");
      state.src = str;
    };
  }
});

// node_modules/markdown-it/lib/rules_core/block.js
var require_block = __commonJS({
  "node_modules/markdown-it/lib/rules_core/block.js"(exports, module) {

    module.exports = function block3(state) {
      var token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/inline.js
var require_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_core/inline.js"(exports, module) {

    module.exports = function inline3(state) {
      var tokens = state.tokens,
        tok,
        i,
        l;
      for (i = 0, l = tokens.length; i < l; i++) {
        tok = tokens[i];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify = __commonJS({
  "node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module) {

    var arrayReplaceAt = require_utils().arrayReplaceAt;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    module.exports = function linkify(state) {
      var i,
        j,
        l,
        tokens,
        token,
        currentToken,
        nodes,
        ln,
        text2,
        pos,
        lastPos,
        level,
        htmlLinkLevel,
        url,
        fullUrl,
        urlText,
        blockTokens = state.tokens,
        links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i = tokens.length - 1; i >= 0; i--) {
          currentToken = tokens[i];
          if (currentToken.type === "link_close") {
            i--;
            while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
              i--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text2 = currentToken.content;
            links = state.md.linkify.match(text2);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token = new state.Token("text", "", 0);
                token.content = text2.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              token = new state.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state.Token("text", "", 0);
              token.content = urlText;
              token.level = level;
              nodes.push(token);
              token = new state.Token("link_close", "a", -1);
              token.level = --level;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text2.length) {
              token = new state.Token("text", "", 0);
              token.content = text2.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
          }
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements = __commonJS({
  "node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module) {

    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
    var SCOPED_ABBR = {
      c: "\xA9",
      r: "\xAE",
      p: "\xA7",
      tm: "\u2122"
    };
    function replaceFn(match, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i,
        token,
        inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i,
        token,
        inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module.exports = function replace(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes = __commonJS({
  "node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module) {

    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "\u2019";
    function replaceAt(str, index, ch) {
      return str.substr(0, index) + ch + str.substr(index + 1);
    }
    function process_inlines(tokens, state) {
      var i, token, text2, t, pos, max2, thisLevel, item2, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        thisLevel = tokens[i].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text2 = token.content;
        pos = 0;
        max2 = text2.length;
        OUTER: while (pos < max2) {
          QUOTE_RE.lastIndex = pos;
          t = QUOTE_RE.exec(text2);
          if (!t) {
            break;
          }
          canOpen = canClose = true;
          pos = t.index + 1;
          isSingle = t[0] === "'";
          lastChar = 32;
          if (t.index - 1 >= 0) {
            lastChar = text2.charCodeAt(t.index - 1);
          } else {
            for (j = i - 1; j >= 0; j--) {
              if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
              if (!tokens[j].content) continue;
              lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
              break;
            }
          }
          nextChar = 32;
          if (pos < max2) {
            nextChar = text2.charCodeAt(pos);
          } else {
            for (j = i + 1; j < tokens.length; j++) {
              if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
              if (!tokens[j].content) continue;
              nextChar = tokens[j].content.charCodeAt(0);
              break;
            }
          }
          isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
          isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
          isLastWhiteSpace = isWhiteSpace(lastChar);
          isNextWhiteSpace = isWhiteSpace(nextChar);
          if (isNextWhiteSpace) {
            canOpen = false;
          } else if (isNextPunctChar) {
            if (!(isLastWhiteSpace || isLastPunctChar)) {
              canOpen = false;
            }
          }
          if (isLastWhiteSpace) {
            canClose = false;
          } else if (isLastPunctChar) {
            if (!(isNextWhiteSpace || isNextPunctChar)) {
              canClose = false;
            }
          }
          if (nextChar === 34 && t[0] === '"') {
            if (lastChar >= 48 && lastChar <= 57) {
              canClose = canOpen = false;
            }
          }
          if (canOpen && canClose) {
            canOpen = isLastPunctChar;
            canClose = isNextPunctChar;
          }
          if (!canOpen && !canClose) {
            if (isSingle) {
              token.content = replaceAt(token.content, t.index, APOSTROPHE);
            }
            continue;
          }
          if (canClose) {
            for (j = stack.length - 1; j >= 0; j--) {
              item2 = stack[j];
              if (stack[j].level < thisLevel) {
                break;
              }
              if (item2.single === isSingle && stack[j].level === thisLevel) {
                item2 = stack[j];
                if (isSingle) {
                  openQuote = state.md.options.quotes[2];
                  closeQuote = state.md.options.quotes[3];
                } else {
                  openQuote = state.md.options.quotes[0];
                  closeQuote = state.md.options.quotes[1];
                }
                token.content = replaceAt(token.content, t.index, closeQuote);
                tokens[item2.token].content = replaceAt(tokens[item2.token].content, item2.pos, openQuote);
                pos += closeQuote.length - 1;
                if (item2.token === i) {
                  pos += openQuote.length - 1;
                }
                text2 = token.content;
                max2 = text2.length;
                stack.length = j;
                continue OUTER;
              }
            }
          }
          if (canOpen) {
            stack.push({
              token: i,
              pos: t.index,
              single: isSingle,
              level: thisLevel
            });
          } else if (canClose && isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
        }
      }
    }
    module.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});

// node_modules/markdown-it/lib/token.js
var require_token = __commonJS({
  "node_modules/markdown-it/lib/token.js"(exports, module) {

    function Token(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token.prototype.attrIndex = function attrIndex(name) {
      var attrs, i, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i = 0, len = attrs.length; i < len; i++) {
        if (attrs[i][0] === name) {
          return i;
        }
      }
      return -1;
    };
    Token.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token.prototype.attrSet = function attrSet(name, value) {
      var idx = this.attrIndex(name),
        attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token.prototype.attrGet = function attrGet(name) {
      var idx = this.attrIndex(name),
        value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token.prototype.attrJoin = function attrJoin(name, value) {
      var idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    module.exports = Token;
  }
});

// node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core = __commonJS({
  "node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module) {

    var Token = require_token();
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token;
    module.exports = StateCore;
  }
});

// node_modules/markdown-it/lib/parser_core.js
var require_parser_core = __commonJS({
  "node_modules/markdown-it/lib/parser_core.js"(exports, module) {

    var Ruler = require_ruler();
    var _rules = [["normalize", require_normalize()], ["block", require_block()], ["inline", require_inline()], ["linkify", require_linkify()], ["replacements", require_replacements()], ["smartquotes", require_smartquotes()]];
    function Core() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
    }
    Core.prototype.process = function (state) {
      var i, l, rules;
      rules = this.ruler.getRules("");
      for (i = 0, l = rules.length; i < l; i++) {
        rules[i](state);
      }
    };
    Core.prototype.State = require_state_core();
    module.exports = Core;
  }
});

// node_modules/markdown-it/lib/rules_block/table.js
var require_table = __commonJS({
  "node_modules/markdown-it/lib/rules_block/table.js"(exports, module) {

    var isSpace = require_utils().isSpace;
    function getLine2(state, line) {
      var pos = state.bMarks[line] + state.tShift[line],
        max2 = state.eMarks[line];
      return state.src.substr(pos, max2 - pos);
    }
    function escapedSplit(str) {
      var result = [],
        pos = 0,
        max2 = str.length,
        ch,
        isEscaped = false,
        lastPos = 0,
        current = "";
      ch = str.charCodeAt(pos);
      while (pos < max2) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current + str.substring(lastPos));
      return result;
    }
    module.exports = function table3(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine2(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t = columns[i].trim();
        if (!t) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine2(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "") columns.shift();
      if (columns.length && columns[columns.length - 1] === "") columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i = 0; i < columns.length; i++) {
        token = state.push("th_open", "th", 1);
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i].trim();
        token.children = [];
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine2(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "") columns.shift();
        if (columns.length && columns[columns.length - 1] === "") columns.pop();
        if (nextLine === startLine + 2) {
          token = state.push("tbody_open", "tbody", 1);
          token.map = tbodyLines = [startLine + 2, 0];
        }
        token = state.push("tr_open", "tr", 1);
        token.map = [nextLine, nextLine + 1];
        for (i = 0; i < columnCount; i++) {
          token = state.push("td_open", "td", 1);
          if (aligns[i]) {
            token.attrs = [["style", "text-align:" + aligns[i]]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i] ? columns[i].trim() : "";
          token.children = [];
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/code.js
var require_code = __commonJS({
  "node_modules/markdown-it/lib/rules_block/code.js"(exports, module) {

    module.exports = function code2(state, startLine, endLine) {
      if (state.md.options.allowIndentation) {
        return false;
      }
      var nextLine, last, token;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/fence.js
var require_fence = __commonJS({
  "node_modules/markdown-it/lib/rules_block/fence.js"(exports, module) {

    module.exports = function fence3(state, startLine, endLine, silent) {
      var marker,
        len,
        params,
        nextLine,
        mem,
        token,
        markup,
        haveEndMarker = false,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max2) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max2);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (;;) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max2 = state.eMarks[nextLine];
        if (pos < max2 && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max2) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote = __commonJS({
  "node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module) {

    var isSpace = require_utils().isSpace;
    module.exports = function blockquote2(state, startLine, endLine, silent) {
      var adjustTab,
        ch,
        i,
        initial,
        l,
        lastLineEmpty,
        lines,
        nextLine,
        offset,
        oldBMarks,
        oldBSCount,
        oldIndent,
        oldParentType,
        oldSCount,
        oldTShift,
        spaceAfterMarker,
        terminate,
        terminatorRules,
        token,
        isOutdented,
        oldLineMax = state.lineMax,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset = state.sCount[startLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[startLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state.bMarks[startLine]];
      state.bMarks[startLine] = pos;
      while (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state.bsCount[startLine]];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max2;
      oldSCount = [state.sCount[startLine]];
      state.sCount[startLine] = offset - initial;
      oldTShift = [state.tShift[startLine]];
      state.tShift[startLine] = pos - state.bMarks[startLine];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max2 = state.eMarks[nextLine];
        if (pos >= max2) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = offset = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + offset) % 4 === 3) {
              pos++;
              initial++;
              offset++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max2) {
            ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max2;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token = state.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token = state.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i = 0; i < oldTShift.length; i++) {
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
        state.sCount[i + startLine] = oldSCount[i];
        state.bsCount[i + startLine] = oldBSCount[i];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/hr.js
var require_hr = __commonJS({
  "node_modules/markdown-it/lib/rules_block/hr.js"(exports, module) {

    var isSpace = require_utils().isSpace;
    module.exports = function hr2(state, startLine, endLine, silent) {
      var marker,
        cnt,
        ch,
        token,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max2) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/list.js
var require_list = __commonJS({
  "node_modules/markdown-it/lib/rules_block/list.js"(exports, module) {

    var isSpace = require_utils().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max2, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max2 = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch,
        start = state.bMarks[startLine] + state.tShift[startLine],
        pos = start,
        max2 = state.eMarks[startLine];
      if (pos + 1 >= max2) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (;;) {
        if (pos >= max2) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i,
        l,
        level = state.level + 2;
      for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
          state.tokens[i + 2].hidden = true;
          state.tokens[i].hidden = true;
          i += 2;
        }
      }
    }
    module.exports = function list2(state, startLine, endLine, silent) {
      var ch,
        contentStart,
        i,
        indent,
        indentAfterMarker,
        initial,
        isOrdered,
        itemLines,
        l,
        listLines,
        listTokIdx,
        markerCharCode,
        markerValue,
        max2,
        nextLine,
        offset,
        oldListIndent,
        oldParentType,
        oldSCount,
        oldTShift,
        oldTight,
        pos,
        posAfterMarker,
        prevEmptyEnd,
        start,
        terminate,
        terminatorRules,
        token,
        isTerminatingParagraph = false,
        tight = true;
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1) return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [startLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max2 = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
        while (pos < max2) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max2) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (!state.md.options.allowIndentation && indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [startLine, 0];
        if (isOrdered) {
          token.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset;
        if (contentStart >= max2 && state.isEmpty(startLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/reference.js
var require_reference = __commonJS({
  "node_modules/markdown-it/lib/rules_block/reference.js"(exports, module) {

    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function reference(state, startLine, _endLine, silent) {
      var ch,
        destEndPos,
        destEndLineNo,
        endLine,
        href,
        i,
        l,
        label,
        labelEnd,
        oldParentType,
        res,
        start,
        str,
        terminate,
        terminatorRules,
        title,
        lines = 0,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max2 = state.eMarks[startLine],
        nextLine = startLine + 1;
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max2) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max2) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max2 = str.length;
      for (pos = 1; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max2 && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) ; else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max2);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) ; else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max2);
      if (pos < max2 && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max2) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max2 && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max2) {
            ch = str.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max2 && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = {
          title,
          href
        };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks = __commonJS({
  "node_modules/markdown-it/lib/common/html_blocks.js"(exports, module) {

    module.exports = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "section", "source", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"];
  }
});

// node_modules/markdown-it/lib/common/html_re.js
var require_html_re = __commonJS({
  "node_modules/markdown-it/lib/common/html_re.js"(exports, module) {

    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module.exports.HTML_TAG_RE = HTML_TAG_RE;
    module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});

// node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module) {

    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [[/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]];
    module.exports = function html_block(state, startLine, endLine, silent) {
      var i,
        nextLine,
        token,
        lineText,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max2);
      for (i = 0; i < HTML_SEQUENCES.length; i++) {
        if (HTML_SEQUENCES[i][0].test(lineText)) {
          break;
        }
      }
      if (i === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max2 = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max2);
          if (HTML_SEQUENCES[i][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/heading.js
var require_heading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/heading.js"(exports, module) {

    var isSpace = require_utils().isSpace;
    module.exports = function heading2(state, startLine, endLine, silent) {
      var ch,
        level,
        tmp,
        token,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max2) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max2 && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max2 && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max2 = state.skipSpacesBack(max2, pos);
      tmp = state.skipCharsBack(max2, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max2 = tmp;
      }
      state.line = startLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = "########".slice(0, level);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = state.src.slice(pos, max2).trim();
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = "########".slice(0, level);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module) {

    module.exports = function lheading(state, startLine, endLine) {
      var content,
        terminate,
        i,
        l,
        token,
        pos,
        max2,
        level,
        marker,
        nextLine = startLine + 1,
        oldParentType,
        terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max2 = state.eMarks[nextLine];
          if (pos < max2) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max2) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph = __commonJS({
  "node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module) {

    module.exports = function paragraph2(state, startLine) {
      var content,
        terminate,
        i,
        l,
        token,
        oldParentType,
        nextLine = startLine + 1,
        terminatorRules = state.md.block.ruler.getRules("paragraph"),
        endLine = state.lineMax;
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token = state.push("paragraph_open", "p", 1);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module) {

    var Token = require_token();
    var isSpace = require_utils().isSpace;
    function StateBlock(src, md, env, tokens) {
      var ch, s2, start, pos, len, indent, offset, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s2 = this.src;
      indent_found = false;
      for (start = pos = indent = offset = 0, len = s2.length; pos < len; pos++) {
        ch = s2.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s2.length);
      this.eMarks.push(s2.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function (type, tag, nesting) {
      var token = new Token(type, tag, nesting);
      token.block = true;
      if (nesting < 0) this.level--;
      token.level = this.level;
      if (nesting > 0) this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max2 = this.lineMax; from < max2; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max2 = this.src.length; pos < max2; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code2) {
      for (var max2 = this.src.length; pos < max2; pos++) {
        if (this.src.charCodeAt(pos) !== code2) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code2 !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i,
        lineIndent,
        ch,
        first,
        last,
        queue,
        lineStart,
        line = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i = 0; line < end; line++, i++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token;
    module.exports = StateBlock;
  }
});

// node_modules/markdown-it/lib/parser_block.js
var require_parser_block = __commonJS({
  "node_modules/markdown-it/lib/parser_block.js"(exports, module) {

    var Ruler = require_ruler();
    var _rules = [["table", require_table(), ["paragraph", "reference"]], ["code", require_code()], ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]], ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]], ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]], ["list", require_list(), ["paragraph", "reference", "blockquote"]], ["reference", require_reference()], ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]], ["heading", require_heading(), ["paragraph", "reference", "blockquote"]], ["lheading", require_lheading()], ["paragraph", require_paragraph()]];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1], {
          alt: (_rules[i][2] || []).slice()
        });
      }
    }
    ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
      var ok,
        i,
        rules = this.ruler.getRules(""),
        len = rules.length,
        line = startLine,
        hasEmptyLines = false,
        maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        for (i = 0; i < len; i++) {
          ok = rules[i](state, line, endLine, false);
          if (ok) {
            break;
          }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function (src, md, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module.exports = ParserBlock;
  }
});

// node_modules/markdown-it/lib/rules_inline/text.js
var require_text = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text.js"(exports, module) {

    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module.exports = function text2(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module) {

    var isSpace = require_utils().isSpace;
    module.exports = function newline(state, silent) {
      var pmax,
        max2,
        ws,
        pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max2 = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32) ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max2 && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module) {

    var isSpace = require_utils().isSpace;
    var ESCAPED = [];
    for (i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    var i;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function (ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module.exports = function escape(state, silent) {
      var ch,
        pos = state.pos,
        max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 92) {
        return false;
      }
      pos++;
      if (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (ch < 256 && ESCAPED[ch] !== 0) {
          if (!silent) {
            state.pending += state.src[pos];
          }
          state.pos += 2;
          return true;
        }
        if (ch === 10) {
          if (!silent) {
            state.push("hardbreak", "br", 0);
          }
          pos++;
          while (pos < max2) {
            ch = state.src.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
          state.pos = pos;
          return true;
        }
      }
      if (!silent) {
        state.pending += "\\";
      }
      state.pos++;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module) {

    module.exports = function backtick(state, silent) {
      var start,
        max2,
        marker,
        token,
        matchStart,
        matchEnd,
        openerLength,
        closerLength,
        pos = state.pos,
        ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max2 = state.posMax;
      while (pos < max2 && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent) state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchStart = matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max2 && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent) state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module) {

    module.exports.tokenize = function strikethrough(state, silent) {
      var i,
        scanned,
        token,
        len,
        ch,
        start = state.pos,
        marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i = 0; i < len; i += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i,
        j,
        startDelim,
        endDelim,
        token,
        loneMarkers = [],
        max2 = delimiters.length;
      for (i = 0; i < max2; i++) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i = loneMarkers.pop();
        j = i + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    module.exports.postProcess = function strikethrough(state) {
      var curr,
        tokens_meta = state.tokens_meta,
        max2 = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module) {

    module.exports.tokenize = function emphasis(state, silent) {
      var i,
        scanned,
        token,
        start = state.pos,
        marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i = 0; i < scanned.length; i++) {
        token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          marker,
          length: scanned.length,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i,
        startDelim,
        endDelim,
        token,
        ch,
        isStrong,
        max2 = delimiters.length;
      for (i = max2 - 1; i >= 0; i--) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token = state.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state.tokens[delimiters[i - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i--;
        }
      }
    }
    module.exports.postProcess = function emphasis(state) {
      var curr,
        tokens_meta = state.tokens_meta,
        max2 = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/link.js
var require_link = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/link.js"(exports, module) {

    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function link2(state, silent) {
      var attrs,
        code2,
        label,
        labelEnd,
        labelStart,
        pos,
        res,
        ref,
        token,
        href = "",
        title = "",
        oldPos = state.pos,
        max2 = state.posMax,
        start = state.pos,
        parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max2 && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max2; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max2) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max2; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max2 && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max2; pos++) {
              code2 = state.src.charCodeAt(pos);
              if (!isSpace(code2) && code2 !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max2 && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.md.inline.tokenize(state);
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max2;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/image.js
var require_image = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/image.js"(exports, module) {

    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function image2(state, silent) {
      var attrs,
        code2,
        content,
        label,
        labelEnd,
        labelStart,
        pos,
        ref,
        res,
        title,
        token,
        tokens,
        start,
        href = "",
        oldPos = state.pos,
        max2 = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max2 && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max2; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max2) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max2; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max2 && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max2; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max2 && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(content, state.md, state.env, tokens = []);
        token = state.push("image", "img", 0);
        token.attrs = attrs = [["src", href], ["alt", ""]];
        token.children = tokens;
        token.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max2;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module) {

    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module.exports = function autolink(state, silent) {
      var url,
        fullUrl,
        token,
        ch,
        start,
        max2,
        pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max2 = state.posMax;
      for (;;) {
        if (++pos >= max2) return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60) return false;
        if (ch === 62) break;
      }
      url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module) {

    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module.exports = function html_inline(state, silent) {
      var ch,
        match,
        max2,
        token,
        pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max2) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        token = state.push("html_inline", "", 0);
        token.content = state.src.slice(pos, pos + match[0].length);
      }
      state.pos += match[0].length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module) {

    var entities = require_entities2();
    var has = require_utils().has;
    var isValidEntityCode = require_utils().isValidEntityCode;
    var fromCodePoint = require_utils().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module.exports = function entity(state, silent) {
      var ch,
        code2,
        match,
        pos = state.pos,
        max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 38) {
        return false;
      }
      if (pos + 1 < max2) {
        ch = state.src.charCodeAt(pos + 1);
        if (ch === 35) {
          match = state.src.slice(pos).match(DIGITAL_RE);
          if (match) {
            if (!silent) {
              code2 = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
              state.pending += isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
            }
            state.pos += match[0].length;
            return true;
          }
        } else {
          match = state.src.slice(pos).match(NAMED_RE);
          if (match) {
            if (has(entities, match[1])) {
              if (!silent) {
                state.pending += entities[match[1]];
              }
              state.pos += match[0].length;
              return true;
            }
          }
        }
      }
      if (!silent) {
        state.pending += "&";
      }
      state.pos++;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module) {

    function processDelimiters(state, delimiters) {
      var closerIdx,
        openerIdx,
        closer,
        opener,
        minOpenerIdx,
        newMinOpenerIdx,
        isOddMatch,
        lastJump,
        openersBottom = {},
        max2 = delimiters.length;
      if (!max2) return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max2; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close) continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker) continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module.exports = function link_pairs(state) {
      var curr,
        tokens_meta = state.tokens_meta,
        max2 = state.tokens_meta.length;
      processDelimiters(state, state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/text_collapse.js
var require_text_collapse = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text_collapse.js"(exports, module) {

    module.exports = function text_collapse(state) {
      var curr,
        last,
        level = 0,
        tokens = state.tokens,
        max2 = state.tokens.length;
      for (curr = last = 0; curr < max2; curr++) {
        if (tokens[curr].nesting < 0) level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0) level++;
        if (tokens[curr].type === "text" && curr + 1 < max2 && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module) {

    var Token = require_token();
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
    }
    StateInline.prototype.pushPending = function () {
      var token = new Token("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function (type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token(type, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = {
          delimiters: this.delimiters
        };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function (start, canSplitWord) {
      var pos = start,
        lastChar,
        nextChar,
        count,
        can_open,
        can_close,
        isLastWhiteSpace,
        isLastPunctChar,
        isNextWhiteSpace,
        isNextPunctChar,
        left_flanking = true,
        right_flanking = true,
        max2 = this.posMax,
        marker = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max2 && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max2 ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token;
    module.exports = StateInline;
  }
});

// node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline = __commonJS({
  "node_modules/markdown-it/lib/parser_inline.js"(exports, module) {

    var Ruler = require_ruler();
    var _rules = [["text", require_text()], ["newline", require_newline()], ["escape", require_escape()], ["backticks", require_backticks()], ["strikethrough", require_strikethrough().tokenize], ["emphasis", require_emphasis().tokenize], ["link", require_link()], ["image", require_image()], ["autolink", require_autolink()], ["html_inline", require_html_inline()], ["entity", require_entity()]];
    var _rules2 = [["balance_pairs", require_balance_pairs()], ["strikethrough", require_strikethrough().postProcess], ["emphasis", require_emphasis().postProcess], ["text_collapse", require_text_collapse()]];
    function ParserInline() {
      var i;
      this.ruler = new Ruler();
      for (i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
      this.ruler2 = new Ruler();
      for (i = 0; i < _rules2.length; i++) {
        this.ruler2.push(_rules2[i][0], _rules2[i][1]);
      }
    }
    ParserInline.prototype.skipToken = function (state) {
      var ok,
        i,
        pos = state.pos,
        rules = this.ruler.getRules(""),
        len = rules.length,
        maxNesting = state.md.options.maxNesting,
        cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          state.level++;
          ok = rules[i](state, true);
          state.level--;
          if (ok) {
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function (state) {
      var ok,
        i,
        rules = this.ruler.getRules(""),
        len = rules.length,
        end = state.posMax,
        maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        if (state.level < maxNesting) {
          for (i = 0; i < len; i++) {
            ok = rules[i](state, false);
            if (ok) {
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function (str, md, env, outTokens) {
      var i, rules, len;
      var state = new this.State(str, md, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i = 0; i < len; i++) {
        rules[i](state);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module.exports = ParserInline;
  }
});

// node_modules/linkify-it/lib/re.js
var require_re = __commonJS({
  "node_modules/linkify-it/lib/re.js"(exports, module) {

    module.exports = function (opts) {
      var re = {};
      re.src_Any = require_regex2().source;
      re.src_Cc = require_regex3().source;
      re.src_Z = require_regex5().source;
      re.src_P = require_regex().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><\uFF5C]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + ").|;(?!" + re.src_ZCc + ").|\\!+(?!" + re.src_ZCc + "|[!]).|\\?(?!" + re.src_ZCc + "|[?]).)+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});

// node_modules/linkify-it/index.js
var require_linkify_it = __commonJS({
  "node_modules/linkify-it/index.js"(exports, module) {

    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function (source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function (key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction2(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function (acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function (text2, pos, self) {
          var tail = text2.slice(pos);
          if (!self.re.http) {
            self.re.http = new RegExp("^\\/\\/" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, "i");
          }
          if (self.re.http.test(tail)) {
            return tail.match(self.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function (text2, pos, self) {
          var tail = text2.slice(pos);
          if (!self.re.no_http) {
            self.re.no_http = new RegExp("^" + self.re.src_auth + "(?:localhost|(?:(?:" + self.re.src_domain + ")\\.)+" + self.re.src_domain_root + ")" + self.re.src_port + self.re.src_host_terminator + self.re.src_path, "i");
          }
          if (self.re.no_http.test(tail)) {
            if (pos >= 3 && text2[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text2[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function (text2, pos, self) {
          var tail = text2.slice(pos);
          if (!self.re.mailto) {
            self.re.mailto = new RegExp("^" + self.re.src_email_name + "@" + self.re.src_host_strict, "i");
          }
          if (self.re.mailto.test(tail)) {
            return tail.match(self.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    function resetScanCache(self) {
      self.__index__ = -1;
      self.__text_cache__ = "";
    }
    function createValidator(re) {
      return function (text2, pos) {
        var tail = text2.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function (match, self) {
        self.normalize(match);
      };
    }
    function compile(self) {
      var re = self.re = require_re()(self.__opts__);
      var tlds = self.__tlds__.slice();
      self.onCompile();
      if (!self.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self.__schemas__).forEach(function (name) {
        var val = self.__schemas__[name];
        if (val === null) {
          return;
        }
        var compiled = {
          validate: null,
          link: null
        };
        self.__compiled__[name] = compiled;
        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction2(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction2(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases.forEach(function (alias) {
        if (!self.__compiled__[self.__schemas__[alias]]) {
          return;
        }
        self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
        self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
      });
      self.__compiled__[""] = {
        validate: null,
        normalize: createNormalizer()
      };
      var slist = Object.keys(self.__compiled__).filter(function (name) {
        return name.length > 0 && self.__compiled__[name];
      }).map(escapeRE).join("|");
      self.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self.re.pretest = RegExp("(" + self.re.schema_test.source + ")|(" + self.re.host_fuzzy_test.source + ")|@", "i");
      resetScanCache(self);
    }
    function Match(self, shift) {
      var start = self.__index__,
        end = self.__last_index__,
        text2 = self.__text_cache__.slice(start, end);
      this.schema = self.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text2;
      this.text = text2;
      this.url = text2;
    }
    function createMatch(self, shift) {
      var match = new Match(self, shift);
      self.__compiled__[match.schema].normalize(match, self);
      return match;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };
    LinkifyIt.prototype.set = function set(options) {
      this.__opts__ = assign(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text2) {
      this.__text_cache__ = text2;
      this.__index__ = -1;
      if (!text2.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text2)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text2)) !== null) {
          len = this.testSchemaAt(text2, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text2.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text2.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text2.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text2) {
      return this.re.pretest.test(text2);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
    };
    LinkifyIt.prototype.match = function match(text2) {
      var shift = 0,
        result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text2) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text2.slice(shift) : text2;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
      list2 = Array.isArray(list2) ? list2 : [list2];
      if (!keepOld) {
        this.__tlds__ = list2.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function (el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {};
    module.exports = LinkifyIt;
  }
});

// node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "node_modules/punycode/punycode.js"(exports, module) {

    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error2(type) {
      throw new RangeError(errors[type]);
    }
    function map(array, fn) {
      const result = [];
      let length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      const parts = string.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      const labels = string.split(".");
      const encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      const output = [];
      let counter = 0;
      const length = string.length;
      while (counter < length) {
        const value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          const extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = array => String.fromCodePoint(...array);
    var basicToDigit = function (codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function (digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function (delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function (input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error2("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
        let oldi = i;
        for (let w = 1, k = base;; k += base) {
          if (index >= inputLength) {
            error2("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error2("overflow");
          }
          i += digit * w;
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error2("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error2("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    var encode = function (input) {
      const output = [];
      input = ucs2decode(input);
      let inputLength = input.length;
      let n = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      let basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error2("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta > maxInt) {
            error2("overflow");
          }
          if (currentValue == n) {
            let q = delta;
            for (let k = base;; k += base) {
              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function (input) {
      return mapDomain(input, function (string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function (input) {
      return mapDomain(input, function (string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    module.exports = punycode;
  }
});

// node_modules/markdown-it/lib/presets/default.js
var require_default = __commonJS({
  "node_modules/markdown-it/lib/presets/default.js"(exports, module) {

    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 100
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/zero.js
var require_zero = __commonJS({
  "node_modules/markdown-it/lib/presets/zero.js"(exports, module) {

    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: ["normalize", "block", "inline"]
        },
        block: {
          rules: ["paragraph"]
        },
        inline: {
          rules: ["text"],
          rules2: ["balance_pairs", "text_collapse"]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark = __commonJS({
  "node_modules/markdown-it/lib/presets/commonmark.js"(exports, module) {

    module.exports = {
      options: {
        html: true,
        xhtmlOut: true,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: ["normalize", "block", "inline"]
        },
        block: {
          rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"]
        },
        inline: {
          rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"],
          rules2: ["balance_pairs", "emphasis", "text_collapse"]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/index.js
var require_lib = __commonJS({
  "node_modules/markdown-it/lib/index.js"(exports, module) {

    var utils = require_utils();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it();
    var mdurl = require_mdurl();
    var punycode = require_punycode();
    var config = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {}
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {}
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt3(presetName, options) {
      if (!(this instanceof MarkdownIt3)) {
        return new MarkdownIt3(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt3.prototype.set = function (options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt3.prototype.configure = function (presets) {
      var self = this,
        presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function (name) {
          if (presets.components[name].rules) {
            self[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt3.prototype.enable = function (list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function (chain) {
        result = result.concat(this[chain].ruler.enable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list2, true));
      var missed = list2.filter(function (name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.disable = function (list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function (chain) {
        result = result.concat(this[chain].ruler.disable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list2, true));
      var missed = list2.filter(function (name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.use = function (plugin3) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin3.apply(plugin3, args);
      return this;
    };
    MarkdownIt3.prototype.parse = function (src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt3.prototype.render = function (src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt3.prototype.parseInline = function (src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt3.prototype.renderInline = function (src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module.exports = MarkdownIt3;
  }
});

// node_modules/markdown-it/index.js
var require_markdown_it = __commonJS({
  "node_modules/markdown-it/index.js"(exports, module) {

    module.exports = require_lib();
  }
});

// node_modules/markdown-it-sup/index.js
var require_markdown_it_sup = __commonJS({
  "node_modules/markdown-it-sup/index.js"(exports, module) {

    var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;
    function superscript(state, silent) {
      var found,
        content,
        token,
        max2 = state.posMax,
        start = state.pos;
      if (state.src.charCodeAt(start) !== 94) {
        return false;
      }
      if (silent) {
        return false;
      }
      if (start + 2 >= max2) {
        return false;
      }
      state.pos = start + 1;
      while (state.pos < max2) {
        if (state.src.charCodeAt(state.pos) === 94) {
          found = true;
          break;
        }
        state.md.inline.skipToken(state);
      }
      if (!found || start + 1 === state.pos) {
        state.pos = start;
        return false;
      }
      content = state.src.slice(start + 1, state.pos);
      if (content.match(/(^|[^\\])(\\\\)*\s/)) {
        state.pos = start;
        return false;
      }
      state.posMax = state.pos;
      state.pos = start + 1;
      token = state.push("sup_open", "sup", 1);
      token.markup = "^";
      token = state.push("text", "", 0);
      token.content = content.replace(UNESCAPE_RE, "$1");
      token = state.push("sup_close", "sup", -1);
      token.markup = "^";
      state.pos = state.posMax + 1;
      state.posMax = max2;
      return true;
    }
    module.exports = function sup_plugin(md) {
      md.inline.ruler.after("emphasis", "sup", superscript);
    };
  }
});

// src/ast/base.ts
var base_exports = {};
__export(base_exports, {
  getAstValues: () => getAstValues,
  isAst: () => isAst,
  isFunction: () => isFunction$1,
  isVariable: () => isVariable,
  resolve: () => resolve
});
function isAst(value) {
  return !!value?.$$mdtype;
}
function isFunction$1(value) {
  return !!(value?.$$mdtype === "Function");
}
function isVariable(value) {
  return !!(value?.$$mdtype === "Variable");
}
function* getAstValues(value) {
  if (value == null || typeof value !== "object") return;
  if (Array.isArray(value)) for (const v of value) yield* getAstValues(v);
  if (isAst(value)) yield value;
  if (Object.getPrototypeOf(value) !== Object.prototype) return;
  for (const v of Object.values(value)) yield* getAstValues(v);
}
function resolve(value, config = {}) {
  if (value == null || typeof value !== "object") return value;
  if (Array.isArray(value)) return value.map(item2 => resolve(item2, config));
  if (isAst(value) && value?.resolve instanceof Function) return value.resolve(config);
  if (Object.getPrototypeOf(value) !== Object.prototype) return value;
  const output = {};
  for (const [k, v] of Object.entries(value)) output[k] = resolve(v, config);
  return output;
}

// src/tag.ts
var Tag = class {
  constructor(name = "div", attributes = {}, children = []) {
    this.$$mdtype = "Tag";
    this.name = name;
    this.attributes = attributes;
    this.children = children;
  }
};

// src/schema-types/class.ts
var Class = class {
  validate(value) {
    if (typeof value === "string" || typeof value === "object") return [];
    return [{
      id: "attribute-type-invalid",
      level: "error",
      message: `Attribute 'class' must be type 'string | object'`
    }];
  }
  transform(value) {
    if (!value || typeof value === "string") return value;
    const classes = [];
    for (const [k, v] of Object.entries(value ?? {})) if (v) classes.push(k);
    return classes.join(" ");
  }
};

// src/utils.ts
var import_tag = __toModule(require_tag());

// src/ast/variable.ts
var Variable = class {
  constructor(path = []) {
    this.$$mdtype = "Variable";
    this.path = path;
  }
  resolve({
    variables
  } = {}) {
    return variables instanceof Function ? variables(this.path) : this.path.reduce((obj = {}, key) => obj[key], variables);
  }
};

// src/ast/function.ts
var Function2 = class {
  constructor(name, parameters) {
    this.$$mdtype = "Function";
    this.name = name;
    this.parameters = parameters;
  }
  resolve(config = {}) {
    const fn = config?.functions?.[this.name];
    if (!fn) return null;
    const parameters = resolve(this.parameters, config);
    return fn.transform?.(parameters, config);
  }
};

// src/utils.ts
var STATES;
(function (STATES2) {
  STATES2[STATES2["normal"] = 0] = "normal";
  STATES2[STATES2["string"] = 1] = "string";
  STATES2[STATES2["escape"] = 2] = "escape";
})(STATES || (STATES = {}));
var OPEN = "{%";
var CLOSE = "%}";
function isPromise(a) {
  return a && typeof a === "object" && typeof a.then === "function";
}
function findTagEnd(content, start = 0) {
  let state = 0;
  for (let pos = start; pos < content.length; pos++) {
    const char = content[pos];
    switch (state) {
      case 1:
        switch (char) {
          case '"':
            state = 0;
            break;
          case "\\":
            state = 2;
            break;
        }
        break;
      case 2:
        state = 1;
        break;
      case 0:
        if (char === '"') state = 1;else if (content.startsWith(CLOSE, pos)) return pos;
    }
  }
  return null;
}
function parseTag(content, line, contentStart) {
  try {
    return (0, import_tag.parse)(content, {
      Variable,
      Function: Function2
    });
  } catch (error2) {
    if (!(error2 instanceof import_tag.SyntaxError)) throw error2;
    const {
      message,
      location: {
        start,
        end
      }
    } = error2;
    const location = {
      start: {
        line,
        character: start.offset + contentStart
      },
      end: {
        line: line + 1,
        character: end.offset + contentStart
      }
    };
    return {
      type: "error",
      meta: {
        error: {
          message,
          location
        }
      }
    };
  }
}
function parseTags(content, firstLine = 0) {
  let line = firstLine + 1;
  const output = [];
  let start = 0;
  for (let pos = 0; pos < content.length; pos++) {
    if (content[pos] === "\n") {
      line++;
      continue;
    }
    if (!content.startsWith(OPEN, pos)) continue;
    const end = findTagEnd(content, pos);
    if (end == null) {
      pos = pos + OPEN.length;
      continue;
    }
    const text2 = content.slice(pos, end + CLOSE.length);
    const inner = content.slice(pos + OPEN.length, end);
    const lineStart = content.lastIndexOf("\n", pos);
    const lineEnd = content.indexOf("\n", end);
    const lineContent = content.slice(lineStart, lineEnd);
    const tag = parseTag(inner.trim(), line, pos - lineStart);
    const precedingTextEnd = lineContent.trim() === text2 ? lineStart : pos;
    const precedingText = content.slice(start, precedingTextEnd);
    output.push({
      type: "text",
      start,
      end: pos - 1,
      content: precedingText
    });
    output.push({
      map: [line, line + 1],
      position: {
        start: pos - lineStart,
        end: pos - lineStart + text2.length
      },
      start: pos,
      end: pos + text2.length - 1,
      info: text2,
      ...tag
    });
    start = end + CLOSE.length;
    pos = start - 1;
  }
  output.push({
    type: "text",
    start,
    end: content.length - 1,
    content: content.slice(start)
  });
  return output;
}

// src/transformer.ts
var globalAttributes = {
  class: {
    type: Class,
    render: true
  },
  id: {
    type: String,
    render: true
  }
};
var transformer_default = {
  findSchema(node2, {
    nodes = {},
    tags = {}
  } = {}) {
    return node2.tag ? tags[node2.tag] : nodes[node2.type];
  },
  attributes(node2, config = {}) {
    const schema = this.findSchema(node2, config) ?? {};
    const output = {};
    const attrs = {
      ...globalAttributes,
      ...schema.attributes
    };
    for (const [key, attr] of Object.entries(attrs)) {
      if (attr.render == false) continue;
      const name = typeof attr.render === "string" ? attr.render : key;
      let value = node2.attributes[key];
      if (typeof attr.type === "function") {
        const instance = new attr.type();
        if (instance.transform) {
          value = instance.transform(value, config);
        }
      }
      value = value === void 0 ? attr.default : value;
      if (value === void 0) continue;
      output[name] = value;
    }
    return output;
  },
  children(node2, config = {}) {
    const children = node2.children.flatMap(child => this.node(child, config));
    if (children.some(isPromise)) {
      return Promise.all(children);
    }
    return children;
  },
  node(node2, config = {}) {
    const schema = this.findSchema(node2, config) ?? {};
    if (schema && schema.transform instanceof Function) return schema.transform(node2, config);
    const children = this.children(node2, config);
    if (!schema || !schema.render) return children;
    const attributes = this.attributes(node2, config);
    if (isPromise(attributes) || isPromise(children)) {
      return Promise.all([attributes, children]).then(values => new Tag(schema.render, ...values));
    }
    return new Tag(schema.render, attributes, children);
  }
};

// src/ast/node.ts
var Node = class {
  constructor(type = "node", attributes = {}, children = [], tag) {
    this.$$mdtype = "Node";
    this.errors = [];
    this.lines = [];
    this.inline = false;
    this.attributes = attributes;
    this.children = children;
    this.type = type;
    this.tag = tag;
    this.annotations = [];
  }
  *walk() {
    for (const child of this.children) {
      yield child;
      yield* child.walk();
    }
  }
  push(node2) {
    this.children.push(node2);
  }
  resolve(config = {}) {
    return Object.assign(new Node(), this, {
      children: this.children.map(child => child.resolve(config)),
      attributes: resolve(this.attributes, config)
    });
  }
  findSchema(config = {}) {
    return transformer_default.findSchema(this, config);
  }
  transformAttributes(config = {}) {
    return transformer_default.attributes(this, config);
  }
  transformChildren(config) {
    return transformer_default.children(this, config);
  }
  transform(config) {
    return transformer_default.node(this, config);
  }
};

// src/ast/index.ts
var AstTypes = {
  Function: Function2,
  Node,
  Variable
};
function reviver(_, value) {
  if (!value) return value;
  const klass = AstTypes[value.$$mdtype];
  return klass ? Object.assign(new klass(), value) : value;
}
function fromJSON(text2) {
  return JSON.parse(text2, reviver);
}
var ast_default = {
  ...AstTypes,
  ...base_exports,
  fromJSON
};

// src/formatter.ts
var SPACE = " ";
var SEP = ", ";
var NL = "\n";
var OL = "1. ";
var UL = "- ";
var MAX_TAG_HEAD_LENGTH = 80;
var max = (a, b) => Math.max(a, b);
var increment = (o, n = 2) => ({
  ...o,
  indent: (o.indent || 0) + n
});
function* formatChildren(a, options) {
  for (const child of a.children) {
    yield* formatValue(child, options);
  }
}
function* formatTableRow(items) {
  yield `| ${items.join(" | ")} |`;
}
function formatScalar(v) {
  if (ast_default.isAst(v)) {
    return format(v);
  }
  if (v === null) {
    return "";
  }
  if (Array.isArray(v)) {
    return "[" + v.map(formatScalar).join(SEP) + "]";
  }
  if (typeof v === "object") {
    return "{" + Object.entries(v).map(([key, value]) => `${key}: ${formatScalar(value)}`).join(SEP) + "}";
  }
  return JSON.stringify(v);
}
function formatAnnotationValue(a) {
  if (a.name === "primary") return a.value;
  if (a.name === "id" && typeof a.value === "string") return "#" + a.value;
  if (a.type === "class") return "." + a.name;
  return `${a.name}=${formatScalar(a.value)}`;
}
function* formatAttributes(n) {
  for (const [key, value] of Object.entries(n.attributes)) {
    if (key === "class" && !ast_default.isAst(value)) for (const name of Object.keys(value)) {
      yield formatAnnotationValue({
        type: "class",
        name,
        value
      });
    } else yield formatAnnotationValue({
      type: "attribute",
      name: key,
      value
    });
  }
}
function* formatAnnotations(n) {
  if (n.annotations.length) {
    yield OPEN + SPACE;
    yield n.annotations.map(formatAnnotationValue).join(SPACE);
    yield SPACE + CLOSE;
  }
}
function* formatVariable(v) {
  yield "$";
  yield v.path.join(".");
}
function* formatFunction(f) {
  yield f.name;
  yield "(";
  yield Object.values(f.parameters).map(formatScalar).join(SEP);
  yield ")";
}
function* trimStart(g) {
  let n;
  do {
    n = g.next().value.trimStart();
  } while (!n.length);
  yield n;
  yield* g;
}
function* formatNode(n, o = {}) {
  const no = {
    ...o,
    parent: n
  };
  const indent = SPACE.repeat(no.indent || 0);
  switch (n.type) {
    case "document":
      {
        if (n.attributes.frontmatter && n.attributes.frontmatter.length) {
          yield "---" + NL + n.attributes.frontmatter + NL + "---" + NL + NL;
        }
        yield* trimStart(formatChildren(n, no));
        break;
      }
    case "heading":
      {
        yield NL;
        yield indent;
        yield "#".repeat(n.attributes.level || 1);
        yield SPACE;
        yield* formatChildren(n, no);
        yield* formatAnnotations(n);
        yield NL;
        break;
      }
    case "paragraph":
      {
        yield NL;
        yield indent;
        yield* formatChildren(n, no);
        yield* formatAnnotations(n);
        yield NL;
        break;
      }
    case "inline":
      {
        yield* formatChildren(n, no);
        break;
      }
    case "link":
      {
        yield "[";
        yield* formatChildren(n, no);
        yield "]";
        yield "(";
        yield* formatValue(n.attributes.href, no);
        yield ")";
        break;
      }
    case "text":
      {
        if (ast_default.isAst(n.attributes.content)) yield OPEN + SPACE;
        yield* formatValue(n.attributes.content, no);
        if (ast_default.isAst(n.attributes.content)) yield SPACE + CLOSE;
        break;
      }
    case "blockquote":
      {
        yield NL;
        yield indent;
        yield "> ";
        yield* trimStart(formatChildren(n, no));
        break;
      }
    case "hr":
      {
        yield NL;
        yield indent;
        yield "---";
        yield NL;
        break;
      }
    case "image":
      {
        yield "!";
        yield "[";
        yield* formatValue(n.attributes.alt, no);
        yield "]";
        yield "(";
        yield* formatValue(n.attributes.src, no);
        yield ")";
        break;
      }
    case "fence":
      {
        yield NL;
        yield indent;
        yield "```";
        yield (n.attributes.language || "").toLowerCase();
        if (n.annotations.length) yield SPACE;
        yield* formatAnnotations(n);
        yield NL;
        yield indent;
        yield* formatChildren(n, no);
        yield indent;
        yield "```";
        yield NL;
        break;
      }
    case "tag":
      {
        if (!n.inline) {
          yield NL;
          yield indent;
        }
        const open = OPEN + SPACE;
        const tag = [open + n.tag, ...formatAttributes(n)];
        const inlineTag = tag.join(SPACE);
        if (inlineTag.length + open.length * 2 > MAX_TAG_HEAD_LENGTH) {
          yield tag.join(NL + SPACE.repeat(open.length) + indent);
        } else {
          yield inlineTag;
        }
        yield SPACE + (n.children.length ? "" : "/") + CLOSE;
        if (n.children.length) {
          yield* formatChildren(n, no.allowIndentation ? increment(no) : no);
          if (!n.inline) {
            yield indent;
          }
          yield OPEN + SPACE + "/";
          yield n.tag;
          yield SPACE + CLOSE;
        }
        if (!n.inline) {
          yield NL;
        }
        break;
      }
    case "list":
      {
        const prefix = n.attributes.ordered ? OL : UL;
        yield NL;
        for (const child of n.children) {
          const d = format(child, increment(no, prefix.length)).trim();
          yield indent + prefix + d;
          yield NL;
        }
        break;
      }
    case "item":
      {
        yield* formatChildren(n, no);
        yield* formatAnnotations(n);
        break;
      }
    case "strong":
      {
        yield "**";
        yield* formatChildren(n, no);
        yield "**";
        break;
      }
    case "em":
      {
        yield "_";
        yield* formatChildren(n, no);
        yield "_";
        break;
      }
    case "code":
      {
        yield "`";
        yield* formatValue(n.attributes.content, no);
        yield "`";
        break;
      }
    case "s":
      {
        yield "~~";
        yield* formatChildren(n, no);
        yield "~~";
        break;
      }
    case "hardbreak":
      {
        yield "\\" + NL;
        yield indent;
        break;
      }
    case "softbreak":
      {
        yield NL;
        yield indent;
        break;
      }
    case "table":
      {
        const table3 = [...formatChildren(n, increment(no))];
        if (o.parent && o.parent.type === "tag" && o.parent.tag === "table") {
          for (const row of table3) {
            yield NL;
            for (const d of row) {
              yield indent + UL + d.trim();
              yield NL;
            }
            if (row !== table3[table3.length - 1]) {
              yield indent + "---";
            }
          }
        } else {
          yield NL;
          const [head, ...rows] = table3;
          const ml = table3.map(arr => arr.map(s2 => s2.length).reduce(max)).reduce(max);
          yield* formatTableRow(head.map(h => h + SPACE.repeat(ml - h.length)));
          yield NL;
          yield* formatTableRow(head.map(() => "-".repeat(ml)));
          yield NL;
          for (const row of rows) {
            yield* formatTableRow(row.map(r => r + SPACE.repeat(ml - r.length)));
            yield NL;
          }
        }
        break;
      }
    case "thead":
      {
        const [head] = [...formatChildren(n, no)];
        yield head || [];
        break;
      }
    case "tr":
      {
        yield [...formatChildren(n, no)];
        break;
      }
    case "td":
    case "th":
      {
        yield [...formatChildren(n, no), ...formatAnnotations(n)].join("");
        break;
      }
    case "tbody":
      {
        yield* formatChildren(n, no);
        break;
      }
    case "error":
      {
        console.error(n);
        break;
      }
  }
}
function* formatValue(v, o = {}) {
  switch (typeof v) {
    case "undefined":
      break;
    case "boolean":
    case "number":
    case "string":
      {
        yield v.toString();
        break;
      }
    case "object":
      {
        if (v === null) break;
        if (Array.isArray(v)) {
          for (const n of v) yield* formatValue(n, o);
          break;
        }
        switch (v.$$mdtype) {
          case "Function":
            {
              yield* formatFunction(v);
              break;
            }
          case "Node":
            yield* formatNode(v, o);
            break;
          case "Variable":
            {
              yield* formatVariable(v);
              break;
            }
          default:
            throw new Error(`Unimplemented: "${v.$$mdtype}"`);
        }
        break;
      }
  }
}
function format(v, options) {
  let doc = "";
  for (const s2 of formatValue(v, options)) doc += s2;
  return doc;
}

// src/tags/conditional.ts
function truthy(value) {
  return value !== false && value !== void 0 && value !== null;
}
function renderConditions(node2) {
  const conditions = [{
    condition: node2.attributes.primary,
    children: []
  }];
  for (const child of node2.children) {
    if (child.type === "tag" && child.tag === "else") conditions.push({
      condition: "primary" in child.attributes ? child.attributes.primary : true,
      children: []
    });else conditions[conditions.length - 1].children.push(child);
  }
  return conditions;
}
var tagIf = {
  attributes: {
    primary: {
      type: Object,
      render: false
    }
  },
  transform(node2, config) {
    const conditions = renderConditions(node2);
    for (const {
      condition,
      children
    } of conditions) if (truthy(condition)) {
      const nodes = children.flatMap(child => child.transform(config));
      if (nodes.some(isPromise)) {
        return Promise.all(nodes).then(nodes2 => nodes2.flat());
      }
      return nodes;
    }
    return [];
  }
};
var tagElse = {
  selfClosing: true,
  attributes: {
    primary: {
      type: Object,
      render: false
    }
  }
};

// src/functions/index.ts
var and = {
  transform(parameters) {
    return Object.values(parameters).every(x => truthy(x));
  }
};
var or = {
  transform(parameters) {
    return Object.values(parameters).find(x => truthy(x)) !== void 0;
  }
};
var not = {
  parameters: {
    0: {
      required: true
    }
  },
  transform(parameters) {
    return !truthy(parameters[0]);
  }
};
var equals = {
  transform(parameters) {
    const values = Object.values(parameters);
    return values.every(v => v === values[0]);
  }
};
var debug = {
  transform(parameters) {
    return JSON.stringify(parameters[0], null, 2);
  }
};
var defaultFn = {
  transform(parameters) {
    return parameters[0] === void 0 ? parameters[1] : parameters[0];
  }
};
var functions_default = {
  and,
  or,
  not,
  equals,
  default: defaultFn,
  debug
};

// src/transforms/table.ts
function convertToRow(node2, cellType = "td") {
  node2.type = "tr";
  node2.attributes = {};
  for (const cell of node2.children) cell.type = cellType;
  return node2;
}
function transform(document2) {
  for (const node2 of document2.walk()) {
    if (node2.type !== "tag" || node2.tag !== "table") continue;
    const [first, ...rest] = node2.children;
    if (!first || first.type === "table") continue;
    const table3 = new ast_default.Node("table", node2.attributes, [new ast_default.Node("thead"), new ast_default.Node("tbody")]);
    const [thead2, tbody2] = table3.children;
    if (first.type === "list") thead2.push(convertToRow(first, "th"));
    for (const row of rest) {
      if (row.type === "list") convertToRow(row);else if (row.type === "tag" && row.tag === "if") {
        const children = [];
        for (const child of row.children) {
          if (child.type === "hr") continue;
          if (child.type === "list") convertToRow(child);
          children.push(child);
        }
        row.children = children;
      } else continue;
      tbody2.push(row);
    }
    node2.children = [table3];
  }
}

// src/transforms/index.ts
var transforms_default = [transform];

// src/parser.ts
var mappings = {
  ordered_list: "list",
  bullet_list: "list",
  code_inline: "code",
  list_item: "item",
  variable: "text",
  html_block: "html",
  html_inline: "html"
};
function annotate(node2, attributes) {
  for (const attribute of attributes) {
    node2.annotations.push(attribute);
    const {
      name,
      value,
      type
    } = attribute;
    if (type === "attribute") node2.attributes[name] = value;else if (type === "class") if (node2.attributes.class) node2.attributes.class[name] = value;else node2.attributes.class = {
      [name]: value
    };
  }
}
function handleAttrs(token, type) {
  switch (type) {
    case "heading":
      return {
        level: Number(token.tag.replace("h", ""))
      };
    case "list":
      return {
        ordered: token.type.startsWith("ordered")
      };
    case "link":
      {
        const attrs = Object.fromEntries(token.attrs);
        return attrs.title ? {
          href: attrs.href,
          title: attrs.title
        } : {
          href: attrs.href
        };
      }
    case "image":
      {
        const attrs = Object.fromEntries(token.attrs);
        return attrs.title ? {
          alt: token.content,
          src: attrs.src,
          title: attrs.title
        } : {
          alt: token.content,
          src: attrs.src
        };
      }
    case "text":
    case "code":
    case "html":
      return {
        content: (token.meta || {}).variable || token.content
      };
    case "fence":
      {
        const [language] = token.info.split(" ", 1);
        return language === "" ? {
          content: token.content
        } : {
          content: token.content,
          language
        };
      }
    case "td":
    case "th":
      {
        if (token.attrs) {
          const attrs = Object.fromEntries(token.attrs);
          let align;
          if (attrs.style) {
            if (attrs.style.includes("left")) {
              align = "left";
            } else if (attrs.style.includes("center")) {
              align = "center";
            } else if (attrs.style.includes("right")) {
              align = "right";
            }
          }
          if (align) {
            return {
              align
            };
          }
        }
        return {};
      }
    default:
      return {};
  }
}
function handleToken(token, nodes, file, inlineParent) {
  if (token.type === "frontmatter") {
    nodes[0].attributes.frontmatter = token.content;
    return;
  }
  if (token.hidden || token.type === "text" && token.content === "") return;
  const errors = token.errors || [];
  const parent = nodes[nodes.length - 1];
  const {
    tag,
    attributes,
    error: error2
  } = token.meta || {};
  if (token.type === "annotation") {
    if (inlineParent) return annotate(inlineParent, attributes);
    return parent.errors.push({
      id: "no-inline-annotations",
      level: "error",
      message: `Can't apply inline annotations to '${parent.type}'`
    });
  }
  let typeName = token.type.replace(/_(open|close)$/, "");
  if (mappings[typeName]) typeName = mappings[typeName];
  if (typeName === "error") {
    const {
      message,
      location
    } = error2;
    errors.push({
      id: "parse-error",
      level: "critical",
      message,
      location
    });
  }
  if (token.nesting < 0) {
    if (parent.type === typeName) {
      if (parent.lines && token.map) parent.lines.push(...token.map);
      return nodes.pop();
    }
    errors.push({
      id: "missing-opening",
      level: "critical",
      message: `Node '${typeName}' is missing opening`
    });
  }
  const attrs = handleAttrs(token, typeName);
  const node2 = new Node(typeName, attrs, void 0, tag || void 0);
  const {
    position = {}
  } = token;
  node2.errors = errors;
  node2.lines = token.map || parent.lines || [];
  node2.location = {
    file,
    start: {
      line: node2.lines[0],
      character: position.start
    },
    end: {
      line: node2.lines[1],
      character: position.end
    }
  };
  if (inlineParent) node2.inline = true;
  if (attributes && ["tag", "fence", "image"].includes(typeName)) annotate(node2, attributes);
  parent.push(node2);
  if (token.nesting > 0) nodes.push(node2);
  if (!Array.isArray(token.children)) return;
  inlineParent = parent;
  nodes.push(node2);
  const isLeafNode = typeName === "image";
  if (!isLeafNode) {
    for (const child of token.children) handleToken(child, nodes, file, inlineParent);
  }
  nodes.pop();
}
function parser$1(tokens, file) {
  const doc = new Node("document");
  const nodes = [doc];
  for (const token of tokens) handleToken(token, nodes, file);
  if (nodes.length > 1) for (const node2 of nodes.slice(1)) node2.errors.push({
    id: "missing-closing",
    level: "critical",
    message: `Node '${node2.tag || node2.type}' is missing closing`
  });
  for (const transform3 of transforms_default) transform3(doc);
  return doc;
}

// src/schema.ts
var schema_exports = {};
__export(schema_exports, {
  blockquote: () => blockquote,
  code: () => code,
  document: () => document$1,
  em: () => em,
  error: () => error,
  fence: () => fence$1,
  hardbreak: () => hardbreak,
  heading: () => heading$1,
  hr: () => hr,
  html: () => html$1,
  image: () => image$1,
  inline: () => inline,
  item: () => item,
  link: () => link$1,
  list: () => list,
  node: () => node$1,
  paragraph: () => paragraph,
  s: () => s$1,
  softbreak: () => softbreak,
  strong: () => strong,
  table: () => table,
  tbody: () => tbody,
  td: () => td,
  text: () => text,
  th: () => th,
  thead: () => thead,
  tr: () => tr
});

// src/ast/raw.ts
var Raw = class {
  constructor(content, inline3) {
    this.$$mdtype = "Raw";
    this.content = content;
    this.inline = inline3;
  }
};

// src/schema.ts
var document$1 = {
  render: "article",
  children: ["heading", "paragraph", "image", "table", "tag", "fence", "blockquote", "list", "hr"],
  attributes: {
    frontmatter: {
      render: false
    }
  }
};
var heading$1 = {
  children: ["inline"],
  attributes: {
    level: {
      type: Number,
      render: false,
      required: true
    }
  },
  transform(node2, config) {
    return new Tag(`h${node2.attributes["level"]}`, node2.transformAttributes(config), node2.transformChildren(config));
  }
};
var paragraph = {
  render: "p",
  children: ["inline"]
};
var image$1 = {
  render: "img",
  attributes: {
    src: {
      type: String,
      required: true
    },
    alt: {
      type: String
    },
    title: {
      type: String
    }
  }
};
var fence$1 = {
  render: "pre",
  attributes: {
    content: {
      type: String,
      render: false,
      required: true
    },
    language: {
      type: String,
      render: "data-language"
    },
    process: {
      type: Boolean,
      render: false,
      default: true
    }
  },
  transform(node2, config) {
    const attributes = node2.transformAttributes(config);
    const children = node2.children.length ? node2.transformChildren(config) : [node2.attributes.content];
    return new Tag("pre", attributes, children);
  }
};
var blockquote = {
  render: "blockquote",
  children: ["heading", "paragraph", "image", "table", "tag", "fence", "blockquote", "list", "hr"]
};
var item = {
  render: "li",
  children: ["inline", "heading", "paragraph", "image", "table", "tag", "fence", "blockquote", "list", "hr"]
};
var list = {
  children: ["item"],
  attributes: {
    ordered: {
      type: Boolean,
      render: false,
      required: true
    }
  },
  transform(node2, config) {
    return new Tag(node2.attributes.ordered ? "ol" : "ul", node2.transformAttributes(config), node2.transformChildren(config));
  }
};
var hr = {
  render: "hr"
};
var table = {
  render: "table"
};
var td = {
  render: "td",
  children: ["inline", "heading", "paragraph", "image", "table", "tag", "fence", "blockquote", "list", "hr"],
  attributes: {
    colspan: {
      type: Number
    },
    rowspan: {
      type: Number
    },
    align: {
      type: String
    }
  }
};
var th = {
  render: "th",
  attributes: {
    width: {
      type: Number
    },
    align: {
      type: String
    }
  }
};
var tr = {
  render: "tr",
  children: ["th", "td"]
};
var tbody = {
  render: "tbody",
  children: ["tr", "tag"]
};
var thead = {
  render: "thead",
  children: ["tr"]
};
var strong = {
  render: "strong",
  children: ["em", "s", "link", "code", "text", "tag"]
};
var em = {
  render: "em",
  children: ["strong", "s", "link", "code", "text", "tag"]
};
var s$1 = {
  render: "s",
  children: ["strong", "em", "link", "code", "text", "tag"]
};
var inline = {
  children: ["strong", "em", "s", "code", "text", "tag", "link", "image", "hardbreak", "softbreak"]
};
var link$1 = {
  render: "a",
  children: ["strong", "em", "s", "code", "text", "tag"],
  attributes: {
    href: {
      type: String,
      required: true
    },
    title: {
      type: String
    }
  }
};
var code = {
  render: "code",
  attributes: {
    content: {
      type: String,
      render: false,
      required: true
    }
  },
  transform(node2, config) {
    const attributes = node2.transformAttributes(config);
    return new Tag("code", attributes, [node2.attributes.content]);
  }
};
var text = {
  attributes: {
    content: {
      type: String,
      required: true
    }
  },
  transform(node2) {
    return node2.attributes.content;
  }
};
var hardbreak = {
  render: "br"
};
var softbreak = {
  transform(_node, _config) {
    return " ";
  }
};
var html$1 = {
  attributes: {
    content: {
      type: String,
      required: true
    }
  },
  transform(node2) {
    return node2.attributes.content ? new Raw(node2.attributes.content, node2.inline) : null;
  }
};
var error = {};
var node$1 = {};

// src/renderers/html.ts
var import_markdown_it = __toModule(require_markdown_it());
var {
  escapeHtml
} = (0, import_markdown_it.default)().utils;
var voidElements$1 = new Set(["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"]);
function render(node2) {
  if (typeof node2 === "string") return escapeHtml(node2);
  if (Array.isArray(node2)) return node2.map(render).join("");
  if (node2 === null || typeof node2 !== "object") return "";
  if (node2.$$mdtype === "Raw") return node2.content;
  const {
    name,
    attributes,
    children = []
  } = node2;
  if (!name) return render(children);
  let output = `<${name}`;
  for (const [k, v] of Object.entries(attributes ?? {})) output += ` ${k}="${escapeHtml(String(v))}"`;
  output += ">";
  if (voidElements$1.has(name)) return output;
  if (children.length) output += render(children);
  output += `</${name}>`;
  return output;
}

// src/renderers/react/shared.ts
function tagName(name, components) {
  return typeof name !== "string" ? "Fragment" : name[0] !== name[0].toUpperCase() ? name : components instanceof Function ? components(name) : components[name];
}

// src/renderers/react/react.ts
function dynamic(node2, React, {
  components = {}
} = {}, raw) {
  function deepRender(value) {
    if (value == null || typeof value !== "object") return value;
    if (Array.isArray(value)) return value.map(item2 => deepRender(item2));
    if (["Tag", "Raw"].includes(value.$$mdtype)) return render2(value);
    if (typeof value !== "object") return value;
    const output = {};
    for (const [k, v] of Object.entries(value)) output[k] = deepRender(v);
    return output;
  }
  function render2(node3) {
    if (Array.isArray(node3)) return React.createElement(React.Fragment, null, ...node3.map(render2));
    if (node3 === null || typeof node3 !== "object") return node3;
    if (node3.$$mdtype === "Raw") return raw?.(node3.content, node3.inline);
    const {
      name,
      attributes: {
        class: className,
        ...attrs
      } = {},
      children = []
    } = node3;
    if (className) attrs.className = className;
    return React.createElement(tagName(name, components), Object.keys(attrs).length == 0 ? null : deepRender(attrs), ...children.map(render2));
  }
  return render2(node2);
}

// src/renderers/react/static.ts
function reactStatic(node2, raw) {
  function renderArray(children) {
    return children.map(render2).join(", ");
  }
  function deepRender(value) {
    if (value == null || typeof value !== "object") return JSON.stringify(value);
    if (Array.isArray(value)) return `[${value.map(item2 => deepRender(item2)).join(", ")}]`;
    if (["Tag", "Raw"].includes(value.$$mdtype)) return render2(value);
    if (typeof value !== "object") return JSON.stringify(value);
    const object = Object.entries(value).map(([k, v]) => [JSON.stringify(k), deepRender(v)].join(": ")).join(", ");
    return `{${object}}`;
  }
  function render2(node3) {
    if (Array.isArray(node3)) return `React.createElement(React.Fragment, null, ${renderArray(node3)})`;
    if (node3 === null || typeof node3 !== "object") return JSON.stringify(node3);
    if (node3.$$mdtype === "Raw") return raw?.(node3.content, node3.inline) ?? "";
    const {
      name,
      attributes: {
        class: className,
        ...attrs
      } = {},
      children = []
    } = node3;
    if (className) attrs.className = className;
    return `React.createElement(
    tagName(${JSON.stringify(name)}, components),
    ${Object.keys(attrs).length == 0 ? "null" : deepRender(attrs)},
    ${renderArray(children)})`;
  }
  return `
  (({components = {}} = {}) => {
    ${tagName}
    return ${render2(node2)};
  })
`;
}

// src/renderers/index.ts
var renderers_default = {
  html: render,
  react: dynamic,
  reactStatic
};

// src/tags/partial.ts
var PartialFile = class {
  validate(file, config) {
    const {
      partials = {}
    } = config;
    const partial2 = partials[file];
    if (!partial2) return [{
      id: "attribute-value-invalid",
      level: "error",
      message: `Partial \`${file}\` not found. The 'file' attribute must be set in \`config.partials\``
    }];
    return [];
  }
};
var partial = {
  selfClosing: true,
  attributes: {
    file: {
      type: PartialFile,
      render: false,
      required: true
    },
    variables: {
      type: Object,
      render: false
    }
  },
  transform(node2, config) {
    const {
      partials = {}
    } = config;
    const {
      file,
      variables
    } = node2.attributes;
    const partial2 = partials[file];
    if (!partial2) return null;
    const scopedConfig = {
      ...config,
      variables: {
        ...config.variables,
        ...variables,
        ["$$partial:filename"]: file
      }
    };
    const transformChildren = part => part.resolve(scopedConfig).transformChildren(scopedConfig);
    return Array.isArray(partial2) ? partial2.flatMap(transformChildren) : transformChildren(partial2);
  }
};

// src/tags/table.ts
var table2 = {
  children: ["table"]
};

// src/tags/index.ts
var tags_default = {
  if: tagIf,
  else: tagElse,
  partial,
  table: table2
};

// src/tokenizer/index.ts
var import_lib = __toModule(require_lib());

// src/tokenizer/plugins/annotations.ts
var import_tag4 = __toModule(require_tag());
function createToken(state, content, contentStart) {
  try {
    const {
      type,
      meta,
      nesting = 0
    } = (0, import_tag4.parse)(content, {
      Variable,
      Function: Function2
    });
    const token = state.push(type, "", nesting);
    token.info = content;
    token.meta = meta;
    if (!state.delimiters) {
      state.delimiters = [];
    }
    return token;
  } catch (error2) {
    if (!(error2 instanceof import_tag4.SyntaxError)) throw error2;
    const {
      message,
      location: {
        start,
        end
      }
    } = error2;
    const location = contentStart ? {
      start: {
        offset: start.offset + contentStart
      },
      end: {
        offset: end.offset + contentStart
      }
    } : null;
    const token = state.push("error", "", 0);
    token.meta = {
      error: {
        message,
        location
      }
    };
    return token;
  }
}
function block(state, startLine, endLine, silent) {
  const start = state.bMarks[startLine] + state.tShift[startLine];
  const finish = state.eMarks[startLine];
  if (!state.src.startsWith(OPEN, start)) return false;
  const tagEnd = findTagEnd(state.src, start);
  const lastPossible = state.src.slice(0, finish).trim().length;
  if (!tagEnd || tagEnd < lastPossible - CLOSE.length) return false;
  const contentStart = start + OPEN.length;
  const content = state.src.slice(contentStart, tagEnd).trim();
  const lines = content.split("\n").length;
  if (content[0] === "$") return false;
  if (silent) return true;
  const token = createToken(state, content, contentStart);
  token.map = [startLine, startLine + lines];
  state.line += lines;
  return true;
}
function inline2(state, silent) {
  if (!state.src.startsWith(OPEN, state.pos)) return false;
  const tagEnd = findTagEnd(state.src, state.pos);
  if (!tagEnd) return false;
  const content = state.src.slice(state.pos + OPEN.length, tagEnd);
  if (!silent) createToken(state, content.trim());
  state.pos = tagEnd + CLOSE.length;
  return true;
}
function core$1(state) {
  let token;
  for (token of state.tokens) {
    if (token.type !== "fence") continue;
    if (token.info.includes(OPEN)) {
      const start = token.info.indexOf(OPEN);
      const end = findTagEnd(token.info, start);
      const content = token.info.slice(start + OPEN.length, end);
      try {
        const {
          meta
        } = (0, import_tag4.parse)(content.trim(), {
          Variable,
          Function: Function2
        });
        token.meta = meta;
      } catch (error2) {
        if (!(error2 instanceof import_tag4.SyntaxError)) throw error2;
        if (!token.errors) token.errors = [];
        token.errors.push({
          id: "fence-tag-error",
          level: "error",
          message: `Syntax error in fence tag: ${error2.message}`
        });
      }
    }
    if (token?.meta?.attributes?.find(attr => attr.name === "process" && !attr.value)) continue;
    token.children = parseTags(token.content, token.map[0]);
  }
}
function plugin(md) {
  md.block.ruler.before("paragraph", "annotations", block, {
    alt: ["paragraph", "blockquote"]
  });
  md.inline.ruler.push("containers", inline2);
  md.core.ruler.push("annotations", core$1);
}

// src/tokenizer/plugins/frontmatter.ts
var fence2 = "---";
function getLine(state, n) {
  return state.src.slice(state.bMarks[n], state.eMarks[n]).trim();
}
function findClose(state, endLine) {
  for (let line = 1; line < endLine; line++) if (getLine(state, line) === fence2) return line;
}
function block2(state, startLine, endLine, silent) {
  if (startLine != 0 || getLine(state, 0) != fence2) return false;
  const close = findClose(state, endLine);
  if (!close) return false;
  if (silent) return true;
  const token = state.push("frontmatter", "", 0);
  token.content = state.src.slice(state.eMarks[0], state.bMarks[close]).trim();
  token.map = [0, close];
  token.hidden = true;
  state.line = close + 1;
  return true;
}
function plugin2(md) {
  md.block.ruler.before("hr", "frontmatter", block2);
}

// src/tokenizer/index.ts
var Tokenizer$2 = class {
  constructor(config = {}) {
    this.parser = new import_lib.default(config);
    this.parser.use(plugin, "annotations", {});
    this.parser.use(plugin2, "frontmatter", {});
    this.parser.use(require_markdown_it_sup());
    this.parser.disable(["lheading", "code"]);
  }
  tokenize(content) {
    return this.parser.parse(content.toString(), {});
  }
};

// src/validator.ts
var TypeMappings = {
  String,
  Number,
  Array,
  Object,
  Boolean
};
function validateType(type, value, config) {
  if (!type) return true;
  if (ast_default.isFunction(value) && config.validation?.validateFunctions) {
    const schema = config.functions?.[value.name];
    return !schema?.returns ? true : Array.isArray(schema.returns) ? schema.returns.find(t => t === type) !== void 0 : schema.returns === type;
  }
  if (ast_default.isAst(value)) return true;
  if (Array.isArray(type)) return type.some(t => validateType(t, value, config));
  if (typeof type === "string") type = TypeMappings[type];
  if (typeof type === "function") {
    const instance = new type();
    if (instance.validate) {
      return instance.validate(value, config);
    }
  }
  return value != null && value.constructor === type;
}
function typeToString(type) {
  if (typeof type === "string") return type;
  if (Array.isArray(type)) return type.map(typeToString).join(" | ");
  return type.name;
}
function validateFunction(fn, config) {
  const schema = config.functions?.[fn.name];
  const errors = [];
  if (!schema) return [{
    id: "function-undefined",
    level: "critical",
    message: `Undefined function: '${fn.name}'`
  }];
  if (schema.validate) errors.push(...schema.validate(fn, config));
  if (schema.parameters) {
    for (const [key, value] of Object.entries(fn.parameters)) {
      const param = schema.parameters?.[key];
      if (!param) {
        errors.push({
          id: "parameter-undefined",
          level: "error",
          message: `Invalid parameter: '${key}'`
        });
        continue;
      }
      if (ast_default.isAst(value) && !ast_default.isFunction(value)) continue;
      if (param.type) {
        const valid = validateType(param.type, value, config);
        if (valid === false) {
          errors.push({
            id: "parameter-type-invalid",
            level: "error",
            message: `Parameter '${key}' of '${fn.name}' must be type of '${typeToString(param.type)}'`
          });
        } else if (Array.isArray(valid)) {
          errors.push(...valid);
        }
      }
    }
  }
  for (const [key, {
    required
  }] of Object.entries(schema.parameters ?? {})) if (required && fn.parameters[key] === void 0) errors.push({
    id: "parameter-missing-required",
    level: "error",
    message: `Missing required parameter: '${key}'`
  });
  return errors;
}
function validate(node2, config) {
  const schema = node2.findSchema(config);
  const errors = [...(node2.errors || [])];
  if (!schema) {
    errors.push({
      id: node2.tag ? "tag-undefined" : "node-undefined",
      level: "critical",
      message: node2.tag ? `Undefined tag: '${node2.tag}'` : `Undefined node: '${node2.type}'`
    });
    return errors;
  }
  if (schema.selfClosing && node2.children.length > 0) errors.push({
    id: "tag-selfclosing-has-children",
    level: "critical",
    message: `'${node2.tag}' tag should be self-closing`
  });
  const attributes = {
    ...globalAttributes,
    ...schema.attributes
  };
  if (schema.validate) errors.push(...schema.validate(node2, config));
  for (let [key, value] of Object.entries(node2.attributes)) {
    const attrib = attributes[key];
    if (!attrib) {
      errors.push({
        id: "attribute-undefined",
        level: "error",
        message: `Invalid attribute: '${key}'`
      });
      continue;
    }
    let {
      type,
      matches,
      errorLevel
    } = attrib;
    if (ast_default.isAst(value)) {
      if (ast_default.isFunction(value) && config.validation?.validateFunctions) errors.push(...validateFunction(value, config));else if (ast_default.isVariable(value) && config.variables) {
        let missing = false;
        let variables = config.variables;
        for (const key2 of value.path) {
          if (!Object.prototype.hasOwnProperty.call(variables, key2)) {
            missing = true;
            break;
          }
          variables = variables[key2];
        }
        if (missing) {
          errors.push({
            id: "variable-undefined",
            level: "error",
            message: `Undefined variable: '${value.path.join(".")}'`
          });
        }
      } else continue;
    }
    value = value;
    if (key === "id" && value.match(/^[0-9]/)) errors.push({
      id: "attribute-value-invalid",
      level: "error",
      message: "The id attribute must not start with a number"
    });
    if (type) {
      const valid = validateType(type, value, config);
      if (valid === false) {
        errors.push({
          id: "attribute-type-invalid",
          level: errorLevel || "error",
          message: `Attribute '${key}' must be type of '${typeToString(type)}'`
        });
      }
      if (Array.isArray(valid)) {
        errors.push(...valid);
      }
    }
    if (typeof matches === "function") matches = matches(config);
    if (Array.isArray(matches) && !matches.includes(value)) errors.push({
      id: "attribute-value-invalid",
      level: errorLevel || "error",
      message: `Attribute '${key}' must match one of ${JSON.stringify(matches)}`
    });
    if (matches instanceof RegExp && !matches.test(value)) errors.push({
      id: "attribute-value-invalid",
      level: errorLevel || "error",
      message: `Attribute '${key}' must match ${matches}`
    });
  }
  for (const [key, {
    required
  }] of Object.entries(attributes)) if (required && node2.attributes[key] === void 0) errors.push({
    id: "attribute-missing-required",
    level: "error",
    message: `Missing required attribute: '${key}'`
  });
  for (const {
    type
  } of node2.children) {
    if (schema.children && type !== "error" && !schema.children.includes(type)) errors.push({
      id: "child-invalid",
      level: "warning",
      message: `Can't nest '${type}' in '${node2.tag || node2.type}'`
    });
  }
  return errors;
}

// index.ts
var tokenizer = new Tokenizer$2();
function mergeConfig(config = {}) {
  return {
    ...config,
    tags: {
      ...tags_default,
      ...config.tags
    },
    nodes: {
      ...schema_exports,
      ...config.nodes
    },
    functions: {
      ...functions_default,
      ...config.functions
    }
  };
}
function parse3(content, file) {
  if (typeof content === "string") content = tokenizer.tokenize(content);
  return parser$1(content, file);
}
function resolve2(content, config) {
  if (Array.isArray(content)) return content.flatMap(child => child.resolve(config));
  return content.resolve(config);
}
function transform2(nodes, options) {
  const config = mergeConfig(options);
  const content = resolve2(nodes, config);
  if (Array.isArray(content)) return content.flatMap(child => child.transform(config));
  return content.transform(config);
}
function validate2(content, options) {
  const config = mergeConfig(options);
  const output = [];
  for (const node2 of [content, ...content.walk()]) {
    const {
      type,
      lines,
      location
    } = node2;
    const errors = validate(node2, config);
    for (const error2 of errors) output.push({
      type,
      lines,
      location,
      error: error2
    });
  }
  return output;
}
function createElement(name, attributes = {}, ...children) {
  return {
    name,
    attributes,
    children
  };
}
var Markdoc = class {
  constructor(config) {
    this.parse = parse3;
    this.resolve = content => resolve2(content, this.config);
    this.transform = content => transform2(content, this.config);
    this.validate = content => validate2(content, this.config);
    this.config = config;
  }
};
Markdoc.nodes = schema_exports;
Markdoc.tags = tags_default;
Markdoc.functions = functions_default;
Markdoc.globalAttributes = globalAttributes;
Markdoc.renderers = renderers_default;
Markdoc.transforms = transforms_default;
Markdoc.Ast = ast_default;
Markdoc.Tag = Tag;
Markdoc.Tokenizer = Tokenizer$2;
Markdoc.parseTags = parseTags;
Markdoc.transformer = transformer_default;
Markdoc.validator = validate;
Markdoc.parse = parse3;
Markdoc.transform = transform2;
Markdoc.validate = validate2;
Markdoc.createElement = createElement;
Markdoc.truthy = truthy;
Markdoc.__EXPERIMENTAL__format = format;

const heading = {
  children: ["inline"],
  attributes: {
    id: {
      type: String
    },
    level: {
      type: Number,
      required: true,
      default: 1
    }
  },
  transform(node, config) {
    const attributes = node.transformAttributes(config);
    const children = node.transformChildren(config);
    return new Tag(`h${node.attributes["level"]}`, {
      ...attributes
    }, children);
  }
};

const footnoteRef = {
  attributes: {
    id: {
      type: String,
      render: true,
      required: true
    },
    href: {
      type: String,
      render: true,
      required: true
    },
    label: {
      type: String,
      render: false,
      required: true
    }
  },
  transform(node, config) {
    const attributes = node.transformAttributes(config);
    const link = new Tag("a", attributes, [`${node.attributes.label}`]);
    return new Tag(`sup`, {
      class: "footnote-ref"
    }, [link]);
  }
};

const footnoteItem = {
  attributes: {
    id: {
      type: String,
      render: true,
      required: true
    },
    href: {
      type: String,
      render: false,
      required: true
    }
  },
  transform(node, config) {
    node.attributes.class = `footnote-item`;
    const anchor = new ast_default.Node("link", {
      class: "footnote-anchor",
      href: node.attributes.href
    }, [new ast_default.Node("text", {
      content: "↩"
    })]);
    node.push(anchor);
    return new Tag("li", node.transformAttributes(config), node.transformChildren(config));
  }
};

function checkIfExternal(attributes) {
  const href = attributes.href;
  if (href.includes("urbit.org") || href.startsWith("/") || href.startsWith("#") || href.startsWith("?")) {
    return "_self";
  } else {
    return "_blank";
  }
}
const link = {
  render: "NextLink",
  children: ["strong", "em", "s", "code", "text", "tag"],
  attributes: {
    href: {
      type: String,
      required: true
    },
    title: {
      type: String
    },
    target: {
      type: String
    }
  },
  transform(node, config) {
    const attributes = node.transformAttributes(config);
    const children = node.transformChildren(config);
    const target = checkIfExternal(attributes);
    return new Tag("NextLink", {
      ...attributes,
      target
    }, children);
  }
};

const math = {
  render: "Math",
  attributes: {
    block: {
      type: Boolean
    },
    className: {
      type: String
    }
  }
};

const image = {
  render: "span",
  attributes: {
    src: {
      type: String,
      required: true
    },
    alt: {
      type: String
    },
    title: {
      type: String
    }
  },
  transform(node, config) {
    const attributes = node.transformAttributes(config);
    const children = node.transformChildren(config);
    const imageTag = new Tag("img", attributes, children);
    return new Tag("span", {
      id: "figure"
    }, [imageTag]);
  }
};

const sup = {
  render: "superscript",
  children: ["strong", "em", "s", "code", "text", "tag"],
  attributes: {},
  transform(node, config) {
    return new Tag(`sup`, node.transformAttributes(config), node.transformChildren(config));
  }
};

const fence = {
  render: "Fence",
  attributes: {
    language: {
      type: String,
      description: "The programming language of the code block. Place it after the backticks."
    },
    copy: {
      type: Boolean,
      description: "Adds a copy button."
    },
    mode: {
      type: String,
      description: "Sets modes for code blocks. Specify either 'collapse' or 'scroll'."
    }
  }
};

const tab = {
  render: "Tab",
  attributes: {
    label: {
      type: String
    }
  }
};
const tabs = {
  render: "Tabs",
  attributes: {},
  transform(node, config) {
    const labels = node.transformChildren(config).filter(child => child && child.name === "Tab").map(tab => typeof tab === "object" ? tab.attributes.label : null);
    return new Tag(this.render, {
      labels
    }, node.transformChildren(config));
  }
};

const html = {
  render: "RenderHtml",
  attributes: {
    content: {
      type: String
    }
  },
  transform(node) {
    return node.attributes.content ? new Tag("RenderHtml", {
      content: node.attributes.content
    }, [node.inline]) : null;
  }
};

const button = {
  render: "Button",
  attributes: {
    label: {
      type: String
    },
    link: {
      type: String
    },
    color: {
      type: String
    }
  }
};

const callout = {
  render: "Callout",
  attributes: {
    title: {
      type: String
    },
    className: {
      type: String
    }
  }
};

const div = {
  render: "Div",
  attributes: {
    className: {
      type: String
    },
    title: {
      type: String
    },
    id: {
      type: String
    }
  }
};

const iframe = {
  render: "Iframe",
  attributes: {
    className: {
      type: String
    },
    height: {
      type: String
    },
    src: {
      type: String
    },
    width: {
      type: String
    }
  }
};

const TabContext = /*#__PURE__*/React__default["default"].createContext();
const Tabs = ({
  labels,
  children
}) => {
  const [currentTab, setCurrentTab] = React__default["default"].useState(labels[0]);
  return /*#__PURE__*/React__default["default"].createElement(TabContext.Provider, {
    value: currentTab
  }, /*#__PURE__*/React__default["default"].createElement("ul", {
    className: "flex items-center display cursor-pointer space-x-4"
  }, labels.map(label => /*#__PURE__*/React__default["default"].createElement("li", {
    className: "block bg-wall-100 tab rounded-xl " + (currentTab === label ? "font-semibold" : ""),
    key: label,
    onClick: () => setCurrentTab(label)
  }, label))), children);
};

const Tab = ({
  label,
  children
}) => {
  const currentTab = React__default["default"].useContext(TabContext);
  if (label !== currentTab) {
    return null;
  }
  return children;
};

const Button = ({
  label,
  link = "",
  color
}) => {
  return /*#__PURE__*/React__default["default"].createElement(Link__default["default"], {
    passHref: true,
    href: link
  }, /*#__PURE__*/React__default["default"].createElement("a", {
    className: "button-lg max-w-fit " + color
  }, label));
};

const Callout = ({
  title,
  children,
  className = "bg-wall-100"
}) => {
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: classNames("rounded-xl display !p-7 flex flex-col space-y-4", className)
  }, title && /*#__PURE__*/React__default["default"].createElement("h2", null, title), children);
};

function useCopyToClipboard(text, notifyTimeout = 1000) {
  const [copyStatus, setCopyStatus] = React$2.useState("inactive");
  const copy = React$2.useCallback(event => {
    event.stopPropagation();
    navigator.clipboard.writeText(text).then(() => setCopyStatus("copied"), () => setCopyStatus("failed"));
  }, [text]);
  React$2.useEffect(() => {
    if (copyStatus === "inactive") {
      return;
    }
    const timeoutId = setTimeout(() => setCopyStatus("inactive"), notifyTimeout);
    return () => clearTimeout(timeoutId);
  }, [copyStatus]);
  return [copyStatus, copy];
}

function Copy() {
  return /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "21",
    height: "21",
    viewBox: "0 0 21 21",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M3.67016 7.38696H11.9725C13.2071 7.38696 14.2176 8.39759 14.2176 9.63207V17.9344C14.2176 19.169 13.207 20.1795 11.9725 20.1795H3.67016C2.43559 20.1795 1.42505 19.1689 1.42505 17.9344V9.63207C1.42505 8.3975 2.43567 7.38696 3.67016 7.38696ZM9.02936 0.821102H17.3317C18.5663 0.821102 19.5768 1.83173 19.5768 3.06621V11.3686C19.5768 12.6031 18.5662 13.6137 17.3317 13.6137H15.1611V9.63186C15.1611 7.87885 13.7264 6.44406 11.9733 6.44406H6.78488V3.066C6.78488 1.83143 7.7955 0.820892 9.02999 0.820892L9.02936 0.821102Z",
    fill: "#AFAEAB"
  }));
}

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
/**
 * prism-react-renderer:
 * This file has been modified to remove:
 * - globals and window dependency
 * - worker support
 * - highlightAll and other element dependent methods
 * - _.hooks helpers
 * - UMD/node-specific hacks
 * It has also been run through prettier
 */

var Prism$2 = function () {
  // Private helper vars
  var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
  var uniqueId = 0;

  // The grammar object for plaintext
  var plainTextGrammar = {};
  var _ = {
    /**
     * A namespace for utility methods.
     *
     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
     * change or disappear at any time.
     *
     * @namespace
     * @memberof Prism
     */
    util: {
      encode: function encode(tokens) {
        if (tokens instanceof Token) {
          return new Token(tokens.type, encode(tokens.content), tokens.alias);
        } else if (Array.isArray(tokens)) {
          return tokens.map(encode);
        } else {
          return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
        }
      },
      /**
       * Returns the name of the type of the given value.
       *
       * @param {any} o
       * @returns {string}
       * @example
       * type(null)      === 'Null'
       * type(undefined) === 'Undefined'
       * type(123)       === 'Number'
       * type('foo')     === 'String'
       * type(true)      === 'Boolean'
       * type([1, 2])    === 'Array'
       * type({})        === 'Object'
       * type(String)    === 'Function'
       * type(/abc+/)    === 'RegExp'
       */
      type: function (o) {
        return Object.prototype.toString.call(o).slice(8, -1);
      },
      /**
       * Returns a unique number for the given object. Later calls will still return the same number.
       *
       * @param {Object} obj
       * @returns {number}
       */
      objId: function (obj) {
        if (!obj['__id']) {
          Object.defineProperty(obj, '__id', {
            value: ++uniqueId
          });
        }
        return obj['__id'];
      },
      /**
       * Creates a deep clone of the given object.
       *
       * The main intended use of this function is to clone language definitions.
       *
       * @param {T} o
       * @param {Record<number, any>} [visited]
       * @returns {T}
       * @template T
       */
      clone: function deepClone(o, visited) {
        visited = visited || {};
        var clone;
        var id;
        switch (_.util.type(o)) {
          case 'Object':
            id = _.util.objId(o);
            if (visited[id]) {
              return visited[id];
            }
            clone = /** @type {Record<string, any>} */{};
            visited[id] = clone;
            for (var key in o) {
              if (o.hasOwnProperty(key)) {
                clone[key] = deepClone(o[key], visited);
              }
            }
            return (/** @type {any} */clone
            );
          case 'Array':
            id = _.util.objId(o);
            if (visited[id]) {
              return visited[id];
            }
            clone = [];
            visited[id] = clone;
            /** @type {Array} */ /** @type {any} */o.forEach(function (v, i) {
              clone[i] = deepClone(v, visited);
            });
            return (/** @type {any} */clone
            );
          default:
            return o;
        }
      },
      /**
       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
       *
       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
       *
       * @param {Element} element
       * @returns {string}
       */
      getLanguage: function (element) {
        while (element) {
          var m = lang.exec(element.className);
          if (m) {
            return m[1].toLowerCase();
          }
          element = element.parentElement;
        }
        return 'none';
      },
      /**
       * Sets the Prism `language-xxxx` class of the given element.
       *
       * @param {Element} element
       * @param {string} language
       * @returns {void}
       */
      setLanguage: function (element, language) {
        // remove all `language-xxxx` classes
        // (this might leave behind a leading space)
        element.className = element.className.replace(RegExp(lang, 'gi'), '');

        // add the new `language-xxxx` class
        // (using `classList` will automatically clean up spaces for us)
        element.classList.add('language-' + language);
      },
      /**
       * Returns whether a given class is active for `element`.
       *
       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
       * given class is just the given class with a `no-` prefix.
       *
       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
       * ancestors have the given class or the negated version of it, then the default activation will be returned.
       *
       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
       * version of it, the class is considered active.
       *
       * @param {Element} element
       * @param {string} className
       * @param {boolean} [defaultActivation=false]
       * @returns {boolean}
       */
      isActive: function (element, className, defaultActivation) {
        var no = 'no-' + className;
        while (element) {
          var classList = element.classList;
          if (classList.contains(className)) {
            return true;
          }
          if (classList.contains(no)) {
            return false;
          }
          element = element.parentElement;
        }
        return !!defaultActivation;
      }
    },
    /**
     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
     *
     * @namespace
     * @memberof Prism
     * @public
     */
    languages: {
      /**
       * The grammar for plain, unformatted text.
       */
      plain: plainTextGrammar,
      plaintext: plainTextGrammar,
      text: plainTextGrammar,
      txt: plainTextGrammar,
      /**
       * Creates a deep copy of the language with the given id and appends the given tokens.
       *
       * If a token in `redef` also appears in the copied language, then the existing token in the copied language
       * will be overwritten at its original position.
       *
       * ## Best practices
       *
       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
       * understand the language definition because, normally, the order of tokens matters in Prism grammars.
       *
       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
       *
       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
       * @param {Grammar} redef The new tokens to append.
       * @returns {Grammar} The new language created.
       * @public
       * @example
       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
       *     // at its original position
       *     'comment': { ... },
       *     // CSS doesn't have a 'color' token, so this token will be appended
       *     'color': /\b(?:red|green|blue)\b/
       * });
       */
      extend: function (id, redef) {
        var lang = _.util.clone(_.languages[id]);
        for (var key in redef) {
          lang[key] = redef[key];
        }
        return lang;
      },
      /**
       * Inserts tokens _before_ another token in a language definition or any other grammar.
       *
       * ## Usage
       *
       * This helper method makes it easy to modify existing languages. For example, the CSS language definition
       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
       * this:
       *
       * ```js
       * Prism.languages.markup.style = {
       *     // token
       * };
       * ```
       *
       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
       * before existing tokens. For the CSS example above, you would use it like this:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'cdata', {
       *     'style': {
       *         // token
       *     }
       * });
       * ```
       *
       * ## Special cases
       *
       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
       * will be ignored.
       *
       * This behavior can be used to insert tokens after `before`:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'comment', {
       *     'comment': Prism.languages.markup.comment,
       *     // tokens after 'comment'
       * });
       * ```
       *
       * ## Limitations
       *
       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
       * deleting properties which is necessary to insert at arbitrary positions.
       *
       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
       * Instead, it will create a new object and replace all references to the target object with the new one. This
       * can be done without temporarily deleting properties, so the iteration order is well-defined.
       *
       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
       * you hold the target object in a variable, then the value of the variable will not change.
       *
       * ```js
       * var oldMarkup = Prism.languages.markup;
       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
       *
       * assert(oldMarkup !== Prism.languages.markup);
       * assert(newMarkup === Prism.languages.markup);
       * ```
       *
       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
       * object to be modified.
       * @param {string} before The key to insert before.
       * @param {Grammar} insert An object containing the key-value pairs to be inserted.
       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
       * object to be modified.
       *
       * Defaults to `Prism.languages`.
       * @returns {Grammar} The new grammar object.
       * @public
       */
      insertBefore: function (inside, before, insert, root) {
        root = root || /** @type {any} */_.languages;
        var grammar = root[inside];
        /** @type {Grammar} */
        var ret = {};
        for (var token in grammar) {
          if (grammar.hasOwnProperty(token)) {
            if (token == before) {
              for (var newToken in insert) {
                if (insert.hasOwnProperty(newToken)) {
                  ret[newToken] = insert[newToken];
                }
              }
            }

            // Do not insert token which also occur in insert. See #1525
            if (!insert.hasOwnProperty(token)) {
              ret[token] = grammar[token];
            }
          }
        }
        var old = root[inside];
        root[inside] = ret;

        // Update references in other language definitions
        _.languages.DFS(_.languages, function (key, value) {
          if (value === old && key != inside) {
            this[key] = ret;
          }
        });
        return ret;
      },
      // Traverse a language definition with Depth First Search
      DFS: function DFS(o, callback, type, visited) {
        visited = visited || {};
        var objId = _.util.objId;
        for (var i in o) {
          if (o.hasOwnProperty(i)) {
            callback.call(o, i, o[i], type || i);
            var property = o[i];
            var propertyType = _.util.type(property);
            if (propertyType === 'Object' && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, null, visited);
            } else if (propertyType === 'Array' && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, i, visited);
            }
          }
        }
      }
    },
    plugins: {},
    /**
     * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
     * and the language definitions to use, and returns a string with the HTML produced.
     *
     * The following hooks will be run:
     * 1. `before-tokenize`
     * 2. `after-tokenize`
     * 3. `wrap`: On each {@link Token}.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @param {string} language The name of the language definition passed to `grammar`.
     * @returns {string} The highlighted HTML.
     * @memberof Prism
     * @public
     * @example
     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
     */
    highlight: function (text, grammar, language) {
      var env = {
        code: text,
        grammar: grammar,
        language: language
      };
      _.hooks.run('before-tokenize', env);
      env.tokens = _.tokenize(env.code, env.grammar);
      _.hooks.run('after-tokenize', env);
      return Token.stringify(_.util.encode(env.tokens), env.language);
    },
    /**
     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
     * and the language definitions to use, and returns an array with the tokenized code.
     *
     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
     *
     * This method could be useful in other contexts as well, as a very crude parser.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @returns {TokenStream} An array of strings and tokens, a token stream.
     * @memberof Prism
     * @public
     * @example
     * let code = `var foo = 0;`;
     * let tokens = Prism.tokenize(code, Prism.languages.javascript);
     * tokens.forEach(token => {
     *     if (token instanceof Prism.Token && token.type === 'number') {
     *         console.log(`Found numeric literal: ${token.content}`);
     *     }
     * });
     */
    tokenize: function (text, grammar) {
      var rest = grammar.rest;
      if (rest) {
        for (var token in rest) {
          grammar[token] = rest[token];
        }
        delete grammar.rest;
      }
      var tokenList = new LinkedList();
      addAfter(tokenList, tokenList.head, text);
      matchGrammar(text, tokenList, grammar, tokenList.head, 0);
      return toArray(tokenList);
    },
    /**
     * @namespace
     * @memberof Prism
     * @public
     */
    hooks: {
      all: {},
      /**
       * Adds the given callback to the list of callbacks for the given hook.
       *
       * The callback will be invoked when the hook it is registered for is run.
       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
       *
       * One callback function can be registered to multiple hooks and the same hook multiple times.
       *
       * @param {string} name The name of the hook.
       * @param {HookCallback} callback The callback function which is given environment variables.
       * @public
       */
      add: function (name, callback) {
        var hooks = _.hooks.all;
        hooks[name] = hooks[name] || [];
        hooks[name].push(callback);
      },
      /**
       * Runs a hook invoking all registered callbacks with the given environment variables.
       *
       * Callbacks will be invoked synchronously and in the order in which they were registered.
       *
       * @param {string} name The name of the hook.
       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
       * @public
       */
      run: function (name, env) {
        var callbacks = _.hooks.all[name];
        if (!callbacks || !callbacks.length) {
          return;
        }
        for (var i = 0, callback; callback = callbacks[i++];) {
          callback(env);
        }
      }
    },
    Token: Token
  };

  // Typescript note:
  // The following can be used to import the Token type in JSDoc:
  //
  //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

  /**
   * Creates a new token.
   *
   * @param {string} type See {@link Token#type type}
   * @param {string | TokenStream} content See {@link Token#content content}
   * @param {string|string[]} [alias] The alias(es) of the token.
   * @param {string} [matchedStr=""] A copy of the full string this token was created from.
   * @class
   * @global
   * @public
   */
  function Token(type, content, alias, matchedStr) {
    /**
     * The type of the token.
     *
     * This is usually the key of a pattern in a {@link Grammar}.
     *
     * @type {string}
     * @see GrammarToken
     * @public
     */
    this.type = type;
    /**
     * The strings or tokens contained by this token.
     *
     * This will be a token stream if the pattern matched also defined an `inside` grammar.
     *
     * @type {string | TokenStream}
     * @public
     */
    this.content = content;
    /**
     * The alias(es) of the token.
     *
     * @type {string|string[]}
     * @see GrammarToken
     * @public
     */
    this.alias = alias;
    // Copy of the full string this token was created from
    this.length = (matchedStr || '').length | 0;
  }

  /**
   * A token stream is an array of strings and {@link Token Token} objects.
   *
   * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
   * them.
   *
   * 1. No adjacent strings.
   * 2. No empty strings.
   *
   *    The only exception here is the token stream that only contains the empty string and nothing else.
   *
   * @typedef {Array<string | Token>} TokenStream
   * @global
   * @public
   */

  /**
   * Converts the given token or token stream to an HTML representation.
   *
   * The following hooks will be run:
   * 1. `wrap`: On each {@link Token}.
   *
   * @param {string | Token | TokenStream} o The token or token stream to be converted.
   * @param {string} language The name of current language.
   * @returns {string} The HTML representation of the token or token stream.
   * @memberof Token
   * @static
   */
  Token.stringify = function stringify(o, language) {
    if (typeof o == 'string') {
      return o;
    }
    if (Array.isArray(o)) {
      var s = '';
      o.forEach(function (e) {
        s += stringify(e, language);
      });
      return s;
    }
    var env = {
      type: o.type,
      content: stringify(o.content, language),
      tag: 'span',
      classes: ['token', o.type],
      attributes: {},
      language: language
    };
    var aliases = o.alias;
    if (aliases) {
      if (Array.isArray(aliases)) {
        Array.prototype.push.apply(env.classes, aliases);
      } else {
        env.classes.push(aliases);
      }
    }
    _.hooks.run('wrap', env);
    var attributes = '';
    for (var name in env.attributes) {
      attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
    }
    return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
  };

  /**
   * @param {RegExp} pattern
   * @param {number} pos
   * @param {string} text
   * @param {boolean} lookbehind
   * @returns {RegExpExecArray | null}
   */
  function matchPattern(pattern, pos, text, lookbehind) {
    pattern.lastIndex = pos;
    var match = pattern.exec(text);
    if (match && lookbehind && match[1]) {
      // change the match to remove the text matched by the Prism lookbehind group
      var lookbehindLength = match[1].length;
      match.index += lookbehindLength;
      match[0] = match[0].slice(lookbehindLength);
    }
    return match;
  }

  /**
   * @param {string} text
   * @param {LinkedList<string | Token>} tokenList
   * @param {any} grammar
   * @param {LinkedListNode<string | Token>} startNode
   * @param {number} startPos
   * @param {RematchOptions} [rematch]
   * @returns {void}
   * @private
   *
   * @typedef RematchOptions
   * @property {string} cause
   * @property {number} reach
   */
  function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
    for (var token in grammar) {
      if (!grammar.hasOwnProperty(token) || !grammar[token]) {
        continue;
      }
      var patterns = grammar[token];
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      for (var j = 0; j < patterns.length; ++j) {
        if (rematch && rematch.cause == token + ',' + j) {
          return;
        }
        var patternObj = patterns[j];
        var inside = patternObj.inside;
        var lookbehind = !!patternObj.lookbehind;
        var greedy = !!patternObj.greedy;
        var alias = patternObj.alias;
        if (greedy && !patternObj.pattern.global) {
          // Without the global flag, lastIndex won't work
          var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
          patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
        }

        /** @type {RegExp} */
        var pattern = patternObj.pattern || patternObj;
        for (
        // iterate the token list and keep track of the current token/string position
        var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
          if (rematch && pos >= rematch.reach) {
            break;
          }
          var str = currentNode.value;
          if (tokenList.length > text.length) {
            // Something went terribly wrong, ABORT, ABORT!
            return;
          }
          if (str instanceof Token) {
            continue;
          }
          var removeCount = 1; // this is the to parameter of removeBetween
          var match;
          if (greedy) {
            match = matchPattern(pattern, pos, text, lookbehind);
            if (!match || match.index >= text.length) {
              break;
            }
            var from = match.index;
            var to = match.index + match[0].length;
            var p = pos;

            // find the node that contains the match
            p += currentNode.value.length;
            while (from >= p) {
              currentNode = currentNode.next;
              p += currentNode.value.length;
            }
            // adjust pos (and p)
            p -= currentNode.value.length;
            pos = p;

            // the current node is a Token, then the match starts inside another Token, which is invalid
            if (currentNode.value instanceof Token) {
              continue;
            }

            // find the last node which is affected by this match
            for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {
              removeCount++;
              p += k.value.length;
            }
            removeCount--;

            // replace with the new match
            str = text.slice(pos, p);
            match.index -= pos;
          } else {
            match = matchPattern(pattern, 0, str, lookbehind);
            if (!match) {
              continue;
            }
          }

          // eslint-disable-next-line no-redeclare
          var from = match.index;
          var matchStr = match[0];
          var before = str.slice(0, from);
          var after = str.slice(from + matchStr.length);
          var reach = pos + str.length;
          if (rematch && reach > rematch.reach) {
            rematch.reach = reach;
          }
          var removeFrom = currentNode.prev;
          if (before) {
            removeFrom = addAfter(tokenList, removeFrom, before);
            pos += before.length;
          }
          removeRange(tokenList, removeFrom, removeCount);
          var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
          currentNode = addAfter(tokenList, removeFrom, wrapped);
          if (after) {
            addAfter(tokenList, currentNode, after);
          }
          if (removeCount > 1) {
            // at least one Token object was removed, so we have to do some rematching
            // this can only happen if the current pattern is greedy

            /** @type {RematchOptions} */
            var nestedRematch = {
              cause: token + ',' + j,
              reach: reach
            };
            matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

            // the reach might have been extended because of the rematching
            if (rematch && nestedRematch.reach > rematch.reach) {
              rematch.reach = nestedRematch.reach;
            }
          }
        }
      }
    }
  }

  /**
   * @typedef LinkedListNode
   * @property {T} value
   * @property {LinkedListNode<T> | null} prev The previous node.
   * @property {LinkedListNode<T> | null} next The next node.
   * @template T
   * @private
   */

  /**
   * @template T
   * @private
   */
  function LinkedList() {
    /** @type {LinkedListNode<T>} */
    var head = {
      value: null,
      prev: null,
      next: null
    };
    /** @type {LinkedListNode<T>} */
    var tail = {
      value: null,
      prev: head,
      next: null
    };
    head.next = tail;

    /** @type {LinkedListNode<T>} */
    this.head = head;
    /** @type {LinkedListNode<T>} */
    this.tail = tail;
    this.length = 0;
  }

  /**
   * Adds a new node with the given value to the list.
   *
   * @param {LinkedList<T>} list
   * @param {LinkedListNode<T>} node
   * @param {T} value
   * @returns {LinkedListNode<T>} The added node.
   * @template T
   */
  function addAfter(list, node, value) {
    // assumes that node != list.tail && values.length >= 0
    var next = node.next;
    var newNode = {
      value: value,
      prev: node,
      next: next
    };
    node.next = newNode;
    next.prev = newNode;
    list.length++;
    return newNode;
  }
  /**
   * Removes `count` nodes after the given node. The given node will not be removed.
   *
   * @param {LinkedList<T>} list
   * @param {LinkedListNode<T>} node
   * @param {number} count
   * @template T
   */
  function removeRange(list, node, count) {
    var next = node.next;
    for (var i = 0; i < count && next !== list.tail; i++) {
      next = next.next;
    }
    node.next = next;
    next.prev = node;
    list.length -= i;
  }
  /**
   * @param {LinkedList<T>} list
   * @returns {T[]}
   * @template T
   */
  function toArray(list) {
    var array = [];
    var node = list.head.next;
    while (node !== list.tail) {
      array.push(node.value);
      node = node.next;
    }
    return array;
  }
  return _;
}();
var prism$1 = Prism$2;
Prism$2.default = Prism$2;

/* This content is auto-generated to include some prismjs language components: */

/* "prismjs/components/prism-markup" */

prism$1.languages.markup = {
  'comment': {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  'prolog': {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  'doctype': {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      'internal-subset': {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null // see below
      },

      'string': {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      'punctuation': /^<!|>$|[[\]]/,
      'doctype-tag': /^DOCTYPE/i,
      'name': /[^\s<>'"]+/
    }
  },
  'cdata': {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  'tag': {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      'tag': {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          'punctuation': /^<\/?/,
          'namespace': /^[^\s>\/:]+:/
        }
      },
      'special-attr': [],
      'attr-value': {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          'punctuation': [{
            pattern: /^=/,
            alias: 'attr-equals'
          }, /"|'/]
        }
      },
      'punctuation': /\/?>/,
      'attr-name': {
        pattern: /[^\s>\/]+/,
        inside: {
          'namespace': /^[^\s>\/:]+:/
        }
      }
    }
  },
  'entity': [{
    pattern: /&[\da-z]{1,8};/i,
    alias: 'named-entity'
  }, /&#x?[\da-f]{1,8};/i]
};
prism$1.languages.markup['tag'].inside['attr-value'].inside['entity'] = prism$1.languages.markup['entity'];
prism$1.languages.markup['doctype'].inside['internal-subset'].inside = prism$1.languages.markup; // Plugin to make entity title show the real entity, idea by Roman Komarov

prism$1.hooks.add('wrap', function (env) {
  if (env.type === 'entity') {
    env.attributes['title'] = env.content.replace(/&amp;/, '&');
  }
});
Object.defineProperty(prism$1.languages.markup.tag, 'addInlined', {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName, lang) {
    var includedCdataInside = {};
    includedCdataInside['language-' + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: prism$1.languages[lang]
    };
    includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      'included-cdata': {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside['language-' + lang] = {
      pattern: /[\s\S]+/,
      inside: prism$1.languages[lang]
    };
    var def = {};
    def[tagName] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () {
        return tagName;
      }), 'i'),
      lookbehind: true,
      greedy: true,
      inside: inside
    };
    prism$1.languages.insertBefore('markup', 'cdata', def);
  }
});
Object.defineProperty(prism$1.languages.markup.tag, 'addAttribute', {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function (attrName, lang) {
    prism$1.languages.markup.tag.inside['special-attr'].push({
      pattern: RegExp(/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, 'i'),
      lookbehind: true,
      inside: {
        'attr-name': /^[^\s=]+/,
        'attr-value': {
          pattern: /=[\s\S]+/,
          inside: {
            'value': {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, 'language-' + lang],
              inside: prism$1.languages[lang]
            },
            'punctuation': [{
              pattern: /^=/,
              alias: 'attr-equals'
            }, /"|'/]
          }
        }
      }
    });
  }
});
prism$1.languages.html = prism$1.languages.markup;
prism$1.languages.mathml = prism$1.languages.markup;
prism$1.languages.svg = prism$1.languages.markup;
prism$1.languages.xml = prism$1.languages.extend('markup', {});
prism$1.languages.ssml = prism$1.languages.xml;
prism$1.languages.atom = prism$1.languages.xml;
prism$1.languages.rss = prism$1.languages.xml;
/* "prismjs/components/prism-bash" */

(function (Prism) {
  // $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\n' '|'
  // + LC_ALL, RANDOM, REPLY, SECONDS.
  // + make sure PS1..4 are here as they are not always set,
  // - some useless things.
  var envVars = '\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b';
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: 'punctuation',
    // this looks reasonably well in all themes
    inside: null // see below
  };

  var insideString = {
    'bash': commandAfterHeredoc,
    'environment': {
      pattern: RegExp('\\$' + envVars),
      alias: 'constant'
    },
    'variable': [
    // [0]: Arithmetic Environment
    {
      pattern: /\$?\(\([\s\S]+?\)\)/,
      greedy: true,
      inside: {
        // If there is a $ sign at the beginning highlight $(( and )) as variable
        'variable': [{
          pattern: /(^\$\(\([\s\S]+)\)\)/,
          lookbehind: true
        }, /^\$\(\(/],
        'number': /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
        // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
        'operator': /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
        // If there is no $ sign at the beginning highlight (( and )) as punctuation
        'punctuation': /\(\(?|\)\)?|,|;/
      }
    },
    // [1]: Command Substitution
    {
      pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
      greedy: true,
      inside: {
        'variable': /^\$\(|^`|\)$|`$/
      }
    },
    // [2]: Brace expansion
    {
      pattern: /\$\{[^}]+\}/,
      greedy: true,
      inside: {
        'operator': /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
        'punctuation': /[\[\]]/,
        'environment': {
          pattern: RegExp('(\\{)' + envVars),
          lookbehind: true,
          alias: 'constant'
        }
      }
    }, /\$(?:\w+|[#?*!@$])/],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    'entity': /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism.languages.bash = {
    'shebang': {
      pattern: /^#!\s*\/.*/,
      alias: 'important'
    },
    'comment': {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    'function-name': [
    // a) function foo {
    // b) foo() {
    // c) function foo() {
    // but not “foo {”
    {
      // a) and c)
      pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
      lookbehind: true,
      alias: 'function'
    }, {
      // b)
      pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
      alias: 'function'
    }],
    // Highlight variable names as variables in for and select beginnings.
    'for-or-select': {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: 'variable',
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (“=” and “+=”).
    'assign-left': {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
      inside: {
        'environment': {
          pattern: RegExp('(^|[\\s;|&]|[<>]\\()' + envVars),
          lookbehind: true,
          alias: 'constant'
        }
      },
      alias: 'variable',
      lookbehind: true
    },
    'string': [
    // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
    {
      pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
      lookbehind: true,
      greedy: true,
      inside: insideString
    },
    // Here-document with quotes around the tag
    // → No expansion (so no “inside”).
    {
      pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
      lookbehind: true,
      greedy: true,
      inside: {
        'bash': commandAfterHeredoc
      }
    },
    // “Normal” string
    {
      // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
      pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
      lookbehind: true,
      greedy: true,
      inside: insideString
    }, {
      // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
      pattern: /(^|[^$\\])'[^']*'/,
      lookbehind: true,
      greedy: true
    }, {
      // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
      pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
      greedy: true,
      inside: {
        'entity': insideString.entity
      }
    }],
    'environment': {
      pattern: RegExp('\\$?' + envVars),
      alias: 'constant'
    },
    'variable': insideString.variable,
    'function': {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    'keyword': {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    'builtin': {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: 'class-name'
    },
    'boolean': {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    'file-descriptor': {
      pattern: /\B&\d\b/,
      alias: 'important'
    },
    'operator': {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        'file-descriptor': {
          pattern: /^\d/,
          alias: 'important'
        }
      }
    },
    'punctuation': /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    'number': {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism.languages.bash;
  /* Patterns in command substitution. */

  var toBeCopied = ['comment', 'function-name', 'for-or-select', 'assign-left', 'string', 'environment', 'function', 'keyword', 'builtin', 'boolean', 'file-descriptor', 'operator', 'punctuation', 'number'];
  var inside = insideString.variable[1].inside;
  for (var i = 0; i < toBeCopied.length; i++) {
    inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];
  }
  Prism.languages.shell = Prism.languages.bash;
})(prism$1);
/* "prismjs/components/prism-clike" */

prism$1.languages.clike = {
  'comment': [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true,
    greedy: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  'string': {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  'class-name': {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      'punctuation': /[.\\]/
    }
  },
  'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  'boolean': /\b(?:false|true)\b/,
  'function': /\b\w+(?=\()/,
  'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  'punctuation': /[{}[\];(),.:]/
};
/* "prismjs/components/prism-c" */

prism$1.languages.c = prism$1.languages.extend('clike', {
  'comment': {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  'string': {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  'class-name': {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  'keyword': /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  'function': /\b[a-z_]\w*(?=\s*\()/i,
  'number': /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  'operator': />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
prism$1.languages.insertBefore('c', 'string', {
  'char': {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
prism$1.languages.insertBefore('c', 'string', {
  'macro': {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: 'property',
    inside: {
      'string': [{
        // highlight the path of the include statement as a string
        pattern: /^(#\s*include\s*)<[^>]+>/,
        lookbehind: true
      }, prism$1.languages.c['string']],
      'char': prism$1.languages.c['char'],
      'comment': prism$1.languages.c['comment'],
      'macro-name': [{
        pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
        lookbehind: true
      }, {
        pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
        lookbehind: true,
        alias: 'function'
      }],
      // highlight macro directives as keywords
      'directive': {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: 'keyword'
      },
      'directive-hash': /^#/,
      'punctuation': /##|\\(?=[\r\n])/,
      'expression': {
        pattern: /\S[\s\S]*/,
        inside: prism$1.languages.c
      }
    }
  }
});
prism$1.languages.insertBefore('c', 'function', {
  // highlight predefined macros as constants
  'constant': /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete prism$1.languages.c['boolean'];
/* "prismjs/components/prism-cpp" */

(function (Prism) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function () {
    return keyword.source;
  });
  Prism.languages.cpp = Prism.languages.extend('c', {
    'class-name': [{
      pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function () {
        return keyword.source;
      })),
      lookbehind: true
    },
    // This is intended to capture the class name of method implementations like:
    //   void foo::bar() const {}
    // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
    // it starts with an uppercase letter. This approximation should give decent results.
    /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
    // This will capture the class name before destructors like:
    //   Foo::~Foo() {}
    /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
    // This also intends to capture the class name of method implementations but here the class has template
    // parameters, so it can't be a namespace (until C++ adds generic namespaces).
    /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/],
    'keyword': keyword,
    'number': {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    'operator': />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    'boolean': /\b(?:false|true)\b/
  });
  Prism.languages.insertBefore('cpp', 'string', {
    'module': {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(/(\b(?:import|module)\s+)/.source + '(?:' +
      // header-name
      /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + '|' +
      // module name or partition or both
      /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function () {
        return modName;
      }) + ')'),
      lookbehind: true,
      greedy: true,
      inside: {
        'string': /^[<"][\s\S]+/,
        'operator': /:/,
        'punctuation': /\./
      }
    },
    'raw-string': {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: 'string',
      greedy: true
    }
  });
  Prism.languages.insertBefore('cpp', 'keyword', {
    'generic-function': {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        'function': /^\w+/,
        'generic': {
          pattern: /<[\s\S]+/,
          alias: 'class-name',
          inside: Prism.languages.cpp
        }
      }
    }
  });
  Prism.languages.insertBefore('cpp', 'operator', {
    'double-colon': {
      pattern: /::/,
      alias: 'punctuation'
    }
  });
  Prism.languages.insertBefore('cpp', 'class-name', {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    'base-clause': {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism.languages.extend('cpp', {})
    }
  });
  Prism.languages.insertBefore('inside', 'double-colon', {
    // All untokenized words that are not namespaces should be class names
    'class-name': /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism.languages.cpp['base-clause']);
})(prism$1);
/* "prismjs/components/prism-css" */

(function (Prism) {
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism.languages.css = {
    'comment': /\/\*[\s\S]*?\*\//,
    'atrule': {
      pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
      inside: {
        'rule': /^@[\w-]+/,
        'selector-function-argument': {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: 'selector'
        },
        'keyword': {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        } // See rest below
      }
    },

    'url': {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
      greedy: true,
      inside: {
        'function': /^url/i,
        'punctuation': /^\(|\)$/,
        'string': {
          pattern: RegExp('^' + string.source + '$'),
          alias: 'url'
        }
      }
    },
    'selector': {
      pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
      lookbehind: true
    },
    'string': {
      pattern: string,
      greedy: true
    },
    'property': {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    'important': /!important\b/i,
    'function': {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    'punctuation': /[(){};:,]/
  };
  Prism.languages.css['atrule'].inside.rest = Prism.languages.css;
  var markup = Prism.languages.markup;
  if (markup) {
    markup.tag.addInlined('style', 'css');
    markup.tag.addAttribute('style', 'css');
  }
})(prism$1);
/* "prismjs/components/prism-css-extras" */

(function (Prism) {
  var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
  var selectorInside;
  Prism.languages.css.selector = {
    pattern: Prism.languages.css.selector.pattern,
    lookbehind: true,
    inside: selectorInside = {
      'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
      'pseudo-class': /:[-\w]+/,
      'class': /\.[-\w]+/,
      'id': /#[-\w]+/,
      'attribute': {
        pattern: RegExp('\\[(?:[^[\\]"\']|' + string.source + ')*\\]'),
        greedy: true,
        inside: {
          'punctuation': /^\[|\]$/,
          'case-sensitivity': {
            pattern: /(\s)[si]$/i,
            lookbehind: true,
            alias: 'keyword'
          },
          'namespace': {
            pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
            lookbehind: true,
            inside: {
              'punctuation': /\|$/
            }
          },
          'attr-name': {
            pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
            lookbehind: true
          },
          'attr-value': [string, {
            pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
            lookbehind: true
          }],
          'operator': /[|~*^$]?=/
        }
      },
      'n-th': [{
        pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
        lookbehind: true,
        inside: {
          'number': /[\dn]+/,
          'operator': /[+-]/
        }
      }, {
        pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
        lookbehind: true
      }],
      'combinator': />|\+|~|\|\|/,
      // the `tag` token has been existed and removed.
      // because we can't find a perfect tokenize to match it.
      // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
      'punctuation': /[(),]/
    }
  };
  Prism.languages.css['atrule'].inside['selector-function-argument'].inside = selectorInside;
  Prism.languages.insertBefore('css', 'property', {
    'variable': {
      pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
      lookbehind: true
    }
  });
  var unit = {
    pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
    lookbehind: true
  }; // 123 -123 .123 -.123 12.3 -12.3

  var number = {
    pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
    lookbehind: true
  };
  Prism.languages.insertBefore('css', 'function', {
    'operator': {
      pattern: /(\s)[+\-*\/](?=\s)/,
      lookbehind: true
    },
    // CAREFUL!
    // Previewers and Inline color use hexcode and color.
    'hexcode': {
      pattern: /\B#[\da-f]{3,8}\b/i,
      alias: 'color'
    },
    'color': [{
      pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
      lookbehind: true
    }, {
      pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
      inside: {
        'unit': unit,
        'number': number,
        'function': /[\w-]+(?=\()/,
        'punctuation': /[(),]/
      }
    }],
    // it's important that there is no boundary assertion after the hex digits
    'entity': /\\[\da-f]{1,8}/i,
    'unit': unit,
    'number': number
  });
})(prism$1);
/* "prismjs/components/prism-javascript" */

prism$1.languages.javascript = prism$1.languages.extend('clike', {
  'class-name': [prism$1.languages.clike['class-name'], {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    lookbehind: true
  }],
  'keyword': [{
    pattern: /((?:^|\})\s*)catch\b/,
    lookbehind: true
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: true
  }],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  'number': {
    pattern: RegExp(/(^|[^\w$])/.source + '(?:' + (
    // constant
    /NaN|Infinity/.source + '|' +
    // binary integer
    /0[bB][01]+(?:_[01]+)*n?/.source + '|' +
    // octal integer
    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + '|' +
    // hexadecimal integer
    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + '|' +
    // decimal bigint
    /\d+(?:_\d+)*n/.source + '|' +
    // decimal number (integer or float) but no bigint
    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ')' + /(?![\w$])/.source),
    lookbehind: true
  },
  'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
prism$1.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
prism$1.languages.insertBefore('javascript', 'keyword', {
  'regex': {
    // eslint-disable-next-line regexp/no-dupe-characters-character-class
    pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
    lookbehind: true,
    greedy: true,
    inside: {
      'regex-source': {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: 'language-regex',
        inside: prism$1.languages.regex
      },
      'regex-delimiter': /^\/|\/$/,
      'regex-flags': /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  'function-variable': {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: 'function'
  },
  'parameter': [{
    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    lookbehind: true,
    inside: prism$1.languages.javascript
  }, {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    lookbehind: true,
    inside: prism$1.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    lookbehind: true,
    inside: prism$1.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    lookbehind: true,
    inside: prism$1.languages.javascript
  }],
  'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
prism$1.languages.insertBefore('javascript', 'string', {
  'hashbang': {
    pattern: /^#!.*/,
    greedy: true,
    alias: 'comment'
  },
  'template-string': {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      'template-punctuation': {
        pattern: /^`|`$/,
        alias: 'string'
      },
      'interpolation': {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          'interpolation-punctuation': {
            pattern: /^\$\{|\}$/,
            alias: 'punctuation'
          },
          rest: prism$1.languages.javascript
        }
      },
      'string': /[\s\S]+/
    }
  },
  'string-property': {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: 'property'
  }
});
prism$1.languages.insertBefore('javascript', 'operator', {
  'literal-property': {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: 'property'
  }
});
if (prism$1.languages.markup) {
  prism$1.languages.markup.tag.addInlined('script', 'javascript'); // add attribute support for all DOM events.
  // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events

  prism$1.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, 'javascript');
}
prism$1.languages.js = prism$1.languages.javascript;
/* "prismjs/components/prism-coffeescript" */

(function (Prism) {
  // Ignore comments starting with { to privilege string interpolation highlighting
  var comment = /#(?!\{).+/;
  var interpolation = {
    pattern: /#\{[^}]+\}/,
    alias: 'variable'
  };
  Prism.languages.coffeescript = Prism.languages.extend('javascript', {
    'comment': comment,
    'string': [
    // Strings are multiline
    {
      pattern: /'(?:\\[\s\S]|[^\\'])*'/,
      greedy: true
    }, {
      // Strings are multiline
      pattern: /"(?:\\[\s\S]|[^\\"])*"/,
      greedy: true,
      inside: {
        'interpolation': interpolation
      }
    }],
    'keyword': /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
    'class-member': {
      pattern: /@(?!\d)\w+/,
      alias: 'variable'
    }
  });
  Prism.languages.insertBefore('coffeescript', 'comment', {
    'multiline-comment': {
      pattern: /###[\s\S]+?###/,
      alias: 'comment'
    },
    // Block regexp can contain comments and interpolation
    'block-regex': {
      pattern: /\/{3}[\s\S]*?\/{3}/,
      alias: 'regex',
      inside: {
        'comment': comment,
        'interpolation': interpolation
      }
    }
  });
  Prism.languages.insertBefore('coffeescript', 'string', {
    'inline-javascript': {
      pattern: /`(?:\\[\s\S]|[^\\`])*`/,
      inside: {
        'delimiter': {
          pattern: /^`|`$/,
          alias: 'punctuation'
        },
        'script': {
          pattern: /[\s\S]+/,
          alias: 'language-javascript',
          inside: Prism.languages.javascript
        }
      }
    },
    // Block strings
    'multiline-string': [{
      pattern: /'''[\s\S]*?'''/,
      greedy: true,
      alias: 'string'
    }, {
      pattern: /"""[\s\S]*?"""/,
      greedy: true,
      alias: 'string',
      inside: {
        interpolation: interpolation
      }
    }]
  });
  Prism.languages.insertBefore('coffeescript', 'keyword', {
    // Object property
    'property': /(?!\d)\w+(?=\s*:(?!:))/
  });
  delete Prism.languages.coffeescript['template-string'];
  Prism.languages.coffee = Prism.languages.coffeescript;
})(prism$1);
/* "prismjs/components/prism-yaml" */

(function (Prism) {
  // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property
  // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node
  var anchorOrAlias = /[*&][^\s[\]{},]+/; // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property

  var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/; // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)

  var properties = '(?:' + tag.source + '(?:[ \t]+' + anchorOrAlias.source + ')?|' + anchorOrAlias.source + '(?:[ \t]+' + tag.source + ')?)'; // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)
  // This is a simplified version that doesn't support "#" and multiline keys
  // All these long scarry character classes are simplified versions of YAML's characters

  var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function () {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  });
  var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  /**
   *
   * @param {string} value
   * @param {string} [flags]
   * @returns {RegExp}
   */

  function createValuePattern(value, flags) {
    flags = (flags || '').replace(/m/g, '') + 'm'; // add m flag

    var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function () {
      return properties;
    }).replace(/<<value>>/g, function () {
      return value;
    });
    return RegExp(pattern, flags);
  }
  Prism.languages.yaml = {
    'scalar': {
      pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function () {
        return properties;
      })),
      lookbehind: true,
      alias: 'string'
    },
    'comment': /#.*/,
    'key': {
      pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function () {
        return properties;
      }).replace(/<<key>>/g, function () {
        return '(?:' + plainKey + '|' + string + ')';
      })),
      lookbehind: true,
      greedy: true,
      alias: 'atrule'
    },
    'directive': {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: 'important'
    },
    'datetime': {
      pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
      lookbehind: true,
      alias: 'number'
    },
    'boolean': {
      pattern: createValuePattern(/false|true/.source, 'i'),
      lookbehind: true,
      alias: 'important'
    },
    'null': {
      pattern: createValuePattern(/null|~/.source, 'i'),
      lookbehind: true,
      alias: 'important'
    },
    'string': {
      pattern: createValuePattern(string),
      lookbehind: true,
      greedy: true
    },
    'number': {
      pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, 'i'),
      lookbehind: true
    },
    'tag': tag,
    'important': anchorOrAlias,
    'punctuation': /---|[:[\]{}\-,|>?]|\.\.\./
  };
  Prism.languages.yml = Prism.languages.yaml;
})(prism$1);
/* "prismjs/components/prism-markdown" */

(function (Prism) {
  // Allow only one line break
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  /**
   * This function is intended for the creation of the bold or italic pattern.
   *
   * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.
   *
   * _Note:_ Keep in mind that this adds a capturing group.
   *
   * @param {string} pattern
   * @returns {RegExp}
   */

  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function () {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + '(?:' + pattern + ')');
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function () {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism.languages.markdown = Prism.languages.extend('markup', {});
  Prism.languages.insertBefore('markdown', 'prolog', {
    'front-matter-block': {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        'punctuation': /^---|---$/,
        'front-matter': {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ['yaml', 'language-yaml'],
          inside: Prism.languages.yaml
        }
      }
    },
    'blockquote': {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: 'punctuation'
    },
    'table': {
      pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),
      inside: {
        'table-data-rows': {
          pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),
          lookbehind: true,
          inside: {
            'table-data': {
              pattern: RegExp(tableCell),
              inside: Prism.languages.markdown
            },
            'punctuation': /\|/
          }
        },
        'table-line': {
          pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),
          lookbehind: true,
          inside: {
            'punctuation': /\||:?-{3,}:?/
          }
        },
        'table-header-row': {
          pattern: RegExp('^' + tableRow + '$'),
          inside: {
            'table-header': {
              pattern: RegExp(tableCell),
              alias: 'important',
              inside: Prism.languages.markdown
            },
            'punctuation': /\|/
          }
        }
      }
    },
    'code': [{
      // Prefixed by 4 spaces or 1 tab and preceded by an empty line
      pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
      lookbehind: true,
      alias: 'keyword'
    }, {
      // ```optional language
      // code block
      // ```
      pattern: /^```[\s\S]*?^```$/m,
      greedy: true,
      inside: {
        'code-block': {
          pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
          lookbehind: true
        },
        'code-language': {
          pattern: /^(```).+/,
          lookbehind: true
        },
        'punctuation': /```/
      }
    }],
    'title': [{
      // title 1
      // =======
      // title 2
      // -------
      pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
      alias: 'important',
      inside: {
        punctuation: /==+$|--+$/
      }
    }, {
      // # title 1
      // ###### title 6
      pattern: /(^\s*)#.+/m,
      lookbehind: true,
      alias: 'important',
      inside: {
        punctuation: /^#+|#+$/
      }
    }],
    'hr': {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: 'punctuation'
    },
    'list': {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: 'punctuation'
    },
    'url-reference': {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        'variable': {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        'string': /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        'punctuation': /^[\[\]!:]|[<>]/
      },
      alias: 'url'
    },
    'bold': {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        'content': {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {} // see below
        },

        'punctuation': /\*\*|__/
      }
    },
    'italic': {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        'content': {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {} // see below
        },

        'punctuation': /[*_]/
      }
    },
    'strike': {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        'content': {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {} // see below
        },

        'punctuation': /~~?/
      }
    },
    'code-snippet': {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ['code', 'keyword']
    },
    'url': {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        'operator': /^!/,
        'content': {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {} // see below
        },

        'variable': {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        'url': {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        'string': {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ['url', 'bold', 'italic', 'strike'].forEach(function (token) {
    ['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {
      if (token !== inside) {
        Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];
      }
    });
  });
  Prism.hooks.add('after-tokenize', function (env) {
    if (env.language !== 'markdown' && env.language !== 'md') {
      return;
    }
    function walkTokens(tokens) {
      if (!tokens || typeof tokens === 'string') {
        return;
      }
      for (var i = 0, l = tokens.length; i < l; i++) {
        var token = tokens[i];
        if (token.type !== 'code') {
          walkTokens(token.content);
          continue;
        }
        /*
         * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token
         * is optional. But the grammar is defined so that there is only one case we have to handle:
         *
         * token.content = [
         *     <span class="punctuation">```</span>,
         *     <span class="code-language">xxxx</span>,
         *     '\n', // exactly one new lines (\r or \n or \r\n)
         *     <span class="code-block">...</span>,
         *     '\n', // exactly one new lines again
         *     <span class="punctuation">```</span>
         * ];
         */

        var codeLang = token.content[1];
        var codeBlock = token.content[3];
        if (codeLang && codeBlock && codeLang.type === 'code-language' && codeBlock.type === 'code-block' && typeof codeLang.content === 'string') {
          // this might be a language that Prism does not support
          // do some replacements to support C++, C#, and F#
          var lang = codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp'); // only use the first word

          lang = (/[a-z][\w-]*/i.exec(lang) || [''])[0].toLowerCase();
          var alias = 'language-' + lang; // add alias

          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === 'string') {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env.tokens);
  });
  Prism.hooks.add('wrap', function (env) {
    if (env.type !== 'code-block') {
      return;
    }
    var codeLang = '';
    for (var i = 0, l = env.classes.length; i < l; i++) {
      var cls = env.classes[i];
      var match = /language-(.+)/.exec(cls);
      if (match) {
        codeLang = match[1];
        break;
      }
    }
    var grammar = Prism.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {
        var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);
        env.attributes['id'] = id;
        Prism.plugins.autoloader.loadLanguages(codeLang, function () {
          var ele = document.getElementById(id);
          if (ele) {
            ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env.content = Prism.highlight(textContent(env.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');
  /**
   * A list of known entity names.
   *
   * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.
   *
   * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}
   */

  var KNOWN_ENTITY_NAMES = {
    'amp': '&',
    'lt': '<',
    'gt': '>',
    'quot': '"'
  }; // IE 11 doesn't support `String.fromCodePoint`

  var fromCodePoint = String.fromCodePoint || String.fromCharCode;
  /**
   * Returns the text content of a given HTML source code string.
   *
   * @param {string} html
   * @returns {string}
   */

  function textContent(html) {
    // remove all tags
    var text = html.replace(tagPattern, ''); // decode known entities

    text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (m, code) {
      code = code.toLowerCase();
      if (code[0] === '#') {
        var value;
        if (code[1] === 'x') {
          value = parseInt(code.slice(2), 16);
        } else {
          value = Number(code.slice(1));
        }
        return fromCodePoint(value);
      } else {
        var known = KNOWN_ENTITY_NAMES[code];
        if (known) {
          return known;
        } // unable to decode

        return m;
      }
    });
    return text;
  }
  Prism.languages.md = Prism.languages.markdown;
})(prism$1);
/* "prismjs/components/prism-graphql" */

prism$1.languages.graphql = {
  'comment': /#.*/,
  'description': {
    pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
    greedy: true,
    alias: 'string',
    inside: {
      'language-markdown': {
        pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
        lookbehind: true,
        inside: prism$1.languages.markdown
      }
    }
  },
  'string': {
    pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
    greedy: true
  },
  'number': /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  'boolean': /\b(?:false|true)\b/,
  'variable': /\$[a-z_]\w*/i,
  'directive': {
    pattern: /@[a-z_]\w*/i,
    alias: 'function'
  },
  'attr-name': {
    pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
    greedy: true
  },
  'atom-input': {
    pattern: /\b[A-Z]\w*Input\b/,
    alias: 'class-name'
  },
  'scalar': /\b(?:Boolean|Float|ID|Int|String)\b/,
  'constant': /\b[A-Z][A-Z_\d]*\b/,
  'class-name': {
    pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
    lookbehind: true
  },
  'fragment': {
    pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: 'function'
  },
  'definition-mutation': {
    pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: 'function'
  },
  'definition-query': {
    pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: 'function'
  },
  'keyword': /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
  'operator': /[!=|&]|\.{3}/,
  'property-query': /\w+(?=\s*\()/,
  'object': /\w+(?=\s*\{)/,
  'punctuation': /[!(){}\[\]:=,]/,
  'property': /\w+/
};
prism$1.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {
  if (env.language !== 'graphql') {
    return;
  }
  /**
   * get the graphql token stream that we want to customize
   *
   * @typedef {InstanceType<import("./prism-core")["Token"]>} Token
   * @type {Token[]}
   */

  var validTokens = env.tokens.filter(function (token) {
    return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';
  });
  var currentIndex = 0;
  /**
   * Returns whether the token relative to the current index has the given type.
   *
   * @param {number} offset
   * @returns {Token | undefined}
   */

  function getToken(offset) {
    return validTokens[currentIndex + offset];
  }
  /**
   * Returns whether the token relative to the current index has the given type.
   *
   * @param {readonly string[]} types
   * @param {number} [offset=0]
   * @returns {boolean}
   */

  function isTokenType(types, offset) {
    offset = offset || 0;
    for (var i = 0; i < types.length; i++) {
      var token = getToken(i + offset);
      if (!token || token.type !== types[i]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns the index of the closing bracket to an opening bracket.
   *
   * It is assumed that `token[currentIndex - 1]` is an opening bracket.
   *
   * If no closing bracket could be found, `-1` will be returned.
   *
   * @param {RegExp} open
   * @param {RegExp} close
   * @returns {number}
   */

  function findClosingBracket(open, close) {
    var stackHeight = 1;
    for (var i = currentIndex; i < validTokens.length; i++) {
      var token = validTokens[i];
      var content = token.content;
      if (token.type === 'punctuation' && typeof content === 'string') {
        if (open.test(content)) {
          stackHeight++;
        } else if (close.test(content)) {
          stackHeight--;
          if (stackHeight === 0) {
            return i;
          }
        }
      }
    }
    return -1;
  }
  /**
   * Adds an alias to the given token.
   *
   * @param {Token} token
   * @param {string} alias
   * @returns {void}
   */

  function addAlias(token, alias) {
    var aliases = token.alias;
    if (!aliases) {
      token.alias = aliases = [];
    } else if (!Array.isArray(aliases)) {
      token.alias = aliases = [aliases];
    }
    aliases.push(alias);
  }
  for (; currentIndex < validTokens.length;) {
    var startToken = validTokens[currentIndex++]; // add special aliases for mutation tokens

    if (startToken.type === 'keyword' && startToken.content === 'mutation') {
      // any array of the names of all input variables (if any)
      var inputVariables = [];
      if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {
        // definition
        currentIndex += 2; // skip 'definition-mutation' and 'punctuation'

        var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
        if (definitionEnd === -1) {
          continue;
        } // find all input variables

        for (; currentIndex < definitionEnd; currentIndex++) {
          var t = getToken(0);
          if (t.type === 'variable') {
            addAlias(t, 'variable-input');
            inputVariables.push(t.content);
          }
        }
        currentIndex = definitionEnd + 1;
      }
      if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {
        currentIndex++; // skip opening bracket

        addAlias(getToken(0), 'property-mutation');
        if (inputVariables.length > 0) {
          var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
          if (mutationEnd === -1) {
            continue;
          } // give references to input variables a special alias

          for (var i = currentIndex; i < mutationEnd; i++) {
            var varToken = validTokens[i];
            if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {
              addAlias(varToken, 'variable-input');
            }
          }
        }
      }
    }
  }
});
/* "prismjs/components/prism-sql" */

prism$1.languages.sql = {
  'comment': {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  'variable': [{
    pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
    greedy: true
  }, /@[\w.$]+/],
  'string': {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  'identifier': {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      'punctuation': /^`|`$/
    }
  },
  'function': /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  'keyword': /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  'boolean': /\b(?:FALSE|NULL|TRUE)\b/i,
  'number': /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  'operator': /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  'punctuation': /[;[\]()`,.]/
};
/* "prismjs/components/prism-js-templates" */

(function (Prism) {
  var templateString = Prism.languages.javascript['template-string']; // see the pattern in prism-javascript.js

  var templateLiteralPattern = templateString.pattern.source;
  var interpolationObject = templateString.inside['interpolation'];
  var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];
  var interpolationPattern = interpolationObject.pattern.source;
  /**
   * Creates a new pattern to match a template string with a special tag.
   *
   * This will return `undefined` if there is no grammar with the given language id.
   *
   * @param {string} language The language id of the embedded language. E.g. `markdown`.
   * @param {string} tag The regex pattern to match the tag.
   * @returns {object | undefined}
   * @example
   * createTemplate('css', /\bcss/.source);
   */

  function createTemplate(language, tag) {
    if (!Prism.languages[language]) {
      return undefined;
    }
    return {
      pattern: RegExp('((?:' + tag + ')\\s*)' + templateLiteralPattern),
      lookbehind: true,
      greedy: true,
      inside: {
        'template-punctuation': {
          pattern: /^`|`$/,
          alias: 'string'
        },
        'embedded-code': {
          pattern: /[\s\S]+/,
          alias: language
        }
      }
    };
  }
  Prism.languages.javascript['template-string'] = [
  // styled-jsx:
  //   css`a { color: #25F; }`
  // styled-components:
  //   styled.h1`color: red;`
  createTemplate('css', /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),
  // html`<p></p>`
  // div.innerHTML = `<p></p>`
  createTemplate('html', /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
  // svg`<path fill="#fff" d="M55.37 ..."/>`
  createTemplate('svg', /\bsvg/.source),
  // md`# h1`, markdown`## h2`
  createTemplate('markdown', /\b(?:markdown|md)/.source),
  // gql`...`, graphql`...`, graphql.experimental`...`
  createTemplate('graphql', /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source),
  // sql`...`
  createTemplate('sql', /\bsql/.source),
  // vanilla template string
  templateString].filter(Boolean);
  /**
   * Returns a specific placeholder literal for the given language.
   *
   * @param {number} counter
   * @param {string} language
   * @returns {string}
   */

  function getPlaceholder(counter, language) {
    return '___' + language.toUpperCase() + '_' + counter + '___';
  }
  /**
   * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.
   *
   * @param {string} code
   * @param {any} grammar
   * @param {string} language
   * @returns {(string|Token)[]}
   */

  function tokenizeWithHooks(code, grammar, language) {
    var env = {
      code: code,
      grammar: grammar,
      language: language
    };
    Prism.hooks.run('before-tokenize', env);
    env.tokens = Prism.tokenize(env.code, env.grammar);
    Prism.hooks.run('after-tokenize', env);
    return env.tokens;
  }
  /**
   * Returns the token of the given JavaScript interpolation expression.
   *
   * @param {string} expression The code of the expression. E.g. `"${42}"`
   * @returns {Token}
   */

  function tokenizeInterpolationExpression(expression) {
    var tempGrammar = {};
    tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;
    /** @type {Array} */

    var tokens = Prism.tokenize(expression, tempGrammar);
    if (tokens.length === 3) {
      /**
       * The token array will look like this
       * [
       *     ["interpolation-punctuation", "${"]
       *     "..." // JavaScript expression of the interpolation
       *     ["interpolation-punctuation", "}"]
       * ]
       */
      var args = [1, 1];
      args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));
      tokens.splice.apply(tokens, args);
    }
    return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);
  }
  /**
   * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.
   *
   * This function has 3 phases:
   *
   * 1. Replace all JavaScript interpolation expression with a placeholder.
   *    The placeholder will have the syntax of a identify of the target language.
   * 2. Tokenize the code with placeholders.
   * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.
   *    The insertion only works if a placeholder hasn't been "ripped apart" meaning that the placeholder has been
   *    tokenized as two tokens by the grammar of the embedded language.
   *
   * @param {string} code
   * @param {object} grammar
   * @param {string} language
   * @returns {Token}
   */

  function tokenizeEmbedded(code, grammar, language) {
    // 1. First filter out all interpolations
    // because they might be escaped, we need a lookbehind, so we use Prism

    /** @type {(Token|string)[]} */
    var _tokens = Prism.tokenize(code, {
      'interpolation': {
        pattern: RegExp(interpolationPattern),
        lookbehind: true
      }
    }); // replace all interpolations with a placeholder which is not in the code already

    var placeholderCounter = 0;
    /** @type {Object<string, string>} */

    var placeholderMap = {};
    var embeddedCode = _tokens.map(function (token) {
      if (typeof token === 'string') {
        return token;
      } else {
        var interpolationExpression = token.content;
        var placeholder;
        while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {
          /* noop */
        }
        placeholderMap[placeholder] = interpolationExpression;
        return placeholder;
      }
    }).join(''); // 2. Tokenize the embedded code

    var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language); // 3. Re-insert the interpolation

    var placeholders = Object.keys(placeholderMap);
    placeholderCounter = 0;
    /**
     *
     * @param {(Token|string)[]} tokens
     * @returns {void}
     */

    function walkTokens(tokens) {
      for (var i = 0; i < tokens.length; i++) {
        if (placeholderCounter >= placeholders.length) {
          return;
        }
        var token = tokens[i];
        if (typeof token === 'string' || typeof token.content === 'string') {
          var placeholder = placeholders[placeholderCounter];
          var s = typeof token === 'string' ? token : /** @type {string} */
          token.content;
          var index = s.indexOf(placeholder);
          if (index !== -1) {
            ++placeholderCounter;
            var before = s.substring(0, index);
            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);
            var after = s.substring(index + placeholder.length);
            var replacement = [];
            if (before) {
              replacement.push(before);
            }
            replacement.push(middle);
            if (after) {
              var afterTokens = [after];
              walkTokens(afterTokens);
              replacement.push.apply(replacement, afterTokens);
            }
            if (typeof token === 'string') {
              tokens.splice.apply(tokens, [i, 1].concat(replacement));
              i += replacement.length - 1;
            } else {
              token.content = replacement;
            }
          }
        } else {
          var content = token.content;
          if (Array.isArray(content)) {
            walkTokens(content);
          } else {
            walkTokens([content]);
          }
        }
      }
    }
    walkTokens(embeddedTokens);
    return new Prism.Token(language, embeddedTokens, 'language-' + language, code);
  }
  /**
   * The languages for which JS templating will handle tagged template literals.
   *
   * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.
   */

  var supportedLanguages = {
    'javascript': true,
    'js': true,
    'typescript': true,
    'ts': true,
    'jsx': true,
    'tsx': true
  };
  Prism.hooks.add('after-tokenize', function (env) {
    if (!(env.language in supportedLanguages)) {
      return;
    }
    /**
     * Finds and tokenizes all template strings with an embedded languages.
     *
     * @param {(Token | string)[]} tokens
     * @returns {void}
     */

    function findTemplateStrings(tokens) {
      for (var i = 0, l = tokens.length; i < l; i++) {
        var token = tokens[i];
        if (typeof token === 'string') {
          continue;
        }
        var content = token.content;
        if (!Array.isArray(content)) {
          if (typeof content !== 'string') {
            findTemplateStrings([content]);
          }
          continue;
        }
        if (token.type === 'template-string') {
          /**
           * A JavaScript template-string token will look like this:
           *
           * ["template-string", [
           *     ["template-punctuation", "`"],
           *     (
           *         An array of "string" and "interpolation" tokens. This is the simple string case.
           *         or
           *         ["embedded-code", "..."] This is the token containing the embedded code.
           *                                  It also has an alias which is the language of the embedded code.
           *     ),
           *     ["template-punctuation", "`"]
           * ]]
           */
          var embedded = content[1];
          if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {
            // get string content
            var code = stringContent(embedded);
            var alias = embedded.alias;
            var language = Array.isArray(alias) ? alias[0] : alias;
            var grammar = Prism.languages[language];
            if (!grammar) {
              // the embedded language isn't registered.
              continue;
            }
            content[1] = tokenizeEmbedded(code, grammar, language);
          }
        } else {
          findTemplateStrings(content);
        }
      }
    }
    findTemplateStrings(env.tokens);
  });
  /**
   * Returns the string content of a token or token stream.
   *
   * @param {string | Token | (string | Token)[]} value
   * @returns {string}
   */

  function stringContent(value) {
    if (typeof value === 'string') {
      return value;
    } else if (Array.isArray(value)) {
      return value.map(stringContent).join('');
    } else {
      return stringContent(value.content);
    }
  }
})(prism$1);
/* "prismjs/components/prism-typescript" */

(function (Prism) {
  Prism.languages.typescript = Prism.languages.extend('javascript', {
    'class-name': {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null // see below
    },

    'builtin': /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  }); // The keywords TypeScript adds to JavaScript

  Prism.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/,
  // keywords that have to be followed by an identifier
  /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
  // This is for `import type *, {}`
  /\btype\b(?=\s*(?:[\{*]|$))/); // doesn't work with TS because TS is too complex

  delete Prism.languages.typescript['parameter'];
  delete Prism.languages.typescript['literal-property']; // a version of typescript specifically for highlighting types

  var typeInside = Prism.languages.extend('typescript', {});
  delete typeInside['class-name'];
  Prism.languages.typescript['class-name'].inside = typeInside;
  Prism.languages.insertBefore('typescript', 'function', {
    'decorator': {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        'at': {
          pattern: /^@/,
          alias: 'operator'
        },
        'function': /^[\s\S]+/
      }
    },
    'generic-function': {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        'function': /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        'generic': {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: 'class-name',
          inside: typeInside
        }
      }
    }
  });
  Prism.languages.ts = Prism.languages.typescript;
})(prism$1);
/* "prismjs/components/prism-js-extras" */

(function (Prism) {
  Prism.languages.insertBefore('javascript', 'function-variable', {
    'method-variable': {
      pattern: RegExp('(\\.\\s*)' + Prism.languages.javascript['function-variable'].pattern.source),
      lookbehind: true,
      alias: ['function-variable', 'method', 'function', 'property-access']
    }
  });
  Prism.languages.insertBefore('javascript', 'function', {
    'method': {
      pattern: RegExp('(\\.\\s*)' + Prism.languages.javascript['function'].source),
      lookbehind: true,
      alias: ['function', 'property-access']
    }
  });
  Prism.languages.insertBefore('javascript', 'constant', {
    'known-class-name': [{
      // standard built-ins
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
      pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
      alias: 'class-name'
    }, {
      // errors
      pattern: /\b(?:[A-Z]\w*)Error\b/,
      alias: 'class-name'
    }]
  });
  /**
   * Replaces the `<ID>` placeholder in the given pattern with a pattern for general JS identifiers.
   *
   * @param {string} source
   * @param {string} [flags]
   * @returns {RegExp}
   */

  function withId(source, flags) {
    return RegExp(source.replace(/<ID>/g, function () {
      return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
    }), flags);
  }
  Prism.languages.insertBefore('javascript', 'keyword', {
    'imports': {
      // https://tc39.es/ecma262/#sec-imports
      pattern: withId(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source),
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    'exports': {
      // https://tc39.es/ecma262/#sec-exports
      pattern: withId(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source),
      lookbehind: true,
      inside: Prism.languages.javascript
    }
  });
  Prism.languages.javascript['keyword'].unshift({
    pattern: /\b(?:as|default|export|from|import)\b/,
    alias: 'module'
  }, {
    pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
    alias: 'control-flow'
  }, {
    pattern: /\bnull\b/,
    alias: ['null', 'nil']
  }, {
    pattern: /\bundefined\b/,
    alias: 'nil'
  });
  Prism.languages.insertBefore('javascript', 'operator', {
    'spread': {
      pattern: /\.{3}/,
      alias: 'operator'
    },
    'arrow': {
      pattern: /=>/,
      alias: 'operator'
    }
  });
  Prism.languages.insertBefore('javascript', 'punctuation', {
    'property-access': {
      pattern: withId(/(\.\s*)#?<ID>/.source),
      lookbehind: true
    },
    'maybe-class-name': {
      pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
      lookbehind: true
    },
    'dom': {
      // this contains only a few commonly used DOM variables
      pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
      alias: 'variable'
    },
    'console': {
      pattern: /\bconsole(?=\s*\.)/,
      alias: 'class-name'
    }
  }); // add 'maybe-class-name' to tokens which might be a class name

  var maybeClassNameTokens = ['function', 'function-variable', 'method', 'method-variable', 'property-access'];
  for (var i = 0; i < maybeClassNameTokens.length; i++) {
    var token = maybeClassNameTokens[i];
    var value = Prism.languages.javascript[token]; // convert regex to object

    if (Prism.util.type(value) === 'RegExp') {
      value = Prism.languages.javascript[token] = {
        pattern: value
      };
    } // keep in mind that we don't support arrays

    var inside = value.inside || {};
    value.inside = inside;
    inside['maybe-class-name'] = /^[A-Z][\s\S]*/;
  }
})(prism$1);
/* "prismjs/components/prism-jsx" */

(function (Prism) {
  var javascript = Prism.util.clone(Prism.languages.javascript);
  var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
  var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
  var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  /**
   * @param {string} source
   * @param {string} [flags]
   */

  function re(source, flags) {
    source = source.replace(/<S>/g, function () {
      return space;
    }).replace(/<BRACES>/g, function () {
      return braces;
    }).replace(/<SPREAD>/g, function () {
      return spread;
    });
    return RegExp(source, flags);
  }
  spread = re(spread).source;
  Prism.languages.jsx = Prism.languages.extend('markup', javascript);
  Prism.languages.jsx.tag.pattern = re(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
  Prism.languages.jsx.tag.inside['tag'].pattern = /^<\/?[^\s>\/]*/;
  Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
  Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
  Prism.languages.jsx.tag.inside['comment'] = javascript['comment'];
  Prism.languages.insertBefore('inside', 'attr-name', {
    'spread': {
      pattern: re(/<SPREAD>/.source),
      inside: Prism.languages.jsx
    }
  }, Prism.languages.jsx.tag);
  Prism.languages.insertBefore('inside', 'special-attr', {
    'script': {
      // Allow for two levels of nesting
      pattern: re(/=<BRACES>/.source),
      alias: 'language-javascript',
      inside: {
        'script-punctuation': {
          pattern: /^=(?=\{)/,
          alias: 'punctuation'
        },
        rest: Prism.languages.jsx
      }
    }
  }, Prism.languages.jsx.tag); // The following will handle plain text inside tags

  var stringifyToken = function (token) {
    if (!token) {
      return '';
    }
    if (typeof token === 'string') {
      return token;
    }
    if (typeof token.content === 'string') {
      return token.content;
    }
    return token.content.map(stringifyToken).join('');
  };
  var walkTokens = function (tokens) {
    var openedTags = [];
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      var notTagNorBrace = false;
      if (typeof token !== 'string') {
        if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {
          // We found a tag, now find its kind
          if (token.content[0].content[0].content === '</') {
            // Closing tag
            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
              // Pop matching opening tag
              openedTags.pop();
            }
          } else {
            if (token.content[token.content.length - 1].content === '/>') ;else {
              // Opening tag
              openedTags.push({
                tagName: stringifyToken(token.content[0].content[1]),
                openedBraces: 0
              });
            }
          }
        } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {
          // Here we might have entered a JSX context inside a tag
          openedTags[openedTags.length - 1].openedBraces++;
        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {
          // Here we might have left a JSX context inside a tag
          openedTags[openedTags.length - 1].openedBraces--;
        } else {
          notTagNorBrace = true;
        }
      }
      if (notTagNorBrace || typeof token === 'string') {
        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
          // Here we are inside a tag, and not inside a JSX context.
          // That's plain text: drop any tokens matched.
          var plainText = stringifyToken(token); // And merge text with adjacent text

          if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {
            plainText += stringifyToken(tokens[i + 1]);
            tokens.splice(i + 1, 1);
          }
          if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {
            plainText = stringifyToken(tokens[i - 1]) + plainText;
            tokens.splice(i - 1, 1);
            i--;
          }
          tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);
        }
      }
      if (token.content && typeof token.content !== 'string') {
        walkTokens(token.content);
      }
    }
  };
  Prism.hooks.add('after-tokenize', function (env) {
    if (env.language !== 'jsx' && env.language !== 'tsx') {
      return;
    }
    walkTokens(env.tokens);
  });
})(prism$1);
/* "prismjs/components/prism-diff" */

(function (Prism) {
  Prism.languages.diff = {
    'coord': [
    // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
    /^(?:\*{3}|-{3}|\+{3}).*$/m,
    // Match "@@ ... @@" coord lines in unified diff.
    /^@@.*@@$/m,
    // Match coord lines in normal diff (starts with a number).
    /^\d.*$/m] // deleted, inserted, unchanged, diff
  };
  /**
   * A map from the name of a block to its line prefix.
   *
   * @type {Object<string, string>}
   */

  var PREFIXES = {
    'deleted-sign': '-',
    'deleted-arrow': '<',
    'inserted-sign': '+',
    'inserted-arrow': '>',
    'unchanged': ' ',
    'diff': '!'
  }; // add a token for each prefix

  Object.keys(PREFIXES).forEach(function (name) {
    var prefix = PREFIXES[name];
    var alias = [];
    if (!/^\w+$/.test(name)) {
      // "deleted-sign" -> "deleted"
      alias.push(/\w+/.exec(name)[0]);
    }
    if (name === 'diff') {
      alias.push('bold');
    }
    Prism.languages.diff[name] = {
      pattern: RegExp('^(?:[' + prefix + '].*(?:\r\n?|\n|(?![\\s\\S])))+', 'm'),
      alias: alias,
      inside: {
        'line': {
          pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
          lookbehind: true
        },
        'prefix': {
          pattern: /[\s\S]/,
          alias: /\w+/.exec(name)[0]
        }
      }
    };
  }); // make prefixes available to Diff plugin

  Object.defineProperty(Prism.languages.diff, 'PREFIXES', {
    value: PREFIXES
  });
})(prism$1);
/* "prismjs/components/prism-git" */

prism$1.languages.git = {
  /*
   * A simple one line comment like in a git status command
   * For instance:
   * $ git status
   * # On branch infinite-scroll
   * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
   * # and have 1 and 2 different commits each, respectively.
   * nothing to commit (working directory clean)
   */
  'comment': /^#.*/m,
  /*
   * Regexp to match the changed lines in a git diff output. Check the example below.
   */
  'deleted': /^[-–].*/m,
  'inserted': /^\+.*/m,
  /*
   * a string (double and simple quote)
   */
  'string': /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
  /*
   * a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
   * For instance:
   * $ git add file.txt
   */
  'command': {
    pattern: /^.*\$ git .*$/m,
    inside: {
      /*
       * A git command can contain a parameter starting by a single or a double dash followed by a string
       * For instance:
       * $ git diff --cached
       * $ git log -p
       */
      'parameter': /\s--?\w+/
    }
  },
  /*
   * Coordinates displayed in a git diff command
   * For instance:
   * $ git diff
   * diff --git file.txt file.txt
   * index 6214953..1d54a52 100644
   * --- file.txt
   * +++ file.txt
   * @@ -1 +1,2 @@
   * -Here's my tetx file
   * +Here's my text file
   * +And this is the second line
   */
  'coord': /^@@.*@@$/m,
  /*
   * Match a "commit [SHA1]" line in a git log output.
   * For instance:
   * $ git log
   * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
   * Author: lgiraudel
   * Date:   Mon Feb 17 11:18:34 2014 +0100
   *
   *     Add of a new line
   */
  'commit-sha1': /^commit \w{40}$/m
};
/* "prismjs/components/prism-go" */

prism$1.languages.go = prism$1.languages.extend('clike', {
  'string': {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  'keyword': /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  'boolean': /\b(?:_|false|iota|nil|true)\b/,
  'number': [
  // binary and octal integers
  /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
  // hexadecimal integers and floats
  /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
  // decimal integers and floats
  /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i],
  'operator': /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  'builtin': /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
prism$1.languages.insertBefore('go', 'string', {
  'char': {
    pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
    greedy: true
  }
});
delete prism$1.languages.go['class-name'];
/* "prismjs/components/prism-markup-templating" */

(function (Prism) {
  /**
   * Returns the placeholder for the given language id and index.
   *
   * @param {string} language
   * @param {string|number} index
   * @returns {string}
   */
  function getPlaceholder(language, index) {
    return '___' + language.toUpperCase() + index + '___';
  }
  Object.defineProperties(Prism.languages['markup-templating'] = {}, {
    buildPlaceholders: {
      /**
       * Tokenize all inline templating expressions matching `placeholderPattern`.
       *
       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
       * `true` will be replaced.
       *
       * @param {object} env The environment of the `before-tokenize` hook.
       * @param {string} language The language id.
       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
       * @param {(match: string) => boolean} [replaceFilter]
       */
      value: function (env, language, placeholderPattern, replaceFilter) {
        if (env.language !== language) {
          return;
        }
        var tokenStack = env.tokenStack = [];
        env.code = env.code.replace(placeholderPattern, function (match) {
          if (typeof replaceFilter === 'function' && !replaceFilter(match)) {
            return match;
          }
          var i = tokenStack.length;
          var placeholder; // Check for existing strings

          while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {
            ++i;
          } // Create a sparse array

          tokenStack[i] = match;
          return placeholder;
        }); // Switch the grammar to markup

        env.grammar = Prism.languages.markup;
      }
    },
    tokenizePlaceholders: {
      /**
       * Replace placeholders with proper tokens after tokenizing.
       *
       * @param {object} env The environment of the `after-tokenize` hook.
       * @param {string} language The language id.
       */
      value: function (env, language) {
        if (env.language !== language || !env.tokenStack) {
          return;
        } // Switch the grammar back

        env.grammar = Prism.languages[language];
        var j = 0;
        var keys = Object.keys(env.tokenStack);
        function walkTokens(tokens) {
          for (var i = 0; i < tokens.length; i++) {
            // all placeholders are replaced already
            if (j >= keys.length) {
              break;
            }
            var token = tokens[i];
            if (typeof token === 'string' || token.content && typeof token.content === 'string') {
              var k = keys[j];
              var t = env.tokenStack[k];
              var s = typeof token === 'string' ? token : token.content;
              var placeholder = getPlaceholder(language, k);
              var index = s.indexOf(placeholder);
              if (index > -1) {
                ++j;
                var before = s.substring(0, index);
                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);
                var after = s.substring(index + placeholder.length);
                var replacement = [];
                if (before) {
                  replacement.push.apply(replacement, walkTokens([before]));
                }
                replacement.push(middle);
                if (after) {
                  replacement.push.apply(replacement, walkTokens([after]));
                }
                if (typeof token === 'string') {
                  tokens.splice.apply(tokens, [i, 1].concat(replacement));
                } else {
                  token.content = replacement;
                }
              }
            } else if (token.content
            /* && typeof token.content !== 'string' */) {
              walkTokens(token.content);
            }
          }
          return tokens;
        }
        walkTokens(env.tokens);
      }
    }
  });
})(prism$1);
/* "prismjs/components/prism-handlebars" */

(function (Prism) {
  Prism.languages.handlebars = {
    'comment': /\{\{![\s\S]*?\}\}/,
    'delimiter': {
      pattern: /^\{\{\{?|\}\}\}?$/,
      alias: 'punctuation'
    },
    'string': /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    'number': /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
    'boolean': /\b(?:false|true)\b/,
    'block': {
      pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
      lookbehind: true,
      alias: 'keyword'
    },
    'brackets': {
      pattern: /\[[^\]]+\]/,
      inside: {
        punctuation: /\[|\]/,
        variable: /[\s\S]+/
      }
    },
    'punctuation': /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
    'variable': /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
  };
  Prism.hooks.add('before-tokenize', function (env) {
    var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
    Prism.languages['markup-templating'].buildPlaceholders(env, 'handlebars', handlebarsPattern);
  });
  Prism.hooks.add('after-tokenize', function (env) {
    Prism.languages['markup-templating'].tokenizePlaceholders(env, 'handlebars');
  });
  Prism.languages.hbs = Prism.languages.handlebars;
})(prism$1);
/* "prismjs/components/prism-json" */
// https://www.json.org/json-en.html

prism$1.languages.json = {
  'property': {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  'string': {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  'comment': {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  'number': /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  'punctuation': /[{}[\],]/,
  'operator': /:/,
  'boolean': /\b(?:false|true)\b/,
  'null': {
    pattern: /\bnull\b/,
    alias: 'keyword'
  }
};
prism$1.languages.webmanifest = prism$1.languages.json;
/* "prismjs/components/prism-less" */

/* FIXME :
 :extend() is not handled specifically : its highlighting is buggy.
 Mixin usage must be inside a ruleset to be highlighted.
 At-rules (e.g. import) containing interpolations are buggy.
 Detached rulesets are highlighted as at-rules.
 A comment before a mixin usage prevents the latter to be properly highlighted.
 */

prism$1.languages.less = prism$1.languages.extend('css', {
  'comment': [/\/\*[\s\S]*?\*\//, {
    pattern: /(^|[^\\])\/\/.*/,
    lookbehind: true
  }],
  'atrule': {
    pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      'punctuation': /[:()]/
    }
  },
  // selectors and mixins are considered the same
  'selector': {
    pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      // mixin parameters
      'variable': /@+[\w-]+/
    }
  },
  'property': /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
  'operator': /[+\-*\/]/
});
prism$1.languages.insertBefore('less', 'property', {
  'variable': [
  // Variable declaration (the colon must be consumed!)
  {
    pattern: /@[\w-]+\s*:/,
    inside: {
      'punctuation': /:/
    }
  },
  // Variable usage
  /@@?[\w-]+/],
  'mixin-usage': {
    pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
    lookbehind: true,
    alias: 'function'
  }
});
/* "prismjs/components/prism-makefile" */

prism$1.languages.makefile = {
  'comment': {
    pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
    lookbehind: true
  },
  'string': {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  'builtin-target': {
    pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
    alias: 'builtin'
  },
  'target': {
    pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
    alias: 'symbol',
    inside: {
      'variable': /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
    }
  },
  'variable': /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
  // Directives
  'keyword': /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
  'function': {
    pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
    lookbehind: true
  },
  'operator': /(?:::|[?:+!])?=|[|@]/,
  'punctuation': /[:;(){}]/
};
/* "prismjs/components/prism-objectivec" */

prism$1.languages.objectivec = prism$1.languages.extend('c', {
  'string': {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  'keyword': /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  'operator': /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete prism$1.languages.objectivec['class-name'];
prism$1.languages.objc = prism$1.languages.objectivec;
/* "prismjs/components/prism-ocaml" */
// https://ocaml.org/manual/lex.html

prism$1.languages.ocaml = {
  'comment': {
    pattern: /\(\*[\s\S]*?\*\)/,
    greedy: true
  },
  'char': {
    pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
    greedy: true
  },
  'string': [{
    pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
    greedy: true
  }, {
    pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
    greedy: true
  }],
  'number': [
  // binary and octal
  /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
  // hexadecimal
  /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
  // decimal
  /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i],
  'directive': {
    pattern: /\B#\w+/,
    alias: 'property'
  },
  'label': {
    pattern: /\B~\w+/,
    alias: 'property'
  },
  'type-variable': {
    pattern: /\B'\w+/,
    alias: 'function'
  },
  'variant': {
    pattern: /`\w+/,
    alias: 'symbol'
  },
  // For the list of keywords and operators,
  // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84
  'keyword': /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
  'boolean': /\b(?:false|true)\b/,
  'operator-like-punctuation': {
    pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
    alias: 'punctuation'
  },
  // Custom operators are allowed
  'operator': /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
  'punctuation': /;;|::|[(){}\[\].,:;#]|\b_\b/
};
/* "prismjs/components/prism-python" */

prism$1.languages.python = {
  'comment': {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  'string-interpolation': {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      'interpolation': {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          'format-spec': {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          'conversion-option': {
            pattern: /![sra](?=[:}]$)/,
            alias: 'punctuation'
          },
          rest: null
        }
      },
      'string': /[\s\S]+/
    }
  },
  'triple-quoted-string': {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: 'string'
  },
  'string': {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  'function': {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  'class-name': {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  'decorator': {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ['annotation', 'punctuation'],
    inside: {
      'punctuation': /\./
    }
  },
  'keyword': /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  'builtin': /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  'boolean': /\b(?:False|None|True)\b/,
  'number': /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  'operator': /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  'punctuation': /[{}[\];(),.:]/
};
prism$1.languages.python['string-interpolation'].inside['interpolation'].inside.rest = prism$1.languages.python;
prism$1.languages.py = prism$1.languages.python;
/* "prismjs/components/prism-reason" */

prism$1.languages.reason = prism$1.languages.extend('clike', {
  'string': {
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
    greedy: true
  },
  // 'class-name' must be matched *after* 'constructor' defined below
  'class-name': /\b[A-Z]\w*/,
  'keyword': /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
  'operator': /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
});
prism$1.languages.insertBefore('reason', 'class-name', {
  'char': {
    pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
    greedy: true
  },
  // Negative look-ahead prevents from matching things like String.capitalize
  'constructor': /\b[A-Z]\w*\b(?!\s*\.)/,
  'label': {
    pattern: /\b[a-z]\w*(?=::)/,
    alias: 'symbol'
  }
}); // We can't match functions property, so let's not even try.

delete prism$1.languages.reason.function;
/* "prismjs/components/prism-sass" */

(function (Prism) {
  Prism.languages.sass = Prism.languages.extend('css', {
    // Sass comments don't need to be closed, only indented
    'comment': {
      pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
      lookbehind: true,
      greedy: true
    }
  });
  Prism.languages.insertBefore('sass', 'atrule', {
    // We want to consume the whole line
    'atrule-line': {
      // Includes support for = and + shortcuts
      pattern: /^(?:[ \t]*)[@+=].+/m,
      greedy: true,
      inside: {
        'atrule': /(?:@[\w-]+|[+=])/
      }
    }
  });
  delete Prism.languages.sass.atrule;
  var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
  var operator = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/, {
    pattern: /(\s)-(?=\s)/,
    lookbehind: true
  }];
  Prism.languages.insertBefore('sass', 'property', {
    // We want to consume the whole line
    'variable-line': {
      pattern: /^[ \t]*\$.+/m,
      greedy: true,
      inside: {
        'punctuation': /:/,
        'variable': variable,
        'operator': operator
      }
    },
    // We want to consume the whole line
    'property-line': {
      pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
      greedy: true,
      inside: {
        'property': [/[^:\s]+(?=\s*:)/, {
          pattern: /(:)[^:\s]+/,
          lookbehind: true
        }],
        'punctuation': /:/,
        'variable': variable,
        'operator': operator,
        'important': Prism.languages.sass.important
      }
    }
  });
  delete Prism.languages.sass.property;
  delete Prism.languages.sass.important; // Now that whole lines for other patterns are consumed,
  // what's left should be selectors

  Prism.languages.insertBefore('sass', 'punctuation', {
    'selector': {
      pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
      lookbehind: true,
      greedy: true
    }
  });
})(prism$1);
/* "prismjs/components/prism-scss" */

prism$1.languages.scss = prism$1.languages.extend('css', {
  'comment': {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
    lookbehind: true
  },
  'atrule': {
    pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
    inside: {
      'rule': /@[\w-]+/ // See rest below
    }
  },

  // url, compassified
  'url': /(?:[-a-z]+-)?url(?=\()/i,
  // CSS selector regex is not appropriate for Sass
  // since there can be lot more things (var, @ directive, nesting..)
  // a selector must start at the end of a property or after a brace (end of other rules or nesting)
  // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
  // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
  // can "pass" as a selector- e.g: proper#{$erty})
  // this one was hard to do, so please be careful if you edit this one :)
  'selector': {
    // Initial look-ahead is used to prevent matching of blank selectors
    pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
    inside: {
      'parent': {
        pattern: /&/,
        alias: 'important'
      },
      'placeholder': /%[-\w]+/,
      'variable': /\$[-\w]+|#\{\$[-\w]+\}/
    }
  },
  'property': {
    pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
    inside: {
      'variable': /\$[-\w]+|#\{\$[-\w]+\}/
    }
  }
});
prism$1.languages.insertBefore('scss', 'atrule', {
  'keyword': [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i, {
    pattern: /( )(?:from|through)(?= )/,
    lookbehind: true
  }]
});
prism$1.languages.insertBefore('scss', 'important', {
  // var and interpolated vars
  'variable': /\$[-\w]+|#\{\$[-\w]+\}/
});
prism$1.languages.insertBefore('scss', 'function', {
  'module-modifier': {
    pattern: /\b(?:as|hide|show|with)\b/i,
    alias: 'keyword'
  },
  'placeholder': {
    pattern: /%[-\w]+/,
    alias: 'selector'
  },
  'statement': {
    pattern: /\B!(?:default|optional)\b/i,
    alias: 'keyword'
  },
  'boolean': /\b(?:false|true)\b/,
  'null': {
    pattern: /\bnull\b/,
    alias: 'keyword'
  },
  'operator': {
    pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
    lookbehind: true
  }
});
prism$1.languages.scss['atrule'].inside.rest = prism$1.languages.scss;
/* "prismjs/components/prism-stylus" */

(function (Prism) {
  var unit = {
    pattern: /(\b\d+)(?:%|[a-z]+)/,
    lookbehind: true
  }; // 123 -123 .123 -.123 12.3 -12.3

  var number = {
    pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
    lookbehind: true
  };
  var inside = {
    'comment': {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true
    },
    'url': {
      pattern: /\burl\((["']?).*?\1\)/i,
      greedy: true
    },
    'string': {
      pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
      greedy: true
    },
    'interpolation': null,
    // See below
    'func': null,
    // See below
    'important': /\B!(?:important|optional)\b/i,
    'keyword': {
      pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
      lookbehind: true
    },
    'hexcode': /#[\da-f]{3,6}/i,
    'color': [/\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i, {
      pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
      inside: {
        'unit': unit,
        'number': number,
        'function': /[\w-]+(?=\()/,
        'punctuation': /[(),]/
      }
    }],
    'entity': /\\[\da-f]{1,8}/i,
    'unit': unit,
    'boolean': /\b(?:false|true)\b/,
    'operator': [
    // We want non-word chars around "-" because it is
    // accepted in property names.
    /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/],
    'number': number,
    'punctuation': /[{}()\[\];:,]/
  };
  inside['interpolation'] = {
    pattern: /\{[^\r\n}:]+\}/,
    alias: 'variable',
    inside: {
      'delimiter': {
        pattern: /^\{|\}$/,
        alias: 'punctuation'
      },
      rest: inside
    }
  };
  inside['func'] = {
    pattern: /[\w-]+\([^)]*\).*/,
    inside: {
      'function': /^[^(]+/,
      rest: inside
    }
  };
  Prism.languages.stylus = {
    'atrule-declaration': {
      pattern: /(^[ \t]*)@.+/m,
      lookbehind: true,
      inside: {
        'atrule': /^@[\w-]+/,
        rest: inside
      }
    },
    'variable-declaration': {
      pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
      lookbehind: true,
      inside: {
        'variable': /^\S+/,
        rest: inside
      }
    },
    'statement': {
      pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
      lookbehind: true,
      inside: {
        'keyword': /^\S+/,
        rest: inside
      }
    },
    // A property/value pair cannot end with a comma or a brace
    // It cannot have indented content unless it ended with a semicolon
    'property-declaration': {
      pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
      lookbehind: true,
      inside: {
        'property': {
          pattern: /^[^\s:]+/,
          inside: {
            'interpolation': inside.interpolation
          }
        },
        rest: inside
      }
    },
    // A selector can contain parentheses only as part of a pseudo-element
    // It can span multiple lines.
    // It must end with a comma or an accolade or have indented content.
    'selector': {
      pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
      lookbehind: true,
      inside: {
        'interpolation': inside.interpolation,
        'comment': inside.comment,
        'punctuation': /[{},]/
      }
    },
    'func': inside.func,
    'string': inside.string,
    'comment': {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true,
      greedy: true
    },
    'interpolation': inside.interpolation,
    'punctuation': /[{}()\[\];:.]/
  };
})(prism$1);
/* "prismjs/components/prism-tsx" */

(function (Prism) {
  var typescript = Prism.util.clone(Prism.languages.typescript);
  Prism.languages.tsx = Prism.languages.extend('jsx', typescript); // doesn't work with TS because TS is too complex

  delete Prism.languages.tsx['parameter'];
  delete Prism.languages.tsx['literal-property']; // This will prevent collisions between TSX tags and TS generic types.
  // Idea by https://github.com/karlhorky
  // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928

  var tag = Prism.languages.tsx.tag;
  tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + '(?:' + tag.pattern.source + ')', tag.pattern.flags);
  tag.lookbehind = true;
})(prism$1);
/* "prismjs/components/prism-wasm" */

prism$1.languages.wasm = {
  'comment': [/\(;[\s\S]*?;\)/, {
    pattern: /;;.*/,
    greedy: true
  }],
  'string': {
    pattern: /"(?:\\[\s\S]|[^"\\])*"/,
    greedy: true
  },
  'keyword': [{
    pattern: /\b(?:align|offset)=/,
    inside: {
      'operator': /=/
    }
  }, {
    pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
    inside: {
      'punctuation': /\./
    }
  }, /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/],
  'variable': /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
  'number': /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
  'punctuation': /[()]/
};

// Duotone Dark
// Author: Simurai, adapted from DuoTone themes for Atom (http://simurai.com/projects/2016/01/01/duotone-themes)
// Conversion: Bram de Haan (http://atelierbram.github.io/Base2Tone-prism/output/prism/prism-base2tone-evening-dark.css)
// Generated with Base16 Builder (https://github.com/base16-builder/base16-builder)
var theme = {
  plain: {
    backgroundColor: "#2a2734",
    color: "#9a86fd"
  },
  styles: [{
    types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
    style: {
      color: "#6c6783"
    }
  }, {
    types: ["namespace"],
    style: {
      opacity: 0.7
    }
  }, {
    types: ["tag", "operator", "number"],
    style: {
      color: "#e09142"
    }
  }, {
    types: ["property", "function"],
    style: {
      color: "#9a86fd"
    }
  }, {
    types: ["tag-id", "selector", "atrule-id"],
    style: {
      color: "#eeebff"
    }
  }, {
    types: ["attr-name"],
    style: {
      color: "#c4b9fe"
    }
  }, {
    types: ["boolean", "string", "entity", "url", "attr-value", "keyword", "control", "directive", "unit", "statement", "regex", "atrule", "placeholder", "variable"],
    style: {
      color: "#ffcc99"
    }
  }, {
    types: ["deleted"],
    style: {
      textDecorationLine: "line-through"
    }
  }, {
    types: ["inserted"],
    style: {
      textDecorationLine: "underline"
    }
  }, {
    types: ["italic"],
    style: {
      fontStyle: "italic"
    }
  }, {
    types: ["important", "bold"],
    style: {
      fontWeight: "bold"
    }
  }, {
    types: ["important"],
    style: {
      color: "#c4b9fe"
    }
  }]
};

var defaultProps = {
  // $FlowFixMe
  Prism: prism$1,
  theme: theme
};
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var newlineRe = /\r\n|\r|\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }

var normalizeEmptyLines = function (line) {
  if (line.length === 0) {
    line.push({
      types: ["plain"],
      content: "\n",
      empty: true
    });
  } else if (line.length === 1 && line[0].content === "") {
    line[0].content = "\n";
    line[0].empty = true;
  }
};
var appendTypes = function (types, add) {
  var typesSize = types.length;
  if (typesSize > 0 && types[typesSize - 1] === add) {
    return types;
  }
  return types.concat(add);
}; // Takes an array of Prism's tokens and groups them by line, turning plain
// strings into tokens as well. Tokens can become recursive in some cases,
// which means that their types are concatenated. Plain-string tokens however
// are always of type "plain".
// This is not recursive to avoid exceeding the call-stack limit, since it's unclear
// how nested Prism's tokens can become

var normalizeTokens = function (tokens) {
  var typeArrStack = [[]];
  var tokenArrStack = [tokens];
  var tokenArrIndexStack = [0];
  var tokenArrSizeStack = [tokens.length];
  var i = 0;
  var stackIndex = 0;
  var currentLine = [];
  var acc = [currentLine];
  while (stackIndex > -1) {
    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {
      var content = void 0;
      var types = typeArrStack[stackIndex];
      var tokenArr = tokenArrStack[stackIndex];
      var token = tokenArr[i]; // Determine content and append type to types if necessary

      if (typeof token === "string") {
        types = stackIndex > 0 ? types : ["plain"];
        content = token;
      } else {
        types = appendTypes(types, token.type);
        if (token.alias) {
          types = appendTypes(types, token.alias);
        }
        content = token.content;
      } // If token.content is an array, increase the stack depth and repeat this while-loop

      if (typeof content !== "string") {
        stackIndex++;
        typeArrStack.push(types);
        tokenArrStack.push(content);
        tokenArrIndexStack.push(0);
        tokenArrSizeStack.push(content.length);
        continue;
      } // Split by newlines

      var splitByNewlines = content.split(newlineRe);
      var newlineCount = splitByNewlines.length;
      currentLine.push({
        types: types,
        content: splitByNewlines[0]
      }); // Create a new line for each string on a new line

      for (var i$1 = 1; i$1 < newlineCount; i$1++) {
        normalizeEmptyLines(currentLine);
        acc.push(currentLine = []);
        currentLine.push({
          types: types,
          content: splitByNewlines[i$1]
        });
      }
    } // Decreate the stack depth

    stackIndex--;
    typeArrStack.pop();
    tokenArrStack.pop();
    tokenArrIndexStack.pop();
    tokenArrSizeStack.pop();
  }
  normalizeEmptyLines(currentLine);
  return acc;
};
var themeToDict = function (theme, language) {
  var plain = theme.plain; // $FlowFixMe

  var base = Object.create(null);
  var themeDict = theme.styles.reduce(function (acc, themeEntry) {
    var languages = themeEntry.languages;
    var style = themeEntry.style;
    if (languages && !languages.includes(language)) {
      return acc;
    }
    themeEntry.types.forEach(function (type) {
      // $FlowFixMe
      var accStyle = _extends({}, acc[type], style);
      acc[type] = accStyle;
    });
    return acc;
  }, base); // $FlowFixMe

  themeDict.root = plain; // $FlowFixMe

  themeDict.plain = _extends({}, plain, {
    backgroundColor: null
  });
  return themeDict;
};
function objectWithoutProperties(obj, exclude) {
  var target = {};
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  return target;
}
var Highlight = /*@__PURE__*/function (Component) {
  function Highlight() {
    var this$1$1 = this;
    var args = [],
      len = arguments.length;
    while (len--) args[len] = arguments[len];
    Component.apply(this, args);
    _defineProperty(this, "getThemeDict", function (props) {
      if (this$1$1.themeDict !== undefined && props.theme === this$1$1.prevTheme && props.language === this$1$1.prevLanguage) {
        return this$1$1.themeDict;
      }
      this$1$1.prevTheme = props.theme;
      this$1$1.prevLanguage = props.language;
      var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;
      return this$1$1.themeDict = themeDict;
    });
    _defineProperty(this, "getLineProps", function (ref) {
      var key = ref.key;
      var className = ref.className;
      var style = ref.style;
      var rest$1 = objectWithoutProperties(ref, ["key", "className", "style", "line"]);
      var rest = rest$1;
      var output = _extends({}, rest, {
        className: "token-line",
        style: undefined,
        key: undefined
      });
      var themeDict = this$1$1.getThemeDict(this$1$1.props);
      if (themeDict !== undefined) {
        output.style = themeDict.plain;
      }
      if (style !== undefined) {
        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;
      }
      if (key !== undefined) {
        output.key = key;
      }
      if (className) {
        output.className += " " + className;
      }
      return output;
    });
    _defineProperty(this, "getStyleForToken", function (ref) {
      var types = ref.types;
      var empty = ref.empty;
      var typesSize = types.length;
      var themeDict = this$1$1.getThemeDict(this$1$1.props);
      if (themeDict === undefined) {
        return undefined;
      } else if (typesSize === 1 && types[0] === "plain") {
        return empty ? {
          display: "inline-block"
        } : undefined;
      } else if (typesSize === 1 && !empty) {
        return themeDict[types[0]];
      }
      var baseStyle = empty ? {
        display: "inline-block"
      } : {}; // $FlowFixMe

      var typeStyles = types.map(function (type) {
        return themeDict[type];
      });
      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));
    });
    _defineProperty(this, "getTokenProps", function (ref) {
      var key = ref.key;
      var className = ref.className;
      var style = ref.style;
      var token = ref.token;
      var rest$1 = objectWithoutProperties(ref, ["key", "className", "style", "token"]);
      var rest = rest$1;
      var output = _extends({}, rest, {
        className: "token " + token.types.join(" "),
        children: token.content,
        style: this$1$1.getStyleForToken(token),
        key: undefined
      });
      if (style !== undefined) {
        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;
      }
      if (key !== undefined) {
        output.key = key;
      }
      if (className) {
        output.className += " " + className;
      }
      return output;
    });
    _defineProperty(this, "tokenize", function (Prism, code, grammar, language) {
      var env = {
        code: code,
        grammar: grammar,
        language: language,
        tokens: []
      };
      Prism.hooks.run("before-tokenize", env);
      var tokens = env.tokens = Prism.tokenize(env.code, env.grammar, env.language);
      Prism.hooks.run("after-tokenize", env);
      return tokens;
    });
  }
  if (Component) Highlight.__proto__ = Component;
  Highlight.prototype = Object.create(Component && Component.prototype);
  Highlight.prototype.constructor = Highlight;
  Highlight.prototype.render = function render() {
    var ref = this.props;
    var Prism = ref.Prism;
    var language = ref.language;
    var code = ref.code;
    var children = ref.children;
    var themeDict = this.getThemeDict(this.props);
    var grammar = Prism.languages[language];
    var mixedTokens = grammar !== undefined ? this.tokenize(Prism, code, grammar, language) : [code];
    var tokens = normalizeTokens(mixedTokens);
    return children({
      tokens: tokens,
      className: "prism-code language-" + language,
      style: themeDict !== undefined ? themeDict.root : {},
      getLineProps: this.getLineProps,
      getTokenProps: this.getTokenProps
    });
  };
  return Highlight;
}(React$2.Component);

var prism = {exports: {}};

/* **********************************************
     Begin prism-core.js
********************************************** */

(function (module) {
	/// <reference lib="WebWorker"/>

	var _self = typeof window !== 'undefined' ? window // if in browser
	: typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self // if in worker
	: {} // if in node js
	;

	/**
	 * Prism: Lightweight, robust, elegant syntax highlighting
	 *
	 * @license MIT <https://opensource.org/licenses/MIT>
	 * @author Lea Verou <https://lea.verou.me>
	 * @namespace
	 * @public
	 */
	var Prism = function (_self) {
	  // Private helper vars
	  var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
	  var uniqueId = 0;

	  // The grammar object for plaintext
	  var plainTextGrammar = {};
	  var _ = {
	    /**
	     * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
	     * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
	     * additional languages or plugins yourself.
	     *
	     * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
	     *
	     * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
	     * empty Prism object into the global scope before loading the Prism script like this:
	     *
	     * ```js
	     * window.Prism = window.Prism || {};
	     * Prism.manual = true;
	     * // add a new <script> to load Prism's script
	     * ```
	     *
	     * @default false
	     * @type {boolean}
	     * @memberof Prism
	     * @public
	     */
	    manual: _self.Prism && _self.Prism.manual,
	    /**
	     * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
	     * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
	     * own worker, you don't want it to do this.
	     *
	     * By setting this value to `true`, Prism will not add its own listeners to the worker.
	     *
	     * You obviously have to change this value before Prism executes. To do this, you can add an
	     * empty Prism object into the global scope before loading the Prism script like this:
	     *
	     * ```js
	     * window.Prism = window.Prism || {};
	     * Prism.disableWorkerMessageHandler = true;
	     * // Load Prism's script
	     * ```
	     *
	     * @default false
	     * @type {boolean}
	     * @memberof Prism
	     * @public
	     */
	    disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
	    /**
	     * A namespace for utility methods.
	     *
	     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
	     * change or disappear at any time.
	     *
	     * @namespace
	     * @memberof Prism
	     */
	    util: {
	      encode: function encode(tokens) {
	        if (tokens instanceof Token) {
	          return new Token(tokens.type, encode(tokens.content), tokens.alias);
	        } else if (Array.isArray(tokens)) {
	          return tokens.map(encode);
	        } else {
	          return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
	        }
	      },
	      /**
	       * Returns the name of the type of the given value.
	       *
	       * @param {any} o
	       * @returns {string}
	       * @example
	       * type(null)      === 'Null'
	       * type(undefined) === 'Undefined'
	       * type(123)       === 'Number'
	       * type('foo')     === 'String'
	       * type(true)      === 'Boolean'
	       * type([1, 2])    === 'Array'
	       * type({})        === 'Object'
	       * type(String)    === 'Function'
	       * type(/abc+/)    === 'RegExp'
	       */
	      type: function (o) {
	        return Object.prototype.toString.call(o).slice(8, -1);
	      },
	      /**
	       * Returns a unique number for the given object. Later calls will still return the same number.
	       *
	       * @param {Object} obj
	       * @returns {number}
	       */
	      objId: function (obj) {
	        if (!obj['__id']) {
	          Object.defineProperty(obj, '__id', {
	            value: ++uniqueId
	          });
	        }
	        return obj['__id'];
	      },
	      /**
	       * Creates a deep clone of the given object.
	       *
	       * The main intended use of this function is to clone language definitions.
	       *
	       * @param {T} o
	       * @param {Record<number, any>} [visited]
	       * @returns {T}
	       * @template T
	       */
	      clone: function deepClone(o, visited) {
	        visited = visited || {};
	        var clone;
	        var id;
	        switch (_.util.type(o)) {
	          case 'Object':
	            id = _.util.objId(o);
	            if (visited[id]) {
	              return visited[id];
	            }
	            clone = /** @type {Record<string, any>} */{};
	            visited[id] = clone;
	            for (var key in o) {
	              if (o.hasOwnProperty(key)) {
	                clone[key] = deepClone(o[key], visited);
	              }
	            }
	            return (/** @type {any} */clone
	            );
	          case 'Array':
	            id = _.util.objId(o);
	            if (visited[id]) {
	              return visited[id];
	            }
	            clone = [];
	            visited[id] = clone;
	            /** @type {Array} */ /** @type {any} */o.forEach(function (v, i) {
	              clone[i] = deepClone(v, visited);
	            });
	            return (/** @type {any} */clone
	            );
	          default:
	            return o;
	        }
	      },
	      /**
	       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
	       *
	       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
	       *
	       * @param {Element} element
	       * @returns {string}
	       */
	      getLanguage: function (element) {
	        while (element) {
	          var m = lang.exec(element.className);
	          if (m) {
	            return m[1].toLowerCase();
	          }
	          element = element.parentElement;
	        }
	        return 'none';
	      },
	      /**
	       * Sets the Prism `language-xxxx` class of the given element.
	       *
	       * @param {Element} element
	       * @param {string} language
	       * @returns {void}
	       */
	      setLanguage: function (element, language) {
	        // remove all `language-xxxx` classes
	        // (this might leave behind a leading space)
	        element.className = element.className.replace(RegExp(lang, 'gi'), '');

	        // add the new `language-xxxx` class
	        // (using `classList` will automatically clean up spaces for us)
	        element.classList.add('language-' + language);
	      },
	      /**
	       * Returns the script element that is currently executing.
	       *
	       * This does __not__ work for line script element.
	       *
	       * @returns {HTMLScriptElement | null}
	       */
	      currentScript: function () {
	        if (typeof document === 'undefined') {
	          return null;
	        }
	        if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
	          return (/** @type {any} */document.currentScript
	          );
	        }

	        // IE11 workaround
	        // we'll get the src of the current script by parsing IE11's error stack trace
	        // this will not work for inline scripts

	        try {
	          throw new Error();
	        } catch (err) {
	          // Get file src url from stack. Specifically works with the format of stack traces in IE.
	          // A stack will look like this:
	          //
	          // Error
	          //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
	          //    at Global code (http://localhost/components/prism-core.js:606:1)

	          var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
	          if (src) {
	            var scripts = document.getElementsByTagName('script');
	            for (var i in scripts) {
	              if (scripts[i].src == src) {
	                return scripts[i];
	              }
	            }
	          }
	          return null;
	        }
	      },
	      /**
	       * Returns whether a given class is active for `element`.
	       *
	       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
	       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
	       * given class is just the given class with a `no-` prefix.
	       *
	       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
	       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
	       * ancestors have the given class or the negated version of it, then the default activation will be returned.
	       *
	       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
	       * version of it, the class is considered active.
	       *
	       * @param {Element} element
	       * @param {string} className
	       * @param {boolean} [defaultActivation=false]
	       * @returns {boolean}
	       */
	      isActive: function (element, className, defaultActivation) {
	        var no = 'no-' + className;
	        while (element) {
	          var classList = element.classList;
	          if (classList.contains(className)) {
	            return true;
	          }
	          if (classList.contains(no)) {
	            return false;
	          }
	          element = element.parentElement;
	        }
	        return !!defaultActivation;
	      }
	    },
	    /**
	     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
	     *
	     * @namespace
	     * @memberof Prism
	     * @public
	     */
	    languages: {
	      /**
	       * The grammar for plain, unformatted text.
	       */
	      plain: plainTextGrammar,
	      plaintext: plainTextGrammar,
	      text: plainTextGrammar,
	      txt: plainTextGrammar,
	      /**
	       * Creates a deep copy of the language with the given id and appends the given tokens.
	       *
	       * If a token in `redef` also appears in the copied language, then the existing token in the copied language
	       * will be overwritten at its original position.
	       *
	       * ## Best practices
	       *
	       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
	       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
	       * understand the language definition because, normally, the order of tokens matters in Prism grammars.
	       *
	       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
	       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
	       *
	       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
	       * @param {Grammar} redef The new tokens to append.
	       * @returns {Grammar} The new language created.
	       * @public
	       * @example
	       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
	       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
	       *     // at its original position
	       *     'comment': { ... },
	       *     // CSS doesn't have a 'color' token, so this token will be appended
	       *     'color': /\b(?:red|green|blue)\b/
	       * });
	       */
	      extend: function (id, redef) {
	        var lang = _.util.clone(_.languages[id]);
	        for (var key in redef) {
	          lang[key] = redef[key];
	        }
	        return lang;
	      },
	      /**
	       * Inserts tokens _before_ another token in a language definition or any other grammar.
	       *
	       * ## Usage
	       *
	       * This helper method makes it easy to modify existing languages. For example, the CSS language definition
	       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
	       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
	       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
	       * this:
	       *
	       * ```js
	       * Prism.languages.markup.style = {
	       *     // token
	       * };
	       * ```
	       *
	       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
	       * before existing tokens. For the CSS example above, you would use it like this:
	       *
	       * ```js
	       * Prism.languages.insertBefore('markup', 'cdata', {
	       *     'style': {
	       *         // token
	       *     }
	       * });
	       * ```
	       *
	       * ## Special cases
	       *
	       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
	       * will be ignored.
	       *
	       * This behavior can be used to insert tokens after `before`:
	       *
	       * ```js
	       * Prism.languages.insertBefore('markup', 'comment', {
	       *     'comment': Prism.languages.markup.comment,
	       *     // tokens after 'comment'
	       * });
	       * ```
	       *
	       * ## Limitations
	       *
	       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
	       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
	       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
	       * deleting properties which is necessary to insert at arbitrary positions.
	       *
	       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
	       * Instead, it will create a new object and replace all references to the target object with the new one. This
	       * can be done without temporarily deleting properties, so the iteration order is well-defined.
	       *
	       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
	       * you hold the target object in a variable, then the value of the variable will not change.
	       *
	       * ```js
	       * var oldMarkup = Prism.languages.markup;
	       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
	       *
	       * assert(oldMarkup !== Prism.languages.markup);
	       * assert(newMarkup === Prism.languages.markup);
	       * ```
	       *
	       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
	       * object to be modified.
	       * @param {string} before The key to insert before.
	       * @param {Grammar} insert An object containing the key-value pairs to be inserted.
	       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
	       * object to be modified.
	       *
	       * Defaults to `Prism.languages`.
	       * @returns {Grammar} The new grammar object.
	       * @public
	       */
	      insertBefore: function (inside, before, insert, root) {
	        root = root || /** @type {any} */_.languages;
	        var grammar = root[inside];
	        /** @type {Grammar} */
	        var ret = {};
	        for (var token in grammar) {
	          if (grammar.hasOwnProperty(token)) {
	            if (token == before) {
	              for (var newToken in insert) {
	                if (insert.hasOwnProperty(newToken)) {
	                  ret[newToken] = insert[newToken];
	                }
	              }
	            }

	            // Do not insert token which also occur in insert. See #1525
	            if (!insert.hasOwnProperty(token)) {
	              ret[token] = grammar[token];
	            }
	          }
	        }
	        var old = root[inside];
	        root[inside] = ret;

	        // Update references in other language definitions
	        _.languages.DFS(_.languages, function (key, value) {
	          if (value === old && key != inside) {
	            this[key] = ret;
	          }
	        });
	        return ret;
	      },
	      // Traverse a language definition with Depth First Search
	      DFS: function DFS(o, callback, type, visited) {
	        visited = visited || {};
	        var objId = _.util.objId;
	        for (var i in o) {
	          if (o.hasOwnProperty(i)) {
	            callback.call(o, i, o[i], type || i);
	            var property = o[i];
	            var propertyType = _.util.type(property);
	            if (propertyType === 'Object' && !visited[objId(property)]) {
	              visited[objId(property)] = true;
	              DFS(property, callback, null, visited);
	            } else if (propertyType === 'Array' && !visited[objId(property)]) {
	              visited[objId(property)] = true;
	              DFS(property, callback, i, visited);
	            }
	          }
	        }
	      }
	    },
	    plugins: {},
	    /**
	     * This is the most high-level function in Prism’s API.
	     * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
	     * each one of them.
	     *
	     * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
	     *
	     * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
	     * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
	     * @memberof Prism
	     * @public
	     */
	    highlightAll: function (async, callback) {
	      _.highlightAllUnder(document, async, callback);
	    },
	    /**
	     * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
	     * {@link Prism.highlightElement} on each one of them.
	     *
	     * The following hooks will be run:
	     * 1. `before-highlightall`
	     * 2. `before-all-elements-highlight`
	     * 3. All hooks of {@link Prism.highlightElement} for each element.
	     *
	     * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
	     * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
	     * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
	     * @memberof Prism
	     * @public
	     */
	    highlightAllUnder: function (container, async, callback) {
	      var env = {
	        callback: callback,
	        container: container,
	        selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
	      };
	      _.hooks.run('before-highlightall', env);
	      env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
	      _.hooks.run('before-all-elements-highlight', env);
	      for (var i = 0, element; element = env.elements[i++];) {
	        _.highlightElement(element, async === true, env.callback);
	      }
	    },
	    /**
	     * Highlights the code inside a single element.
	     *
	     * The following hooks will be run:
	     * 1. `before-sanity-check`
	     * 2. `before-highlight`
	     * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
	     * 4. `before-insert`
	     * 5. `after-highlight`
	     * 6. `complete`
	     *
	     * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
	     * the element's language.
	     *
	     * @param {Element} element The element containing the code.
	     * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
	     * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
	     * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
	     * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
	     *
	     * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
	     * asynchronous highlighting to work. You can build your own bundle on the
	     * [Download page](https://prismjs.com/download.html).
	     * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
	     * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
	     * @memberof Prism
	     * @public
	     */
	    highlightElement: function (element, async, callback) {
	      // Find language
	      var language = _.util.getLanguage(element);
	      var grammar = _.languages[language];

	      // Set language on the element, if not present
	      _.util.setLanguage(element, language);

	      // Set language on the parent, for styling
	      var parent = element.parentElement;
	      if (parent && parent.nodeName.toLowerCase() === 'pre') {
	        _.util.setLanguage(parent, language);
	      }
	      var code = element.textContent;
	      var env = {
	        element: element,
	        language: language,
	        grammar: grammar,
	        code: code
	      };
	      function insertHighlightedCode(highlightedCode) {
	        env.highlightedCode = highlightedCode;
	        _.hooks.run('before-insert', env);
	        env.element.innerHTML = env.highlightedCode;
	        _.hooks.run('after-highlight', env);
	        _.hooks.run('complete', env);
	        callback && callback.call(env.element);
	      }
	      _.hooks.run('before-sanity-check', env);

	      // plugins may change/add the parent/element
	      parent = env.element.parentElement;
	      if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
	        parent.setAttribute('tabindex', '0');
	      }
	      if (!env.code) {
	        _.hooks.run('complete', env);
	        callback && callback.call(env.element);
	        return;
	      }
	      _.hooks.run('before-highlight', env);
	      if (!env.grammar) {
	        insertHighlightedCode(_.util.encode(env.code));
	        return;
	      }
	      if (async && _self.Worker) {
	        var worker = new Worker(_.filename);
	        worker.onmessage = function (evt) {
	          insertHighlightedCode(evt.data);
	        };
	        worker.postMessage(JSON.stringify({
	          language: env.language,
	          code: env.code,
	          immediateClose: true
	        }));
	      } else {
	        insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
	      }
	    },
	    /**
	     * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
	     * and the language definitions to use, and returns a string with the HTML produced.
	     *
	     * The following hooks will be run:
	     * 1. `before-tokenize`
	     * 2. `after-tokenize`
	     * 3. `wrap`: On each {@link Token}.
	     *
	     * @param {string} text A string with the code to be highlighted.
	     * @param {Grammar} grammar An object containing the tokens to use.
	     *
	     * Usually a language definition like `Prism.languages.markup`.
	     * @param {string} language The name of the language definition passed to `grammar`.
	     * @returns {string} The highlighted HTML.
	     * @memberof Prism
	     * @public
	     * @example
	     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
	     */
	    highlight: function (text, grammar, language) {
	      var env = {
	        code: text,
	        grammar: grammar,
	        language: language
	      };
	      _.hooks.run('before-tokenize', env);
	      if (!env.grammar) {
	        throw new Error('The language "' + env.language + '" has no grammar.');
	      }
	      env.tokens = _.tokenize(env.code, env.grammar);
	      _.hooks.run('after-tokenize', env);
	      return Token.stringify(_.util.encode(env.tokens), env.language);
	    },
	    /**
	     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
	     * and the language definitions to use, and returns an array with the tokenized code.
	     *
	     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
	     *
	     * This method could be useful in other contexts as well, as a very crude parser.
	     *
	     * @param {string} text A string with the code to be highlighted.
	     * @param {Grammar} grammar An object containing the tokens to use.
	     *
	     * Usually a language definition like `Prism.languages.markup`.
	     * @returns {TokenStream} An array of strings and tokens, a token stream.
	     * @memberof Prism
	     * @public
	     * @example
	     * let code = `var foo = 0;`;
	     * let tokens = Prism.tokenize(code, Prism.languages.javascript);
	     * tokens.forEach(token => {
	     *     if (token instanceof Prism.Token && token.type === 'number') {
	     *         console.log(`Found numeric literal: ${token.content}`);
	     *     }
	     * });
	     */
	    tokenize: function (text, grammar) {
	      var rest = grammar.rest;
	      if (rest) {
	        for (var token in rest) {
	          grammar[token] = rest[token];
	        }
	        delete grammar.rest;
	      }
	      var tokenList = new LinkedList();
	      addAfter(tokenList, tokenList.head, text);
	      matchGrammar(text, tokenList, grammar, tokenList.head, 0);
	      return toArray(tokenList);
	    },
	    /**
	     * @namespace
	     * @memberof Prism
	     * @public
	     */
	    hooks: {
	      all: {},
	      /**
	       * Adds the given callback to the list of callbacks for the given hook.
	       *
	       * The callback will be invoked when the hook it is registered for is run.
	       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
	       *
	       * One callback function can be registered to multiple hooks and the same hook multiple times.
	       *
	       * @param {string} name The name of the hook.
	       * @param {HookCallback} callback The callback function which is given environment variables.
	       * @public
	       */
	      add: function (name, callback) {
	        var hooks = _.hooks.all;
	        hooks[name] = hooks[name] || [];
	        hooks[name].push(callback);
	      },
	      /**
	       * Runs a hook invoking all registered callbacks with the given environment variables.
	       *
	       * Callbacks will be invoked synchronously and in the order in which they were registered.
	       *
	       * @param {string} name The name of the hook.
	       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
	       * @public
	       */
	      run: function (name, env) {
	        var callbacks = _.hooks.all[name];
	        if (!callbacks || !callbacks.length) {
	          return;
	        }
	        for (var i = 0, callback; callback = callbacks[i++];) {
	          callback(env);
	        }
	      }
	    },
	    Token: Token
	  };
	  _self.Prism = _;

	  // Typescript note:
	  // The following can be used to import the Token type in JSDoc:
	  //
	  //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

	  /**
	   * Creates a new token.
	   *
	   * @param {string} type See {@link Token#type type}
	   * @param {string | TokenStream} content See {@link Token#content content}
	   * @param {string|string[]} [alias] The alias(es) of the token.
	   * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	   * @class
	   * @global
	   * @public
	   */
	  function Token(type, content, alias, matchedStr) {
	    /**
	     * The type of the token.
	     *
	     * This is usually the key of a pattern in a {@link Grammar}.
	     *
	     * @type {string}
	     * @see GrammarToken
	     * @public
	     */
	    this.type = type;
	    /**
	     * The strings or tokens contained by this token.
	     *
	     * This will be a token stream if the pattern matched also defined an `inside` grammar.
	     *
	     * @type {string | TokenStream}
	     * @public
	     */
	    this.content = content;
	    /**
	     * The alias(es) of the token.
	     *
	     * @type {string|string[]}
	     * @see GrammarToken
	     * @public
	     */
	    this.alias = alias;
	    // Copy of the full string this token was created from
	    this.length = (matchedStr || '').length | 0;
	  }

	  /**
	   * A token stream is an array of strings and {@link Token Token} objects.
	   *
	   * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	   * them.
	   *
	   * 1. No adjacent strings.
	   * 2. No empty strings.
	   *
	   *    The only exception here is the token stream that only contains the empty string and nothing else.
	   *
	   * @typedef {Array<string | Token>} TokenStream
	   * @global
	   * @public
	   */

	  /**
	   * Converts the given token or token stream to an HTML representation.
	   *
	   * The following hooks will be run:
	   * 1. `wrap`: On each {@link Token}.
	   *
	   * @param {string | Token | TokenStream} o The token or token stream to be converted.
	   * @param {string} language The name of current language.
	   * @returns {string} The HTML representation of the token or token stream.
	   * @memberof Token
	   * @static
	   */
	  Token.stringify = function stringify(o, language) {
	    if (typeof o == 'string') {
	      return o;
	    }
	    if (Array.isArray(o)) {
	      var s = '';
	      o.forEach(function (e) {
	        s += stringify(e, language);
	      });
	      return s;
	    }
	    var env = {
	      type: o.type,
	      content: stringify(o.content, language),
	      tag: 'span',
	      classes: ['token', o.type],
	      attributes: {},
	      language: language
	    };
	    var aliases = o.alias;
	    if (aliases) {
	      if (Array.isArray(aliases)) {
	        Array.prototype.push.apply(env.classes, aliases);
	      } else {
	        env.classes.push(aliases);
	      }
	    }
	    _.hooks.run('wrap', env);
	    var attributes = '';
	    for (var name in env.attributes) {
	      attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	    }
	    return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
	  };

	  /**
	   * @param {RegExp} pattern
	   * @param {number} pos
	   * @param {string} text
	   * @param {boolean} lookbehind
	   * @returns {RegExpExecArray | null}
	   */
	  function matchPattern(pattern, pos, text, lookbehind) {
	    pattern.lastIndex = pos;
	    var match = pattern.exec(text);
	    if (match && lookbehind && match[1]) {
	      // change the match to remove the text matched by the Prism lookbehind group
	      var lookbehindLength = match[1].length;
	      match.index += lookbehindLength;
	      match[0] = match[0].slice(lookbehindLength);
	    }
	    return match;
	  }

	  /**
	   * @param {string} text
	   * @param {LinkedList<string | Token>} tokenList
	   * @param {any} grammar
	   * @param {LinkedListNode<string | Token>} startNode
	   * @param {number} startPos
	   * @param {RematchOptions} [rematch]
	   * @returns {void}
	   * @private
	   *
	   * @typedef RematchOptions
	   * @property {string} cause
	   * @property {number} reach
	   */
	  function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
	    for (var token in grammar) {
	      if (!grammar.hasOwnProperty(token) || !grammar[token]) {
	        continue;
	      }
	      var patterns = grammar[token];
	      patterns = Array.isArray(patterns) ? patterns : [patterns];
	      for (var j = 0; j < patterns.length; ++j) {
	        if (rematch && rematch.cause == token + ',' + j) {
	          return;
	        }
	        var patternObj = patterns[j];
	        var inside = patternObj.inside;
	        var lookbehind = !!patternObj.lookbehind;
	        var greedy = !!patternObj.greedy;
	        var alias = patternObj.alias;
	        if (greedy && !patternObj.pattern.global) {
	          // Without the global flag, lastIndex won't work
	          var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
	          patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
	        }

	        /** @type {RegExp} */
	        var pattern = patternObj.pattern || patternObj;
	        for (
	        // iterate the token list and keep track of the current token/string position
	        var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
	          if (rematch && pos >= rematch.reach) {
	            break;
	          }
	          var str = currentNode.value;
	          if (tokenList.length > text.length) {
	            // Something went terribly wrong, ABORT, ABORT!
	            return;
	          }
	          if (str instanceof Token) {
	            continue;
	          }
	          var removeCount = 1; // this is the to parameter of removeBetween
	          var match;
	          if (greedy) {
	            match = matchPattern(pattern, pos, text, lookbehind);
	            if (!match || match.index >= text.length) {
	              break;
	            }
	            var from = match.index;
	            var to = match.index + match[0].length;
	            var p = pos;

	            // find the node that contains the match
	            p += currentNode.value.length;
	            while (from >= p) {
	              currentNode = currentNode.next;
	              p += currentNode.value.length;
	            }
	            // adjust pos (and p)
	            p -= currentNode.value.length;
	            pos = p;

	            // the current node is a Token, then the match starts inside another Token, which is invalid
	            if (currentNode.value instanceof Token) {
	              continue;
	            }

	            // find the last node which is affected by this match
	            for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {
	              removeCount++;
	              p += k.value.length;
	            }
	            removeCount--;

	            // replace with the new match
	            str = text.slice(pos, p);
	            match.index -= pos;
	          } else {
	            match = matchPattern(pattern, 0, str, lookbehind);
	            if (!match) {
	              continue;
	            }
	          }

	          // eslint-disable-next-line no-redeclare
	          var from = match.index;
	          var matchStr = match[0];
	          var before = str.slice(0, from);
	          var after = str.slice(from + matchStr.length);
	          var reach = pos + str.length;
	          if (rematch && reach > rematch.reach) {
	            rematch.reach = reach;
	          }
	          var removeFrom = currentNode.prev;
	          if (before) {
	            removeFrom = addAfter(tokenList, removeFrom, before);
	            pos += before.length;
	          }
	          removeRange(tokenList, removeFrom, removeCount);
	          var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
	          currentNode = addAfter(tokenList, removeFrom, wrapped);
	          if (after) {
	            addAfter(tokenList, currentNode, after);
	          }
	          if (removeCount > 1) {
	            // at least one Token object was removed, so we have to do some rematching
	            // this can only happen if the current pattern is greedy

	            /** @type {RematchOptions} */
	            var nestedRematch = {
	              cause: token + ',' + j,
	              reach: reach
	            };
	            matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

	            // the reach might have been extended because of the rematching
	            if (rematch && nestedRematch.reach > rematch.reach) {
	              rematch.reach = nestedRematch.reach;
	            }
	          }
	        }
	      }
	    }
	  }

	  /**
	   * @typedef LinkedListNode
	   * @property {T} value
	   * @property {LinkedListNode<T> | null} prev The previous node.
	   * @property {LinkedListNode<T> | null} next The next node.
	   * @template T
	   * @private
	   */

	  /**
	   * @template T
	   * @private
	   */
	  function LinkedList() {
	    /** @type {LinkedListNode<T>} */
	    var head = {
	      value: null,
	      prev: null,
	      next: null
	    };
	    /** @type {LinkedListNode<T>} */
	    var tail = {
	      value: null,
	      prev: head,
	      next: null
	    };
	    head.next = tail;

	    /** @type {LinkedListNode<T>} */
	    this.head = head;
	    /** @type {LinkedListNode<T>} */
	    this.tail = tail;
	    this.length = 0;
	  }

	  /**
	   * Adds a new node with the given value to the list.
	   *
	   * @param {LinkedList<T>} list
	   * @param {LinkedListNode<T>} node
	   * @param {T} value
	   * @returns {LinkedListNode<T>} The added node.
	   * @template T
	   */
	  function addAfter(list, node, value) {
	    // assumes that node != list.tail && values.length >= 0
	    var next = node.next;
	    var newNode = {
	      value: value,
	      prev: node,
	      next: next
	    };
	    node.next = newNode;
	    next.prev = newNode;
	    list.length++;
	    return newNode;
	  }
	  /**
	   * Removes `count` nodes after the given node. The given node will not be removed.
	   *
	   * @param {LinkedList<T>} list
	   * @param {LinkedListNode<T>} node
	   * @param {number} count
	   * @template T
	   */
	  function removeRange(list, node, count) {
	    var next = node.next;
	    for (var i = 0; i < count && next !== list.tail; i++) {
	      next = next.next;
	    }
	    node.next = next;
	    next.prev = node;
	    list.length -= i;
	  }
	  /**
	   * @param {LinkedList<T>} list
	   * @returns {T[]}
	   * @template T
	   */
	  function toArray(list) {
	    var array = [];
	    var node = list.head.next;
	    while (node !== list.tail) {
	      array.push(node.value);
	      node = node.next;
	    }
	    return array;
	  }
	  if (!_self.document) {
	    if (!_self.addEventListener) {
	      // in Node.js
	      return _;
	    }
	    if (!_.disableWorkerMessageHandler) {
	      // In worker
	      _self.addEventListener('message', function (evt) {
	        var message = JSON.parse(evt.data);
	        var lang = message.language;
	        var code = message.code;
	        var immediateClose = message.immediateClose;
	        _self.postMessage(_.highlight(code, _.languages[lang], lang));
	        if (immediateClose) {
	          _self.close();
	        }
	      }, false);
	    }
	    return _;
	  }

	  // Get current script and highlight
	  var script = _.util.currentScript();
	  if (script) {
	    _.filename = script.src;
	    if (script.hasAttribute('data-manual')) {
	      _.manual = true;
	    }
	  }
	  function highlightAutomaticallyCallback() {
	    if (!_.manual) {
	      _.highlightAll();
	    }
	  }
	  if (!_.manual) {
	    // If the document state is "loading", then we'll use DOMContentLoaded.
	    // If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
	    // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
	    // might take longer one animation frame to execute which can create a race condition where only some plugins have
	    // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
	    // See https://github.com/PrismJS/prism/issues/2102
	    var readyState = document.readyState;
	    if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
	      document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
	    } else {
	      if (window.requestAnimationFrame) {
	        window.requestAnimationFrame(highlightAutomaticallyCallback);
	      } else {
	        window.setTimeout(highlightAutomaticallyCallback, 16);
	      }
	    }
	  }
	  return _;
	}(_self);
	if (module.exports) {
	  module.exports = Prism;
	}

	// hack for components to work correctly in node.js
	if (typeof commonjsGlobal !== 'undefined') {
	  commonjsGlobal.Prism = Prism;
	}

	// some additional documentation/types

	/**
	 * The expansion of a simple `RegExp` literal to support additional properties.
	 *
	 * @typedef GrammarToken
	 * @property {RegExp} pattern The regular expression of the token.
	 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
	 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
	 * @property {boolean} [greedy=false] Whether the token is greedy.
	 * @property {string|string[]} [alias] An optional alias or list of aliases.
	 * @property {Grammar} [inside] The nested grammar of this token.
	 *
	 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
	 *
	 * This can be used to make nested and even recursive language definitions.
	 *
	 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
	 * each another.
	 * @global
	 * @public
	 */

	/**
	 * @typedef Grammar
	 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
	 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
	 * @global
	 * @public
	 */

	/**
	 * A function which will invoked after an element was successfully highlighted.
	 *
	 * @callback HighlightCallback
	 * @param {Element} element The element successfully highlighted.
	 * @returns {void}
	 * @global
	 * @public
	 */

	/**
	 * @callback HookCallback
	 * @param {Object<string, any>} env The environment variables of the hook.
	 * @returns {void}
	 * @global
	 * @public
	 */

	/* **********************************************
	     Begin prism-markup.js
	********************************************** */

	Prism.languages.markup = {
	  'comment': {
	    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
	    greedy: true
	  },
	  'prolog': {
	    pattern: /<\?[\s\S]+?\?>/,
	    greedy: true
	  },
	  'doctype': {
	    // https://www.w3.org/TR/xml/#NT-doctypedecl
	    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
	    greedy: true,
	    inside: {
	      'internal-subset': {
	        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
	        lookbehind: true,
	        greedy: true,
	        inside: null // see below
	      },

	      'string': {
	        pattern: /"[^"]*"|'[^']*'/,
	        greedy: true
	      },
	      'punctuation': /^<!|>$|[[\]]/,
	      'doctype-tag': /^DOCTYPE/i,
	      'name': /[^\s<>'"]+/
	    }
	  },
	  'cdata': {
	    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
	    greedy: true
	  },
	  'tag': {
	    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
	    greedy: true,
	    inside: {
	      'tag': {
	        pattern: /^<\/?[^\s>\/]+/,
	        inside: {
	          'punctuation': /^<\/?/,
	          'namespace': /^[^\s>\/:]+:/
	        }
	      },
	      'special-attr': [],
	      'attr-value': {
	        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
	        inside: {
	          'punctuation': [{
	            pattern: /^=/,
	            alias: 'attr-equals'
	          }, {
	            pattern: /^(\s*)["']|["']$/,
	            lookbehind: true
	          }]
	        }
	      },
	      'punctuation': /\/?>/,
	      'attr-name': {
	        pattern: /[^\s>\/]+/,
	        inside: {
	          'namespace': /^[^\s>\/:]+:/
	        }
	      }
	    }
	  },
	  'entity': [{
	    pattern: /&[\da-z]{1,8};/i,
	    alias: 'named-entity'
	  }, /&#x?[\da-f]{1,8};/i]
	};
	Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] = Prism.languages.markup['entity'];
	Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

	// Plugin to make entity title show the real entity, idea by Roman Komarov
	Prism.hooks.add('wrap', function (env) {
	  if (env.type === 'entity') {
	    env.attributes['title'] = env.content.replace(/&amp;/, '&');
	  }
	});
	Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
	  /**
	   * Adds an inlined language to markup.
	   *
	   * An example of an inlined language is CSS with `<style>` tags.
	   *
	   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	   * case insensitive.
	   * @param {string} lang The language key.
	   * @example
	   * addInlined('style', 'css');
	   */
	  value: function addInlined(tagName, lang) {
	    var includedCdataInside = {};
	    includedCdataInside['language-' + lang] = {
	      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
	      lookbehind: true,
	      inside: Prism.languages[lang]
	    };
	    includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;
	    var inside = {
	      'included-cdata': {
	        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
	        inside: includedCdataInside
	      }
	    };
	    inside['language-' + lang] = {
	      pattern: /[\s\S]+/,
	      inside: Prism.languages[lang]
	    };
	    var def = {};
	    def[tagName] = {
	      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () {
	        return tagName;
	      }), 'i'),
	      lookbehind: true,
	      greedy: true,
	      inside: inside
	    };
	    Prism.languages.insertBefore('markup', 'cdata', def);
	  }
	});
	Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
	  /**
	   * Adds an pattern to highlight languages embedded in HTML attributes.
	   *
	   * An example of an inlined language is CSS with `style` attributes.
	   *
	   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
	   * case insensitive.
	   * @param {string} lang The language key.
	   * @example
	   * addAttribute('style', 'css');
	   */
	  value: function (attrName, lang) {
	    Prism.languages.markup.tag.inside['special-attr'].push({
	      pattern: RegExp(/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, 'i'),
	      lookbehind: true,
	      inside: {
	        'attr-name': /^[^\s=]+/,
	        'attr-value': {
	          pattern: /=[\s\S]+/,
	          inside: {
	            'value': {
	              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
	              lookbehind: true,
	              alias: [lang, 'language-' + lang],
	              inside: Prism.languages[lang]
	            },
	            'punctuation': [{
	              pattern: /^=/,
	              alias: 'attr-equals'
	            }, /"|'/]
	          }
	        }
	      }
	    });
	  }
	});
	Prism.languages.html = Prism.languages.markup;
	Prism.languages.mathml = Prism.languages.markup;
	Prism.languages.svg = Prism.languages.markup;
	Prism.languages.xml = Prism.languages.extend('markup', {});
	Prism.languages.ssml = Prism.languages.xml;
	Prism.languages.atom = Prism.languages.xml;
	Prism.languages.rss = Prism.languages.xml;

	/* **********************************************
	     Begin prism-css.js
	********************************************** */

	(function (Prism) {
	  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
	  Prism.languages.css = {
	    'comment': /\/\*[\s\S]*?\*\//,
	    'atrule': {
	      pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
	      inside: {
	        'rule': /^@[\w-]+/,
	        'selector-function-argument': {
	          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
	          lookbehind: true,
	          alias: 'selector'
	        },
	        'keyword': {
	          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
	          lookbehind: true
	        }
	        // See rest below
	      }
	    },

	    'url': {
	      // https://drafts.csswg.org/css-values-3/#urls
	      pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
	      greedy: true,
	      inside: {
	        'function': /^url/i,
	        'punctuation': /^\(|\)$/,
	        'string': {
	          pattern: RegExp('^' + string.source + '$'),
	          alias: 'url'
	        }
	      }
	    },
	    'selector': {
	      pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
	      lookbehind: true
	    },
	    'string': {
	      pattern: string,
	      greedy: true
	    },
	    'property': {
	      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
	      lookbehind: true
	    },
	    'important': /!important\b/i,
	    'function': {
	      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
	      lookbehind: true
	    },
	    'punctuation': /[(){};:,]/
	  };
	  Prism.languages.css['atrule'].inside.rest = Prism.languages.css;
	  var markup = Prism.languages.markup;
	  if (markup) {
	    markup.tag.addInlined('style', 'css');
	    markup.tag.addAttribute('style', 'css');
	  }
	})(Prism);

	/* **********************************************
	     Begin prism-clike.js
	********************************************** */

	Prism.languages.clike = {
	  'comment': [{
	    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
	    lookbehind: true,
	    greedy: true
	  }, {
	    pattern: /(^|[^\\:])\/\/.*/,
	    lookbehind: true,
	    greedy: true
	  }],
	  'string': {
	    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	    greedy: true
	  },
	  'class-name': {
	    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
	    lookbehind: true,
	    inside: {
	      'punctuation': /[.\\]/
	    }
	  },
	  'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
	  'boolean': /\b(?:false|true)\b/,
	  'function': /\b\w+(?=\()/,
	  'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
	  'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
	  'punctuation': /[{}[\];(),.:]/
	};

	/* **********************************************
	     Begin prism-javascript.js
	********************************************** */

	Prism.languages.javascript = Prism.languages.extend('clike', {
	  'class-name': [Prism.languages.clike['class-name'], {
	    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
	    lookbehind: true
	  }],
	  'keyword': [{
	    pattern: /((?:^|\})\s*)catch\b/,
	    lookbehind: true
	  }, {
	    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
	    lookbehind: true
	  }],
	  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	  'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	  'number': {
	    pattern: RegExp(/(^|[^\w$])/.source + '(?:' + (
	    // constant
	    /NaN|Infinity/.source + '|' +
	    // binary integer
	    /0[bB][01]+(?:_[01]+)*n?/.source + '|' +
	    // octal integer
	    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + '|' +
	    // hexadecimal integer
	    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + '|' +
	    // decimal bigint
	    /\d+(?:_\d+)*n/.source + '|' +
	    // decimal number (integer or float) but no bigint
	    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ')' + /(?![\w$])/.source),
	    lookbehind: true
	  },
	  'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
	});
	Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
	Prism.languages.insertBefore('javascript', 'keyword', {
	  'regex': {
	    pattern: RegExp(
	    // lookbehind
	    // eslint-disable-next-line regexp/no-dupe-characters-character-class
	    /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
	    // Regex pattern:
	    // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
	    // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
	    // with the only syntax, so we have to define 2 different regex patterns.
	    /\//.source + '(?:' + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + '|' +
	    // `v` flag syntax. This supports 3 levels of nested character classes.
	    /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ')' +
	    // lookahead
	    /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),
	    lookbehind: true,
	    greedy: true,
	    inside: {
	      'regex-source': {
	        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
	        lookbehind: true,
	        alias: 'language-regex',
	        inside: Prism.languages.regex
	      },
	      'regex-delimiter': /^\/|\/$/,
	      'regex-flags': /^[a-z]+$/
	    }
	  },
	  // This must be declared before keyword because we use "function" inside the look-forward
	  'function-variable': {
	    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
	    alias: 'function'
	  },
	  'parameter': [{
	    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
	    lookbehind: true,
	    inside: Prism.languages.javascript
	  }, {
	    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
	    lookbehind: true,
	    inside: Prism.languages.javascript
	  }, {
	    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
	    lookbehind: true,
	    inside: Prism.languages.javascript
	  }, {
	    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
	    lookbehind: true,
	    inside: Prism.languages.javascript
	  }],
	  'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
	});
	Prism.languages.insertBefore('javascript', 'string', {
	  'hashbang': {
	    pattern: /^#!.*/,
	    greedy: true,
	    alias: 'comment'
	  },
	  'template-string': {
	    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
	    greedy: true,
	    inside: {
	      'template-punctuation': {
	        pattern: /^`|`$/,
	        alias: 'string'
	      },
	      'interpolation': {
	        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
	        lookbehind: true,
	        inside: {
	          'interpolation-punctuation': {
	            pattern: /^\$\{|\}$/,
	            alias: 'punctuation'
	          },
	          rest: Prism.languages.javascript
	        }
	      },
	      'string': /[\s\S]+/
	    }
	  },
	  'string-property': {
	    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
	    lookbehind: true,
	    greedy: true,
	    alias: 'property'
	  }
	});
	Prism.languages.insertBefore('javascript', 'operator', {
	  'literal-property': {
	    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
	    lookbehind: true,
	    alias: 'property'
	  }
	});
	if (Prism.languages.markup) {
	  Prism.languages.markup.tag.addInlined('script', 'javascript');

	  // add attribute support for all DOM events.
	  // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
	  Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, 'javascript');
	}
	Prism.languages.js = Prism.languages.javascript;

	/* **********************************************
	     Begin prism-file-highlight.js
	********************************************** */

	(function () {
	  if (typeof Prism === 'undefined' || typeof document === 'undefined') {
	    return;
	  }

	  // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
	  if (!Element.prototype.matches) {
	    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
	  }
	  var LOADING_MESSAGE = 'Loading…';
	  var FAILURE_MESSAGE = function (status, message) {
	    return '✖ Error ' + status + ' while fetching file: ' + message;
	  };
	  var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';
	  var EXTENSIONS = {
	    'js': 'javascript',
	    'py': 'python',
	    'rb': 'ruby',
	    'ps1': 'powershell',
	    'psm1': 'powershell',
	    'sh': 'bash',
	    'bat': 'batch',
	    'h': 'c',
	    'tex': 'latex'
	  };
	  var STATUS_ATTR = 'data-src-status';
	  var STATUS_LOADING = 'loading';
	  var STATUS_LOADED = 'loaded';
	  var STATUS_FAILED = 'failed';
	  var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])' + ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

	  /**
	   * Loads the given file.
	   *
	   * @param {string} src The URL or path of the source file to load.
	   * @param {(result: string) => void} success
	   * @param {(reason: string) => void} error
	   */
	  function loadFile(src, success, error) {
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', src, true);
	    xhr.onreadystatechange = function () {
	      if (xhr.readyState == 4) {
	        if (xhr.status < 400 && xhr.responseText) {
	          success(xhr.responseText);
	        } else {
	          if (xhr.status >= 400) {
	            error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
	          } else {
	            error(FAILURE_EMPTY_MESSAGE);
	          }
	        }
	      }
	    };
	    xhr.send(null);
	  }

	  /**
	   * Parses the given range.
	   *
	   * This returns a range with inclusive ends.
	   *
	   * @param {string | null | undefined} range
	   * @returns {[number, number | undefined] | undefined}
	   */
	  function parseRange(range) {
	    var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || '');
	    if (m) {
	      var start = Number(m[1]);
	      var comma = m[2];
	      var end = m[3];
	      if (!comma) {
	        return [start, start];
	      }
	      if (!end) {
	        return [start, undefined];
	      }
	      return [start, Number(end)];
	    }
	    return undefined;
	  }
	  Prism.hooks.add('before-highlightall', function (env) {
	    env.selector += ', ' + SELECTOR;
	  });
	  Prism.hooks.add('before-sanity-check', function (env) {
	    var pre = /** @type {HTMLPreElement} */env.element;
	    if (pre.matches(SELECTOR)) {
	      env.code = ''; // fast-path the whole thing and go to complete

	      pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

	      // add code element with loading message
	      var code = pre.appendChild(document.createElement('CODE'));
	      code.textContent = LOADING_MESSAGE;
	      var src = pre.getAttribute('data-src');
	      var language = env.language;
	      if (language === 'none') {
	        // the language might be 'none' because there is no language set;
	        // in this case, we want to use the extension as the language
	        var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
	        language = EXTENSIONS[extension] || extension;
	      }

	      // set language classes
	      Prism.util.setLanguage(code, language);
	      Prism.util.setLanguage(pre, language);

	      // preload the language
	      var autoloader = Prism.plugins.autoloader;
	      if (autoloader) {
	        autoloader.loadLanguages(language);
	      }

	      // load file
	      loadFile(src, function (text) {
	        // mark as loaded
	        pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

	        // handle data-range
	        var range = parseRange(pre.getAttribute('data-range'));
	        if (range) {
	          var lines = text.split(/\r\n?|\n/g);

	          // the range is one-based and inclusive on both ends
	          var start = range[0];
	          var end = range[1] == null ? lines.length : range[1];
	          if (start < 0) {
	            start += lines.length;
	          }
	          start = Math.max(0, Math.min(start - 1, lines.length));
	          if (end < 0) {
	            end += lines.length;
	          }
	          end = Math.max(0, Math.min(end, lines.length));
	          text = lines.slice(start, end).join('\n');

	          // add data-start for line numbers
	          if (!pre.hasAttribute('data-start')) {
	            pre.setAttribute('data-start', String(start + 1));
	          }
	        }

	        // highlight code
	        code.textContent = text;
	        Prism.highlightElement(code);
	      }, function (error) {
	        // mark as failed
	        pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
	        code.textContent = error;
	      });
	    }
	  });
	  Prism.plugins.fileHighlight = {
	    /**
	     * Executes the File Highlight plugin for all matching `pre` elements under the given container.
	     *
	     * Note: Elements which are already loaded or currently loading will not be touched by this method.
	     *
	     * @param {ParentNode} [container=document]
	     */
	    highlight: function highlight(container) {
	      var elements = (container || document).querySelectorAll(SELECTOR);
	      for (var i = 0, element; element = elements[i++];) {
	        Prism.highlightElement(element);
	      }
	    }
	  };
	  var logged = false;
	  /** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
	  Prism.fileHighlight = function () {
	    if (!logged) {
	      console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
	      logged = true;
	    }
	    Prism.plugins.fileHighlight.highlight.apply(this, arguments);
	  };
	})();
} (prism));

var Prism$1 = prism.exports;

Prism.languages.hoon = {
  'comment': {
    pattern: /::.*/,
    greedy: true
  },
  'string': {
    pattern: /"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'/,
    greedy: true
  },
  'constant': /%(?:\.[ny]|[\w-]+)/,
  'class-name': /@(?:[a-z0-9-]*[a-z0-9])?|\*/i,
  'function': /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
  'keyword': /\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
};

function Fence({
  children,
  language,
  copy = false,
  mode = "full"
}) {
  const [copyStatus, useCopy] = useCopyToClipboard(children);
  const [collapsed, setCollapse] = React__default["default"].useState(Boolean(mode === "collapse"));
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: classNames("relative rounded-xl z-0", {
      "max-h-60 overflow-hidden": collapsed
    })
  }, collapsed && /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "absolute w-full h-full bottom-0 overflow-hidden bg-white z-10 rounded-xl",
    style: {
      opacity: "0.5"
    }
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "absolute w-full h-full flex justify-center items-end z-20 cursor-pointer",
    onClick: () => setCollapse(false)
  }, /*#__PURE__*/React__default["default"].createElement("p", {
    className: "!text-sm !font-semibold",
    style: {
      paddingBottom: "0.25rem"
    }
  }, "Click to expand"))), copy && /*#__PURE__*/React__default["default"].createElement("div", {
    className: "absolute flex items-center justify-center top-3 right-3 z-10 cursor-pointer !p-1 border rounded-lg border-[#afaeab]",
    onClick: useCopy
  }, /*#__PURE__*/React__default["default"].createElement("p", null, copyStatus === "inactive" ? /*#__PURE__*/React__default["default"].createElement(Copy, null) : /*#__PURE__*/React__default["default"].createElement("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default["default"].createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M0 8C0 3.58172 3.58172 0 8 0C12.4183 0 16 3.58172 16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8ZM7.54325 11.4247L12.1498 5.66647L11.3169 5.00013L7.39013 9.90859L4.60812 7.59025L3.92526 8.40969L7.54325 11.4247Z",
    fill: "#afaeab"
  })))), /*#__PURE__*/React__default["default"].createElement(Highlight, _extends$6({}, defaultProps, {
    key: language,
    language: language,
    code: children,
    theme: undefined,
    Prism: Prism$1
  }), ({
    className,
    style,
    tokens,
    getLineProps,
    getTokenProps
  }) => /*#__PURE__*/React__default["default"].createElement("pre", {
    className: classNames(className, "!py-4", {
      "max-h-96 overflow-y-auto": Boolean(mode === "scroll")
    }),
    style: style
  }, tokens.slice(0, -1).map((line, i) => /*#__PURE__*/React__default["default"].createElement("div", getLineProps({
    line,
    key: i
  }), line.map((token, key) => /*#__PURE__*/React__default["default"].createElement("span", getTokenProps({
    token,
    key
  }))))))));
}

var htmlReactParser = {exports: {}};

var lib$2 = {};

var possibleStandardNamesOptimized$1 = {};

// An attribute in which the DOM/SVG standard name is the same as the React prop name (e.g., 'accept').
var SAME$1 = 0;
possibleStandardNamesOptimized$1.SAME = SAME$1;

// An attribute in which the React prop name is the camelcased version of the DOM/SVG standard name (e.g., 'acceptCharset').
var CAMELCASE$1 = 1;
possibleStandardNamesOptimized$1.CAMELCASE = CAMELCASE$1;
possibleStandardNamesOptimized$1.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  'accept-charset': 'acceptCharset',
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: 'className',
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: 'htmlFor',
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  'http-equiv': 'httpEquiv',
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  'accent-height': 'accentHeight',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  'alignment-baseline': 'alignmentBaseline',
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  'arabic-form': 'arabicForm',
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  'baseline-shift': 'baselineShift',
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  'cap-height': 'capHeight',
  clip: 0,
  clipPath: 1,
  'clip-path': 'clipPath',
  clipPathUnits: 1,
  clipRule: 1,
  'clip-rule': 'clipRule',
  color: 0,
  colorInterpolation: 1,
  'color-interpolation': 'colorInterpolation',
  colorInterpolationFilters: 1,
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorProfile: 1,
  'color-profile': 'colorProfile',
  colorRendering: 1,
  'color-rendering': 'colorRendering',
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  'dominant-baseline': 'dominantBaseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  'enable-background': 'enableBackground',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  'fill-opacity': 'fillOpacity',
  fillRule: 1,
  'fill-rule': 'fillRule',
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  'flood-opacity': 'floodOpacity',
  floodColor: 1,
  'flood-color': 'floodColor',
  focusable: 0,
  fontFamily: 1,
  'font-family': 'fontFamily',
  fontSize: 1,
  'font-size': 'fontSize',
  fontSizeAdjust: 1,
  'font-size-adjust': 'fontSizeAdjust',
  fontStretch: 1,
  'font-stretch': 'fontStretch',
  fontStyle: 1,
  'font-style': 'fontStyle',
  fontVariant: 1,
  'font-variant': 'fontVariant',
  fontWeight: 1,
  'font-weight': 'fontWeight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  'glyph-name': 'glyphName',
  glyphOrientationHorizontal: 1,
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphOrientationVertical: 1,
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  'horiz-adv-x': 'horizAdvX',
  horizOriginX: 1,
  'horiz-origin-x': 'horizOriginX',
  ideographic: 0,
  imageRendering: 1,
  'image-rendering': 'imageRendering',
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  'letter-spacing': 'letterSpacing',
  lightingColor: 1,
  'lighting-color': 'lightingColor',
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  'marker-end': 'markerEnd',
  markerHeight: 1,
  markerMid: 1,
  'marker-mid': 'markerMid',
  markerStart: 1,
  'marker-start': 'markerStart',
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  'overline-position': 'overlinePosition',
  overlineThickness: 1,
  'overline-thickness': 'overlineThickness',
  paintOrder: 1,
  'paint-order': 'paintOrder',
  panose1: 0,
  'panose-1': 'panose1',
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  'pointer-events': 'pointerEvents',
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  'rendering-intent': 'renderingIntent',
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  'shape-rendering': 'shapeRendering',
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  'stop-color': 'stopColor',
  stopOpacity: 1,
  'stop-opacity': 'stopOpacity',
  strikethroughPosition: 1,
  'strikethrough-position': 'strikethroughPosition',
  strikethroughThickness: 1,
  'strikethrough-thickness': 'strikethroughThickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  'stroke-dasharray': 'strokeDasharray',
  strokeDashoffset: 1,
  'stroke-dashoffset': 'strokeDashoffset',
  strokeLinecap: 1,
  'stroke-linecap': 'strokeLinecap',
  strokeLinejoin: 1,
  'stroke-linejoin': 'strokeLinejoin',
  strokeMiterlimit: 1,
  'stroke-miterlimit': 'strokeMiterlimit',
  strokeWidth: 1,
  'stroke-width': 'strokeWidth',
  strokeOpacity: 1,
  'stroke-opacity': 'strokeOpacity',
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  'text-anchor': 'textAnchor',
  textDecoration: 1,
  'text-decoration': 'textDecoration',
  textLength: 1,
  textRendering: 1,
  'text-rendering': 'textRendering',
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  'underline-position': 'underlinePosition',
  underlineThickness: 1,
  'underline-thickness': 'underlineThickness',
  unicode: 0,
  unicodeBidi: 1,
  'unicode-bidi': 'unicodeBidi',
  unicodeRange: 1,
  'unicode-range': 'unicodeRange',
  unitsPerEm: 1,
  'units-per-em': 'unitsPerEm',
  unselectable: 0,
  vAlphabetic: 1,
  'v-alphabetic': 'vAlphabetic',
  values: 0,
  vectorEffect: 1,
  'vector-effect': 'vectorEffect',
  version: 0,
  vertAdvY: 1,
  'vert-adv-y': 'vertAdvY',
  vertOriginX: 1,
  'vert-origin-x': 'vertOriginX',
  vertOriginY: 1,
  'vert-origin-y': 'vertOriginY',
  vHanging: 1,
  'v-hanging': 'vHanging',
  vIdeographic: 1,
  'v-ideographic': 'vIdeographic',
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  'v-mathematical': 'vMathematical',
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  'word-spacing': 'wordSpacing',
  writingMode: 1,
  'writing-mode': 'writingMode',
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  'x-height': 'xHeight',
  xlinkActuate: 1,
  'xlink:actuate': 'xlinkActuate',
  xlinkArcrole: 1,
  'xlink:arcrole': 'xlinkArcrole',
  xlinkHref: 1,
  'xlink:href': 'xlinkHref',
  xlinkRole: 1,
  'xlink:role': 'xlinkRole',
  xlinkShow: 1,
  'xlink:show': 'xlinkShow',
  xlinkTitle: 1,
  'xlink:title': 'xlinkTitle',
  xlinkType: 1,
  'xlink:type': 'xlinkType',
  xmlBase: 1,
  'xml:base': 'xmlBase',
  xmlLang: 1,
  'xml:lang': 'xmlLang',
  xmlns: 0,
  'xml:space': 'xmlSpace',
  xmlnsXlink: 1,
  'xmlns:xlink': 'xmlnsXlink',
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};

Object.defineProperty(lib$2, '__esModule', {
  value: true
});
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED = 0; // A simple string attribute.
// Attributes that aren't in the filter are presumed to have this type.

var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.

var BOOLEANISH_STRING = 2; // A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.

var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.

var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.

var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.

var POSITIVE_NUMERIC = 6;
function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}
function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
  this.sanitizeURL = sanitizeURL;
  this.removeEmptyString = removeEmptyString;
} // When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.

var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.

var reservedProps = ['children', 'dangerouslySetInnerHTML',
// TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
reservedProps.forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false,
  // mustUseProperty
  name,
  // attributeName
  null,
  // attributeNamespace
  false,
  // sanitizeURL
  false);
}); // A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.

[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
    name = _ref2[0],
    attributeName = _ref2[1];
  properties[name] = new PropertyInfoRecord(name, STRING, false,
  // mustUseProperty
  attributeName,
  // attributeName
  null,
  // attributeNamespace
  false,
  // sanitizeURL
  false);
}); // These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).

['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false,
  // mustUseProperty
  name.toLowerCase(),
  // attributeName
  null,
  // attributeNamespace
  false,
  // sanitizeURL
  false);
}); // These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.

['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false,
  // mustUseProperty
  name,
  // attributeName
  null,
  // attributeNamespace
  false,
  // sanitizeURL
  false);
}); // These are HTML boolean attributes.

['allowFullScreen', 'async',
// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless',
// Microdata
'itemScope'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false,
  // mustUseProperty
  name.toLowerCase(),
  // attributeName
  null,
  // attributeNamespace
  false,
  // sanitizeURL
  false);
}); // These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.

['checked',
// Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true,
  // mustUseProperty
  name,
  // attributeName
  null,
  // attributeNamespace
  false,
  // sanitizeURL
  false);
}); // These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.

['capture', 'download' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false,
  // mustUseProperty
  name,
  // attributeName
  null,
  // attributeNamespace
  false,
  // sanitizeURL
  false);
}); // These are HTML attributes that must be positive numbers.

['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false,
  // mustUseProperty
  name,
  // attributeName
  null,
  // attributeNamespace
  false,
  // sanitizeURL
  false);
}); // These are HTML attributes that must be numbers.

['rowSpan', 'start'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false,
  // mustUseProperty
  name.toLowerCase(),
  // attributeName
  null,
  // attributeNamespace
  false,
  // sanitizeURL
  false);
});
var CAMELIZE = /[\-\:]([a-z])/g;
var capitalize$2 = function capitalize(token) {
  return token[1].toUpperCase();
}; // This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML attribute filter.
// Some of these attributes can be hard to find. This list was created by
// scraping the MDN documentation.

['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize$2);
  properties[name] = new PropertyInfoRecord(name, STRING, false,
  // mustUseProperty
  attributeName, null,
  // attributeNamespace
  false,
  // sanitizeURL
  false);
}); // String SVG attributes with the xlink namespace.

['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize$2);
  properties[name] = new PropertyInfoRecord(name, STRING, false,
  // mustUseProperty
  attributeName, 'http://www.w3.org/1999/xlink', false,
  // sanitizeURL
  false);
}); // String SVG attributes with the xml namespace.

['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize$2);
  properties[name] = new PropertyInfoRecord(name, STRING, false,
  // mustUseProperty
  attributeName, 'http://www.w3.org/XML/1998/namespace', false,
  // sanitizeURL
  false);
}); // These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.

['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false,
  // mustUseProperty
  attributeName.toLowerCase(),
  // attributeName
  null,
  // attributeNamespace
  false,
  // sanitizeURL
  false);
}); // These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.

var xlinkHref = 'xlinkHref';
properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false,
// mustUseProperty
'xlink:href', 'http://www.w3.org/1999/xlink', true,
// sanitizeURL
false);
['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false,
  // mustUseProperty
  attributeName.toLowerCase(),
  // attributeName
  null,
  // attributeNamespace
  true,
  // sanitizeURL
  true);
});
var _require$2 = possibleStandardNamesOptimized$1,
  CAMELCASE = _require$2.CAMELCASE,
  SAME = _require$2.SAME,
  possibleStandardNamesOptimized = _require$2.possibleStandardNames;
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
/**
 * Checks whether a property name is a custom attribute.
 *
 * @see {@link https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/HTMLDOMPropertyConfig.js#L23-L25}
 *
 * @param {string}
 * @return {boolean}
 */

var isCustomAttribute = RegExp.prototype.test.bind(
// eslint-disable-next-line no-misleading-character-class
new RegExp('^(data|aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$'));
var possibleStandardNames = Object.keys(possibleStandardNamesOptimized).reduce(function (accumulator, standardName) {
  var propName = possibleStandardNamesOptimized[standardName];
  if (propName === SAME) {
    accumulator[standardName] = standardName;
  } else if (propName === CAMELCASE) {
    accumulator[standardName.toLowerCase()] = standardName;
  } else {
    accumulator[standardName] = propName;
  }
  return accumulator;
}, {});
lib$2.BOOLEAN = BOOLEAN;
lib$2.BOOLEANISH_STRING = BOOLEANISH_STRING;
lib$2.NUMERIC = NUMERIC;
lib$2.OVERLOADED_BOOLEAN = OVERLOADED_BOOLEAN;
lib$2.POSITIVE_NUMERIC = POSITIVE_NUMERIC;
lib$2.RESERVED = RESERVED;
lib$2.STRING = STRING;
lib$2.getPropertyInfo = getPropertyInfo;
lib$2.isCustomAttribute = isCustomAttribute;
lib$2.possibleStandardNames = possibleStandardNames;

var cjs = {};

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/;

// declaration
var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/;

// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
var TRIM_REGEX = /^\s+|\s+$/g;

// strings
var NEWLINE = '\n';
var FORWARD_SLASH = '/';
var ASTERISK = '*';
var EMPTY_STRING = '';

// types
var TYPE_COMMENT = 'comment';
var TYPE_DECLARATION = 'declaration';

/**
 * @param {String} style
 * @param {Object} [options]
 * @return {Object[]}
 * @throws {TypeError}
 * @throws {Error}
 */
var inlineStyleParser = function (style, options) {
  if (typeof style !== 'string') {
    throw new TypeError('First argument must be a string');
  }
  if (!style) return [];
  options = options || {};

  /**
   * Positional.
   */
  var lineno = 1;
  var column = 1;

  /**
   * Update lineno and column based on `str`.
   *
   * @param {String} str
   */
  function updatePosition(str) {
    var lines = str.match(NEWLINE_REGEX);
    if (lines) lineno += lines.length;
    var i = str.lastIndexOf(NEWLINE);
    column = ~i ? str.length - i : column + str.length;
  }

  /**
   * Mark position and patch `node.position`.
   *
   * @return {Function}
   */
  function position() {
    var start = {
      line: lineno,
      column: column
    };
    return function (node) {
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }

  /**
   * Store position information for a node.
   *
   * @constructor
   * @property {Object} start
   * @property {Object} end
   * @property {undefined|String} source
   */
  function Position(start) {
    this.start = start;
    this.end = {
      line: lineno,
      column: column
    };
    this.source = options.source;
  }

  /**
   * Non-enumerable source string.
   */
  Position.prototype.content = style;

  /**
   * Error `msg`.
   *
   * @param {String} msg
   * @throws {Error}
   */
  function error(msg) {
    var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = style;
    if (options.silent) ; else {
      throw err;
    }
  }

  /**
   * Match `re` and return captures.
   *
   * @param {RegExp} re
   * @return {undefined|Array}
   */
  function match(re) {
    var m = re.exec(style);
    if (!m) return;
    var str = m[0];
    updatePosition(str);
    style = style.slice(str.length);
    return m;
  }

  /**
   * Parse whitespace.
   */
  function whitespace() {
    match(WHITESPACE_REGEX);
  }

  /**
   * Parse comments.
   *
   * @param {Object[]} [rules]
   * @return {Object[]}
   */
  function comments(rules) {
    var c;
    rules = rules || [];
    while (c = comment()) {
      if (c !== false) {
        rules.push(c);
      }
    }
    return rules;
  }

  /**
   * Parse comment.
   *
   * @return {Object}
   * @throws {Error}
   */
  function comment() {
    var pos = position();
    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
    var i = 2;
    while (EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
      ++i;
    }
    i += 2;
    if (EMPTY_STRING === style.charAt(i - 1)) {
      return error('End of comment missing');
    }
    var str = style.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    style = style.slice(i);
    column += 2;
    return pos({
      type: TYPE_COMMENT,
      comment: str
    });
  }

  /**
   * Parse declaration.
   *
   * @return {Object}
   * @throws {Error}
   */
  function declaration() {
    var pos = position();

    // prop
    var prop = match(PROPERTY_REGEX);
    if (!prop) return;
    comment();

    // :
    if (!match(COLON_REGEX)) return error("property missing ':'");

    // val
    var val = match(VALUE_REGEX);
    var ret = pos({
      type: TYPE_DECLARATION,
      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
      value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
    });

    // ;
    match(SEMICOLON_REGEX);
    return ret;
  }

  /**
   * Parse declarations.
   *
   * @return {Object[]}
   */
  function declarations() {
    var decls = [];
    comments(decls);

    // declarations
    var decl;
    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }
    return decls;
  }
  whitespace();
  return declarations();
};

/**
 * Trim `str`.
 *
 * @param {String} str
 * @return {String}
 */
function trim(str) {
  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}

var parse$5 = inlineStyleParser;

/**
 * Parses inline style to object.
 *
 * @example
 * // returns { 'line-height': '42' }
 * StyleToObject('line-height: 42;');
 *
 * @param  {String}      style      - The inline style.
 * @param  {Function}    [iterator] - The iterator function.
 * @return {null|Object}
 */
function StyleToObject(style, iterator) {
  var output = null;
  if (!style || typeof style !== 'string') {
    return output;
  }
  var declaration;
  var declarations = parse$5(style);
  var hasIterator = typeof iterator === 'function';
  var property;
  var value;
  for (var i = 0, len = declarations.length; i < len; i++) {
    declaration = declarations[i];
    property = declaration.property;
    value = declaration.value;
    if (hasIterator) {
      iterator(property, value, declaration);
    } else if (value) {
      output || (output = {});
      output[property] = value;
    }
  }
  return output;
}
var styleToObject = StyleToObject;

var utilities$4 = {};

utilities$4.__esModule = true;
utilities$4.camelCase = void 0;
var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9-]+$/;
var HYPHEN_REGEX = /-([a-z])/g;
var NO_HYPHEN_REGEX = /^[^-]+$/;
var VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;
var MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;
var skipCamelCase = function (property) {
  return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
};
var capitalize$1 = function (match, character) {
  return character.toUpperCase();
};
var trimHyphen = function (match, prefix) {
  return "".concat(prefix, "-");
};
var camelCase = function (property, options) {
  if (options === void 0) {
    options = {};
  }
  if (skipCamelCase(property)) {
    return property;
  }
  property = property.toLowerCase();
  if (options.reactCompat) {
    property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);
  } else {
    property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);
  }
  return property.replace(HYPHEN_REGEX, capitalize$1);
};
utilities$4.camelCase = camelCase;

(function (exports) {

	var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
	  return mod && mod.__esModule ? mod : {
	    "default": mod
	  };
	};
	exports.__esModule = true;
	var style_to_object_1 = __importDefault(styleToObject);
	var utilities_1 = utilities$4;
	function StyleToJS(style, options) {
	  var output = {};
	  if (!style || typeof style !== 'string') {
	    return output;
	  }
	  (0, style_to_object_1["default"])(style, function (property, value) {
	    if (property && value) {
	      output[(0, utilities_1.camelCase)(property, options)] = value;
	    }
	  });
	  return output;
	}
	exports["default"] = StyleToJS;
} (cjs));

var React$1 = React__default["default"];
var styleToJS = cjs.default;

/**
 * Swap key with value in an object.
 *
 * @param {object} obj - The object.
 * @param {Function} [override] - The override method.
 * @returns - The inverted object.
 */
function invertObject(obj, override) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('First argument must be an object');
  }
  var key;
  var value;
  var isOverridePresent = typeof override === 'function';
  var overrides = {};
  var result = {};
  for (key in obj) {
    value = obj[key];
    if (isOverridePresent) {
      overrides = override(key, value);
      if (overrides && overrides.length === 2) {
        result[overrides[0]] = overrides[1];
        continue;
      }
    }
    if (typeof value === 'string') {
      result[value] = key;
    }
  }
  return result;
}

/**
 * Check if a given tag is a custom component.
 *
 * @see {@link https://github.com/facebook/react/blob/v16.6.3/packages/react-dom/src/shared/isCustomComponent.js}
 *
 * @param {string} tagName - The name of the html tag.
 * @param {object} props - The props being passed to the element.
 * @returns - Whether tag is custom component.
 */
function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return props && typeof props.is === 'string';
  }
  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;
    default:
      return true;
  }
}
var styleToJSOptions = {
  reactCompat: true
};

/**
 * Sets style prop.
 *
 * @param {null|undefined|string} style
 * @param {object} props
 */
function setStyleProp$1(style, props) {
  if (style === null || style === undefined) {
    return;
  }
  try {
    props.style = styleToJS(style, styleToJSOptions);
  } catch (err) {
    props.style = {};
  }
}

/**
 * @constant {boolean}
 * @see {@link https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html}
 */
var PRESERVE_CUSTOM_ATTRIBUTES = React$1.version.split('.')[0] >= 16;

// Taken from
// https://github.com/facebook/react/blob/cae635054e17a6f107a39d328649137b83f25972/packages/react-dom/src/client/validateDOMNesting.js#L213
var elementsWithNoTextChildren = new Set(['tr', 'tbody', 'thead', 'tfoot', 'colgroup', 'table', 'head', 'html', 'frameset']);

/**
 * Checks if the given node can contain text nodes
 *
 * @param {DomElement} node - Node.
 * @returns - Whether node can contain text nodes.
 */
function canTextBeChildOfNode$1(node) {
  return !elementsWithNoTextChildren.has(node.name);
}
var utilities$3 = {
  PRESERVE_CUSTOM_ATTRIBUTES: PRESERVE_CUSTOM_ATTRIBUTES,
  invertObject: invertObject,
  isCustomComponent: isCustomComponent,
  setStyleProp: setStyleProp$1,
  canTextBeChildOfNode: canTextBeChildOfNode$1,
  elementsWithNoTextChildren: elementsWithNoTextChildren
};

var reactProperty = lib$2;
var utilities$2 = utilities$3;

/**
 * Converts HTML/SVG DOM attributes to React props.
 *
 * @param {object} [attributes={}] - HTML/SVG DOM attributes.
 * @returns - React props.
 */
var attributesToProps$2 = function attributesToProps(attributes) {
  attributes = attributes || {};
  var valueOnlyInputs = {
    reset: true,
    submit: true
  };
  var attributeName;
  var attributeNameLowerCased;
  var attributeValue;
  var propName;
  var propertyInfo;
  var props = {};
  var inputIsValueOnly = attributes.type && valueOnlyInputs[attributes.type];
  for (attributeName in attributes) {
    attributeValue = attributes[attributeName];

    // ARIA (aria-*) or custom data (data-*) attribute
    if (reactProperty.isCustomAttribute(attributeName)) {
      props[attributeName] = attributeValue;
      continue;
    }

    // convert HTML/SVG attribute to React prop
    attributeNameLowerCased = attributeName.toLowerCase();
    propName = getPropName(attributeNameLowerCased);
    if (propName) {
      propertyInfo = reactProperty.getPropertyInfo(propName);

      // convert attribute to uncontrolled component prop (e.g., `value` to `defaultValue`)
      // https://reactjs.org/docs/uncontrolled-components.html
      if ((propName === 'checked' || propName === 'value') && !inputIsValueOnly) {
        propName = getPropName('default' + attributeNameLowerCased);
      }
      props[propName] = attributeValue;
      switch (propertyInfo && propertyInfo.type) {
        case reactProperty.BOOLEAN:
          props[propName] = true;
          break;
        case reactProperty.OVERLOADED_BOOLEAN:
          if (attributeValue === '') {
            props[propName] = true;
          }
          break;
      }
      continue;
    }

    // preserve custom attribute if React >=16
    if (utilities$2.PRESERVE_CUSTOM_ATTRIBUTES) {
      props[attributeName] = attributeValue;
    }
  }

  // transform inline style to object
  utilities$2.setStyleProp(attributes.style, props);
  return props;
};

/**
 * Gets prop name from lowercased attribute name.
 *
 * @param {string} attributeName - Lowercased attribute name.
 * @returns - Prop name.
 */
function getPropName(attributeName) {
  return reactProperty.possibleStandardNames[attributeName];
}

var React = React__default["default"];
var attributesToProps$1 = attributesToProps$2;
var utilities$1 = utilities$3;
var setStyleProp = utilities$1.setStyleProp;
var canTextBeChildOfNode = utilities$1.canTextBeChildOfNode;

/**
 * Converts DOM nodes to JSX element(s).
 *
 * @param {DomElement[]} nodes - DOM nodes.
 * @param {object} [options={}] - Options.
 * @param {Function} [options.replace] - Replacer.
 * @param {object} [options.library] - Library (React, Preact, etc.).
 * @returns - String or JSX element(s).
 */
function domToReact$1(nodes, options) {
  options = options || {};
  var library = options.library || React;
  var cloneElement = library.cloneElement;
  var createElement = library.createElement;
  var isValidElement = library.isValidElement;
  var result = [];
  var node;
  var isWhitespace;
  var hasReplace = typeof options.replace === 'function';
  var replaceElement;
  var props;
  var children;
  var trim = options.trim;
  for (var i = 0, len = nodes.length; i < len; i++) {
    node = nodes[i];

    // replace with custom React element (if present)
    if (hasReplace) {
      replaceElement = options.replace(node);
      if (isValidElement(replaceElement)) {
        // set "key" prop for sibling elements
        // https://fb.me/react-warning-keys
        if (len > 1) {
          replaceElement = cloneElement(replaceElement, {
            key: replaceElement.key || i
          });
        }
        result.push(replaceElement);
        continue;
      }
    }
    if (node.type === 'text') {
      isWhitespace = !node.data.trim().length;
      if (isWhitespace && node.parent && !canTextBeChildOfNode(node.parent)) {
        // We have a whitespace node that can't be nested in its parent
        // so skip it
        continue;
      }
      if (trim && isWhitespace) {
        // Trim is enabled and we have a whitespace node
        // so skip it
        continue;
      }

      // We have a text node that's not whitespace and it can be nested
      // in its parent so add it to the results
      result.push(node.data);
      continue;
    }
    props = node.attribs;
    if (skipAttributesToProps(node)) {
      setStyleProp(props.style, props);
    } else if (props) {
      props = attributesToProps$1(props);
    }
    children = null;
    switch (node.type) {
      case 'script':
      case 'style':
        // prevent text in <script> or <style> from being escaped
        // https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml
        if (node.children[0]) {
          props.dangerouslySetInnerHTML = {
            __html: node.children[0].data
          };
        }
        break;
      case 'tag':
        // setting textarea value in children is an antipattern in React
        // https://reactjs.org/docs/forms.html#the-textarea-tag
        if (node.name === 'textarea' && node.children[0]) {
          props.defaultValue = node.children[0].data;
        } else if (node.children && node.children.length) {
          // continue recursion of creating React elements (if applicable)
          children = domToReact$1(node.children, options);
        }
        break;

      // skip all other cases (e.g., comment)
      default:
        continue;
    }

    // set "key" prop for sibling elements
    // https://fb.me/react-warning-keys
    if (len > 1) {
      props.key = i;
    }
    result.push(createElement(node.name, props, children));
  }
  return result.length === 1 ? result[0] : result;
}

/**
 * Determines whether DOM element attributes should be transformed to props.
 * Web Components should not have their attributes transformed except for `style`.
 *
 * @param {DomElement} node
 * @returns - Whether node attributes should be converted to props.
 */
function skipAttributesToProps(node) {
  return utilities$1.PRESERVE_CUSTOM_ATTRIBUTES && node.type === 'tag' && utilities$1.isCustomComponent(node.name, node.attribs);
}
var domToReact_1 = domToReact$1;

var htmlDomParser = {exports: {}};

var Parser$3 = {};

var Tokenizer$1 = {};

var decode_codepoint = {};

// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
Object.defineProperty(decode_codepoint, "__esModule", {
  value: true
});
var decodeMap = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]);
var fromCodePoint =
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
String.fromCodePoint || function (codePoint) {
  var output = "";
  if (codePoint > 0xffff) {
    codePoint -= 0x10000;
    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
    codePoint = 0xdc00 | codePoint & 0x3ff;
  }
  output += String.fromCharCode(codePoint);
  return output;
};
function decodeCodePoint(codePoint) {
  var _a;
  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
    return "\uFFFD";
  }
  return fromCodePoint((_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint);
}
decode_codepoint.default = decodeCodePoint;

var decode = {};

var decodeDataHtml = {};

Object.defineProperty(decodeDataHtml, "__esModule", {
  value: true
});
// Generated using scripts/write-decode-map.ts
// prettier-ignore
decodeDataHtml.default = new Uint16Array([14866, 60, 237, 340, 721, 1312, 1562, 1654, 1838, 1957, 2183, 2239, 2301, 2958, 3037, 3893, 4123, 4298, 4330, 4801, 5191, 5395, 5752, 5903, 5943, 5972, 6050, 0, 0, 0, 0, 0, 0, 6135, 6565, 7422, 8183, 8738, 9242, 9503, 9938, 10189, 10573, 10637, 10715, 11950, 12246, 13539, 13950, 14445, 14533, 15364, 16514, 16980, 17390, 17763, 17849, 18036, 18125, 4096, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 92, 100, 106, 115, 122, 137, 142, 151, 157, 163, 167, 182, 196, 204, 220, 229, 108, 105, 103, 33024, 198, 59, 32768, 198, 80, 33024, 38, 59, 32768, 38, 99, 117, 116, 101, 33024, 193, 59, 32768, 193, 114, 101, 118, 101, 59, 32768, 258, 512, 105, 121, 127, 134, 114, 99, 33024, 194, 59, 32768, 194, 59, 32768, 1040, 114, 59, 32896, 55349, 56580, 114, 97, 118, 101, 33024, 192, 59, 32768, 192, 112, 104, 97, 59, 32768, 913, 97, 99, 114, 59, 32768, 256, 100, 59, 32768, 10835, 512, 103, 112, 172, 177, 111, 110, 59, 32768, 260, 102, 59, 32896, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 32768, 8289, 105, 110, 103, 33024, 197, 59, 32768, 197, 512, 99, 115, 209, 214, 114, 59, 32896, 55349, 56476, 105, 103, 110, 59, 32768, 8788, 105, 108, 100, 101, 33024, 195, 59, 32768, 195, 109, 108, 33024, 196, 59, 32768, 196, 2048, 97, 99, 101, 102, 111, 114, 115, 117, 253, 278, 282, 310, 315, 321, 327, 332, 512, 99, 114, 258, 267, 107, 115, 108, 97, 115, 104, 59, 32768, 8726, 583, 271, 274, 59, 32768, 10983, 101, 100, 59, 32768, 8966, 121, 59, 32768, 1041, 768, 99, 114, 116, 289, 296, 306, 97, 117, 115, 101, 59, 32768, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 32768, 8492, 97, 59, 32768, 914, 114, 59, 32896, 55349, 56581, 112, 102, 59, 32896, 55349, 56633, 101, 118, 101, 59, 32768, 728, 99, 114, 59, 32768, 8492, 109, 112, 101, 113, 59, 32768, 8782, 3584, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 368, 373, 380, 426, 461, 466, 487, 491, 495, 533, 593, 695, 701, 707, 99, 121, 59, 32768, 1063, 80, 89, 33024, 169, 59, 32768, 169, 768, 99, 112, 121, 387, 393, 419, 117, 116, 101, 59, 32768, 262, 512, 59, 105, 398, 400, 32768, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 32768, 8517, 108, 101, 121, 115, 59, 32768, 8493, 1024, 97, 101, 105, 111, 435, 441, 449, 454, 114, 111, 110, 59, 32768, 268, 100, 105, 108, 33024, 199, 59, 32768, 199, 114, 99, 59, 32768, 264, 110, 105, 110, 116, 59, 32768, 8752, 111, 116, 59, 32768, 266, 512, 100, 110, 471, 478, 105, 108, 108, 97, 59, 32768, 184, 116, 101, 114, 68, 111, 116, 59, 32768, 183, 114, 59, 32768, 8493, 105, 59, 32768, 935, 114, 99, 108, 101, 1024, 68, 77, 80, 84, 508, 513, 520, 526, 111, 116, 59, 32768, 8857, 105, 110, 117, 115, 59, 32768, 8854, 108, 117, 115, 59, 32768, 8853, 105, 109, 101, 115, 59, 32768, 8855, 111, 512, 99, 115, 539, 562, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8754, 101, 67, 117, 114, 108, 121, 512, 68, 81, 573, 586, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 32768, 8221, 117, 111, 116, 101, 59, 32768, 8217, 1024, 108, 110, 112, 117, 602, 614, 648, 664, 111, 110, 512, 59, 101, 609, 611, 32768, 8759, 59, 32768, 10868, 768, 103, 105, 116, 621, 629, 634, 114, 117, 101, 110, 116, 59, 32768, 8801, 110, 116, 59, 32768, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8750, 512, 102, 114, 653, 656, 59, 32768, 8450, 111, 100, 117, 99, 116, 59, 32768, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8755, 111, 115, 115, 59, 32768, 10799, 99, 114, 59, 32896, 55349, 56478, 112, 512, 59, 67, 713, 715, 32768, 8915, 97, 112, 59, 32768, 8781, 2816, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 743, 758, 763, 768, 773, 795, 809, 821, 826, 910, 1295, 512, 59, 111, 748, 750, 32768, 8517, 116, 114, 97, 104, 100, 59, 32768, 10513, 99, 121, 59, 32768, 1026, 99, 121, 59, 32768, 1029, 99, 121, 59, 32768, 1039, 768, 103, 114, 115, 780, 786, 790, 103, 101, 114, 59, 32768, 8225, 114, 59, 32768, 8609, 104, 118, 59, 32768, 10980, 512, 97, 121, 800, 806, 114, 111, 110, 59, 32768, 270, 59, 32768, 1044, 108, 512, 59, 116, 815, 817, 32768, 8711, 97, 59, 32768, 916, 114, 59, 32896, 55349, 56583, 512, 97, 102, 831, 897, 512, 99, 109, 836, 891, 114, 105, 116, 105, 99, 97, 108, 1024, 65, 68, 71, 84, 852, 859, 877, 884, 99, 117, 116, 101, 59, 32768, 180, 111, 581, 864, 867, 59, 32768, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 32768, 733, 114, 97, 118, 101, 59, 32768, 96, 105, 108, 100, 101, 59, 32768, 732, 111, 110, 100, 59, 32768, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 32768, 8518, 2113, 920, 0, 0, 0, 925, 946, 0, 1139, 102, 59, 32896, 55349, 56635, 768, 59, 68, 69, 931, 933, 938, 32768, 168, 111, 116, 59, 32768, 8412, 113, 117, 97, 108, 59, 32768, 8784, 98, 108, 101, 1536, 67, 68, 76, 82, 85, 86, 961, 978, 996, 1080, 1101, 1125, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8751, 111, 1093, 985, 0, 0, 988, 59, 32768, 168, 110, 65, 114, 114, 111, 119, 59, 32768, 8659, 512, 101, 111, 1001, 1034, 102, 116, 768, 65, 82, 84, 1010, 1017, 1029, 114, 114, 111, 119, 59, 32768, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8660, 101, 101, 59, 32768, 10980, 110, 103, 512, 76, 82, 1041, 1068, 101, 102, 116, 512, 65, 82, 1049, 1056, 114, 114, 111, 119, 59, 32768, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10233, 105, 103, 104, 116, 512, 65, 84, 1089, 1096, 114, 114, 111, 119, 59, 32768, 8658, 101, 101, 59, 32768, 8872, 112, 1042, 1108, 0, 0, 1115, 114, 114, 111, 119, 59, 32768, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 32768, 8741, 110, 1536, 65, 66, 76, 82, 84, 97, 1152, 1179, 1186, 1236, 1272, 1288, 114, 114, 111, 119, 768, 59, 66, 85, 1163, 1165, 1170, 32768, 8595, 97, 114, 59, 32768, 10515, 112, 65, 114, 114, 111, 119, 59, 32768, 8693, 114, 101, 118, 101, 59, 32768, 785, 101, 102, 116, 1315, 1196, 0, 1209, 0, 1220, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 32768, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10590, 101, 99, 116, 111, 114, 512, 59, 66, 1229, 1231, 32768, 8637, 97, 114, 59, 32768, 10582, 105, 103, 104, 116, 805, 1245, 0, 1256, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10591, 101, 99, 116, 111, 114, 512, 59, 66, 1265, 1267, 32768, 8641, 97, 114, 59, 32768, 10583, 101, 101, 512, 59, 65, 1279, 1281, 32768, 8868, 114, 114, 111, 119, 59, 32768, 8615, 114, 114, 111, 119, 59, 32768, 8659, 512, 99, 116, 1300, 1305, 114, 59, 32896, 55349, 56479, 114, 111, 107, 59, 32768, 272, 4096, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1344, 1348, 1354, 1363, 1386, 1391, 1396, 1405, 1413, 1460, 1475, 1483, 1514, 1527, 1531, 1538, 71, 59, 32768, 330, 72, 33024, 208, 59, 32768, 208, 99, 117, 116, 101, 33024, 201, 59, 32768, 201, 768, 97, 105, 121, 1370, 1376, 1383, 114, 111, 110, 59, 32768, 282, 114, 99, 33024, 202, 59, 32768, 202, 59, 32768, 1069, 111, 116, 59, 32768, 278, 114, 59, 32896, 55349, 56584, 114, 97, 118, 101, 33024, 200, 59, 32768, 200, 101, 109, 101, 110, 116, 59, 32768, 8712, 512, 97, 112, 1418, 1423, 99, 114, 59, 32768, 274, 116, 121, 1060, 1431, 0, 0, 1444, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9643, 512, 103, 112, 1465, 1470, 111, 110, 59, 32768, 280, 102, 59, 32896, 55349, 56636, 115, 105, 108, 111, 110, 59, 32768, 917, 117, 512, 97, 105, 1489, 1504, 108, 512, 59, 84, 1495, 1497, 32768, 10869, 105, 108, 100, 101, 59, 32768, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 8652, 512, 99, 105, 1519, 1523, 114, 59, 32768, 8496, 109, 59, 32768, 10867, 97, 59, 32768, 919, 109, 108, 33024, 203, 59, 32768, 203, 512, 105, 112, 1543, 1549, 115, 116, 115, 59, 32768, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 32768, 8519, 1280, 99, 102, 105, 111, 115, 1572, 1576, 1581, 1620, 1648, 121, 59, 32768, 1060, 114, 59, 32896, 55349, 56585, 108, 108, 101, 100, 1060, 1591, 0, 0, 1604, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9642, 1601, 1628, 0, 1633, 0, 0, 1639, 102, 59, 32896, 55349, 56637, 65, 108, 108, 59, 32768, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 32768, 8497, 99, 114, 59, 32768, 8497, 3072, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1678, 1683, 1688, 1701, 1708, 1729, 1734, 1739, 1742, 1748, 1828, 1834, 99, 121, 59, 32768, 1027, 33024, 62, 59, 32768, 62, 109, 109, 97, 512, 59, 100, 1696, 1698, 32768, 915, 59, 32768, 988, 114, 101, 118, 101, 59, 32768, 286, 768, 101, 105, 121, 1715, 1721, 1726, 100, 105, 108, 59, 32768, 290, 114, 99, 59, 32768, 284, 59, 32768, 1043, 111, 116, 59, 32768, 288, 114, 59, 32896, 55349, 56586, 59, 32768, 8921, 112, 102, 59, 32896, 55349, 56638, 101, 97, 116, 101, 114, 1536, 69, 70, 71, 76, 83, 84, 1766, 1783, 1794, 1803, 1809, 1821, 113, 117, 97, 108, 512, 59, 76, 1775, 1777, 32768, 8805, 101, 115, 115, 59, 32768, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8807, 114, 101, 97, 116, 101, 114, 59, 32768, 10914, 101, 115, 115, 59, 32768, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 10878, 105, 108, 100, 101, 59, 32768, 8819, 99, 114, 59, 32896, 55349, 56482, 59, 32768, 8811, 2048, 65, 97, 99, 102, 105, 111, 115, 117, 1854, 1861, 1874, 1880, 1884, 1897, 1919, 1934, 82, 68, 99, 121, 59, 32768, 1066, 512, 99, 116, 1866, 1871, 101, 107, 59, 32768, 711, 59, 32768, 94, 105, 114, 99, 59, 32768, 292, 114, 59, 32768, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 32768, 8459, 833, 1902, 0, 1906, 102, 59, 32768, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 32768, 9472, 512, 99, 116, 1924, 1928, 114, 59, 32768, 8459, 114, 111, 107, 59, 32768, 294, 109, 112, 533, 1940, 1950, 111, 119, 110, 72, 117, 109, 112, 59, 32768, 8782, 113, 117, 97, 108, 59, 32768, 8783, 3584, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 1985, 1990, 1996, 2001, 2010, 2025, 2030, 2034, 2043, 2077, 2134, 2155, 2160, 2167, 99, 121, 59, 32768, 1045, 108, 105, 103, 59, 32768, 306, 99, 121, 59, 32768, 1025, 99, 117, 116, 101, 33024, 205, 59, 32768, 205, 512, 105, 121, 2015, 2022, 114, 99, 33024, 206, 59, 32768, 206, 59, 32768, 1048, 111, 116, 59, 32768, 304, 114, 59, 32768, 8465, 114, 97, 118, 101, 33024, 204, 59, 32768, 204, 768, 59, 97, 112, 2050, 2052, 2070, 32768, 8465, 512, 99, 103, 2057, 2061, 114, 59, 32768, 298, 105, 110, 97, 114, 121, 73, 59, 32768, 8520, 108, 105, 101, 115, 59, 32768, 8658, 837, 2082, 0, 2110, 512, 59, 101, 2086, 2088, 32768, 8748, 512, 103, 114, 2093, 2099, 114, 97, 108, 59, 32768, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 32768, 8898, 105, 115, 105, 98, 108, 101, 512, 67, 84, 2120, 2127, 111, 109, 109, 97, 59, 32768, 8291, 105, 109, 101, 115, 59, 32768, 8290, 768, 103, 112, 116, 2141, 2146, 2151, 111, 110, 59, 32768, 302, 102, 59, 32896, 55349, 56640, 97, 59, 32768, 921, 99, 114, 59, 32768, 8464, 105, 108, 100, 101, 59, 32768, 296, 828, 2172, 0, 2177, 99, 121, 59, 32768, 1030, 108, 33024, 207, 59, 32768, 207, 1280, 99, 102, 111, 115, 117, 2193, 2206, 2211, 2217, 2232, 512, 105, 121, 2198, 2203, 114, 99, 59, 32768, 308, 59, 32768, 1049, 114, 59, 32896, 55349, 56589, 112, 102, 59, 32896, 55349, 56641, 820, 2222, 0, 2227, 114, 59, 32896, 55349, 56485, 114, 99, 121, 59, 32768, 1032, 107, 99, 121, 59, 32768, 1028, 1792, 72, 74, 97, 99, 102, 111, 115, 2253, 2258, 2263, 2269, 2283, 2288, 2294, 99, 121, 59, 32768, 1061, 99, 121, 59, 32768, 1036, 112, 112, 97, 59, 32768, 922, 512, 101, 121, 2274, 2280, 100, 105, 108, 59, 32768, 310, 59, 32768, 1050, 114, 59, 32896, 55349, 56590, 112, 102, 59, 32896, 55349, 56642, 99, 114, 59, 32896, 55349, 56486, 2816, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2323, 2328, 2333, 2374, 2396, 2775, 2780, 2797, 2804, 2934, 2954, 99, 121, 59, 32768, 1033, 33024, 60, 59, 32768, 60, 1280, 99, 109, 110, 112, 114, 2344, 2350, 2356, 2360, 2370, 117, 116, 101, 59, 32768, 313, 98, 100, 97, 59, 32768, 923, 103, 59, 32768, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 32768, 8466, 114, 59, 32768, 8606, 768, 97, 101, 121, 2381, 2387, 2393, 114, 111, 110, 59, 32768, 317, 100, 105, 108, 59, 32768, 315, 59, 32768, 1051, 512, 102, 115, 2401, 2702, 116, 2560, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2423, 2470, 2479, 2530, 2537, 2561, 2618, 2666, 2683, 2690, 512, 110, 114, 2428, 2441, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10216, 114, 111, 119, 768, 59, 66, 82, 2451, 2453, 2458, 32768, 8592, 97, 114, 59, 32768, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8646, 101, 105, 108, 105, 110, 103, 59, 32768, 8968, 111, 838, 2485, 0, 2498, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10214, 110, 805, 2503, 0, 2514, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10593, 101, 99, 116, 111, 114, 512, 59, 66, 2523, 2525, 32768, 8643, 97, 114, 59, 32768, 10585, 108, 111, 111, 114, 59, 32768, 8970, 105, 103, 104, 116, 512, 65, 86, 2546, 2553, 114, 114, 111, 119, 59, 32768, 8596, 101, 99, 116, 111, 114, 59, 32768, 10574, 512, 101, 114, 2566, 2591, 101, 768, 59, 65, 86, 2574, 2576, 2583, 32768, 8867, 114, 114, 111, 119, 59, 32768, 8612, 101, 99, 116, 111, 114, 59, 32768, 10586, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 2604, 2606, 2611, 32768, 8882, 97, 114, 59, 32768, 10703, 113, 117, 97, 108, 59, 32768, 8884, 112, 768, 68, 84, 86, 2626, 2638, 2649, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 32768, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10592, 101, 99, 116, 111, 114, 512, 59, 66, 2659, 2661, 32768, 8639, 97, 114, 59, 32768, 10584, 101, 99, 116, 111, 114, 512, 59, 66, 2676, 2678, 32768, 8636, 97, 114, 59, 32768, 10578, 114, 114, 111, 119, 59, 32768, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8660, 115, 1536, 69, 70, 71, 76, 83, 84, 2716, 2730, 2741, 2750, 2756, 2768, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 32768, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8806, 114, 101, 97, 116, 101, 114, 59, 32768, 8822, 101, 115, 115, 59, 32768, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 10877, 105, 108, 100, 101, 59, 32768, 8818, 114, 59, 32896, 55349, 56591, 512, 59, 101, 2785, 2787, 32768, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 32768, 8666, 105, 100, 111, 116, 59, 32768, 319, 768, 110, 112, 119, 2811, 2899, 2904, 103, 1024, 76, 82, 108, 114, 2821, 2848, 2860, 2887, 101, 102, 116, 512, 65, 82, 2829, 2836, 114, 114, 111, 119, 59, 32768, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10230, 101, 102, 116, 512, 97, 114, 2868, 2875, 114, 114, 111, 119, 59, 32768, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10233, 102, 59, 32896, 55349, 56643, 101, 114, 512, 76, 82, 2911, 2922, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8600, 768, 99, 104, 116, 2941, 2945, 2948, 114, 59, 32768, 8466, 59, 32768, 8624, 114, 111, 107, 59, 32768, 321, 59, 32768, 8810, 2048, 97, 99, 101, 102, 105, 111, 115, 117, 2974, 2978, 2982, 3007, 3012, 3022, 3028, 3033, 112, 59, 32768, 10501, 121, 59, 32768, 1052, 512, 100, 108, 2987, 2998, 105, 117, 109, 83, 112, 97, 99, 101, 59, 32768, 8287, 108, 105, 110, 116, 114, 102, 59, 32768, 8499, 114, 59, 32896, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 32768, 8723, 112, 102, 59, 32896, 55349, 56644, 99, 114, 59, 32768, 8499, 59, 32768, 924, 2304, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3055, 3060, 3067, 3089, 3201, 3206, 3874, 3880, 3889, 99, 121, 59, 32768, 1034, 99, 117, 116, 101, 59, 32768, 323, 768, 97, 101, 121, 3074, 3080, 3086, 114, 111, 110, 59, 32768, 327, 100, 105, 108, 59, 32768, 325, 59, 32768, 1053, 768, 103, 115, 119, 3096, 3160, 3194, 97, 116, 105, 118, 101, 768, 77, 84, 86, 3108, 3121, 3145, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 32768, 8203, 104, 105, 512, 99, 110, 3128, 3137, 107, 83, 112, 97, 99, 101, 59, 32768, 8203, 83, 112, 97, 99, 101, 59, 32768, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 32768, 8203, 116, 101, 100, 512, 71, 76, 3168, 3184, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 32768, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 32768, 8810, 76, 105, 110, 101, 59, 32768, 10, 114, 59, 32896, 55349, 56593, 1024, 66, 110, 112, 116, 3215, 3222, 3238, 3242, 114, 101, 97, 107, 59, 32768, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 32768, 160, 102, 59, 32768, 8469, 3328, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3269, 3271, 3293, 3312, 3352, 3430, 3455, 3551, 3589, 3625, 3678, 3821, 3861, 32768, 10988, 512, 111, 117, 3276, 3286, 110, 103, 114, 117, 101, 110, 116, 59, 32768, 8802, 112, 67, 97, 112, 59, 32768, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 32768, 8742, 768, 108, 113, 120, 3319, 3327, 3345, 101, 109, 101, 110, 116, 59, 32768, 8713, 117, 97, 108, 512, 59, 84, 3335, 3337, 32768, 8800, 105, 108, 100, 101, 59, 32896, 8770, 824, 105, 115, 116, 115, 59, 32768, 8708, 114, 101, 97, 116, 101, 114, 1792, 59, 69, 70, 71, 76, 83, 84, 3373, 3375, 3382, 3394, 3404, 3410, 3423, 32768, 8815, 113, 117, 97, 108, 59, 32768, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32896, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 32896, 8811, 824, 101, 115, 115, 59, 32768, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32896, 10878, 824, 105, 108, 100, 101, 59, 32768, 8821, 117, 109, 112, 533, 3437, 3448, 111, 119, 110, 72, 117, 109, 112, 59, 32896, 8782, 824, 113, 117, 97, 108, 59, 32896, 8783, 824, 101, 512, 102, 115, 3461, 3492, 116, 84, 114, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 3477, 3479, 3485, 32768, 8938, 97, 114, 59, 32896, 10703, 824, 113, 117, 97, 108, 59, 32768, 8940, 115, 1536, 59, 69, 71, 76, 83, 84, 3506, 3508, 3515, 3524, 3531, 3544, 32768, 8814, 113, 117, 97, 108, 59, 32768, 8816, 114, 101, 97, 116, 101, 114, 59, 32768, 8824, 101, 115, 115, 59, 32896, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32896, 10877, 824, 105, 108, 100, 101, 59, 32768, 8820, 101, 115, 116, 101, 100, 512, 71, 76, 3561, 3578, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 32896, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 32896, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 768, 59, 69, 83, 3603, 3605, 3613, 32768, 8832, 113, 117, 97, 108, 59, 32896, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8928, 512, 101, 105, 3630, 3645, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 32768, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 3663, 3665, 3671, 32768, 8939, 97, 114, 59, 32896, 10704, 824, 113, 117, 97, 108, 59, 32768, 8941, 512, 113, 117, 3683, 3732, 117, 97, 114, 101, 83, 117, 512, 98, 112, 3694, 3712, 115, 101, 116, 512, 59, 69, 3702, 3705, 32896, 8847, 824, 113, 117, 97, 108, 59, 32768, 8930, 101, 114, 115, 101, 116, 512, 59, 69, 3722, 3725, 32896, 8848, 824, 113, 117, 97, 108, 59, 32768, 8931, 768, 98, 99, 112, 3739, 3757, 3801, 115, 101, 116, 512, 59, 69, 3747, 3750, 32896, 8834, 8402, 113, 117, 97, 108, 59, 32768, 8840, 99, 101, 101, 100, 115, 1024, 59, 69, 83, 84, 3771, 3773, 3781, 3793, 32768, 8833, 113, 117, 97, 108, 59, 32896, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8929, 105, 108, 100, 101, 59, 32896, 8831, 824, 101, 114, 115, 101, 116, 512, 59, 69, 3811, 3814, 32896, 8835, 8402, 113, 117, 97, 108, 59, 32768, 8841, 105, 108, 100, 101, 1024, 59, 69, 70, 84, 3834, 3836, 3843, 3854, 32768, 8769, 113, 117, 97, 108, 59, 32768, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8775, 105, 108, 100, 101, 59, 32768, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 32768, 8740, 99, 114, 59, 32896, 55349, 56489, 105, 108, 100, 101, 33024, 209, 59, 32768, 209, 59, 32768, 925, 3584, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 3921, 3927, 3936, 3951, 3958, 3963, 3972, 3996, 4002, 4034, 4037, 4055, 4071, 4078, 108, 105, 103, 59, 32768, 338, 99, 117, 116, 101, 33024, 211, 59, 32768, 211, 512, 105, 121, 3941, 3948, 114, 99, 33024, 212, 59, 32768, 212, 59, 32768, 1054, 98, 108, 97, 99, 59, 32768, 336, 114, 59, 32896, 55349, 56594, 114, 97, 118, 101, 33024, 210, 59, 32768, 210, 768, 97, 101, 105, 3979, 3984, 3989, 99, 114, 59, 32768, 332, 103, 97, 59, 32768, 937, 99, 114, 111, 110, 59, 32768, 927, 112, 102, 59, 32896, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 512, 68, 81, 4014, 4027, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 32768, 8220, 117, 111, 116, 101, 59, 32768, 8216, 59, 32768, 10836, 512, 99, 108, 4042, 4047, 114, 59, 32896, 55349, 56490, 97, 115, 104, 33024, 216, 59, 32768, 216, 105, 573, 4060, 4067, 100, 101, 33024, 213, 59, 32768, 213, 101, 115, 59, 32768, 10807, 109, 108, 33024, 214, 59, 32768, 214, 101, 114, 512, 66, 80, 4085, 4109, 512, 97, 114, 4090, 4094, 114, 59, 32768, 8254, 97, 99, 512, 101, 107, 4101, 4104, 59, 32768, 9182, 101, 116, 59, 32768, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 32768, 9180, 2304, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4141, 4150, 4154, 4159, 4163, 4166, 4176, 4198, 4284, 114, 116, 105, 97, 108, 68, 59, 32768, 8706, 121, 59, 32768, 1055, 114, 59, 32896, 55349, 56595, 105, 59, 32768, 934, 59, 32768, 928, 117, 115, 77, 105, 110, 117, 115, 59, 32768, 177, 512, 105, 112, 4181, 4194, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 32768, 8460, 102, 59, 32768, 8473, 1024, 59, 101, 105, 111, 4207, 4209, 4251, 4256, 32768, 10939, 99, 101, 100, 101, 115, 1024, 59, 69, 83, 84, 4223, 4225, 4232, 4244, 32768, 8826, 113, 117, 97, 108, 59, 32768, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8828, 105, 108, 100, 101, 59, 32768, 8830, 109, 101, 59, 32768, 8243, 512, 100, 112, 4261, 4267, 117, 99, 116, 59, 32768, 8719, 111, 114, 116, 105, 111, 110, 512, 59, 97, 4278, 4280, 32768, 8759, 108, 59, 32768, 8733, 512, 99, 105, 4289, 4294, 114, 59, 32896, 55349, 56491, 59, 32768, 936, 1024, 85, 102, 111, 115, 4306, 4313, 4318, 4323, 79, 84, 33024, 34, 59, 32768, 34, 114, 59, 32896, 55349, 56596, 112, 102, 59, 32768, 8474, 99, 114, 59, 32896, 55349, 56492, 3072, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4354, 4360, 4366, 4395, 4417, 4473, 4477, 4481, 4743, 4764, 4776, 4788, 97, 114, 114, 59, 32768, 10512, 71, 33024, 174, 59, 32768, 174, 768, 99, 110, 114, 4373, 4379, 4383, 117, 116, 101, 59, 32768, 340, 103, 59, 32768, 10219, 114, 512, 59, 116, 4389, 4391, 32768, 8608, 108, 59, 32768, 10518, 768, 97, 101, 121, 4402, 4408, 4414, 114, 111, 110, 59, 32768, 344, 100, 105, 108, 59, 32768, 342, 59, 32768, 1056, 512, 59, 118, 4422, 4424, 32768, 8476, 101, 114, 115, 101, 512, 69, 85, 4433, 4458, 512, 108, 113, 4438, 4446, 101, 109, 101, 110, 116, 59, 32768, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 10607, 114, 59, 32768, 8476, 111, 59, 32768, 929, 103, 104, 116, 2048, 65, 67, 68, 70, 84, 85, 86, 97, 4501, 4547, 4556, 4607, 4614, 4671, 4719, 4736, 512, 110, 114, 4506, 4519, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10217, 114, 111, 119, 768, 59, 66, 76, 4529, 4531, 4536, 32768, 8594, 97, 114, 59, 32768, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8644, 101, 105, 108, 105, 110, 103, 59, 32768, 8969, 111, 838, 4562, 0, 4575, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10215, 110, 805, 4580, 0, 4591, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10589, 101, 99, 116, 111, 114, 512, 59, 66, 4600, 4602, 32768, 8642, 97, 114, 59, 32768, 10581, 108, 111, 111, 114, 59, 32768, 8971, 512, 101, 114, 4619, 4644, 101, 768, 59, 65, 86, 4627, 4629, 4636, 32768, 8866, 114, 114, 111, 119, 59, 32768, 8614, 101, 99, 116, 111, 114, 59, 32768, 10587, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 4657, 4659, 4664, 32768, 8883, 97, 114, 59, 32768, 10704, 113, 117, 97, 108, 59, 32768, 8885, 112, 768, 68, 84, 86, 4679, 4691, 4702, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 32768, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10588, 101, 99, 116, 111, 114, 512, 59, 66, 4712, 4714, 32768, 8638, 97, 114, 59, 32768, 10580, 101, 99, 116, 111, 114, 512, 59, 66, 4729, 4731, 32768, 8640, 97, 114, 59, 32768, 10579, 114, 114, 111, 119, 59, 32768, 8658, 512, 112, 117, 4748, 4752, 102, 59, 32768, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 32768, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8667, 512, 99, 104, 4781, 4785, 114, 59, 32768, 8475, 59, 32768, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 32768, 10740, 3328, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 4827, 4842, 4849, 4856, 4889, 4894, 4949, 4955, 4967, 4973, 5059, 5065, 5070, 512, 67, 99, 4832, 4838, 72, 99, 121, 59, 32768, 1065, 121, 59, 32768, 1064, 70, 84, 99, 121, 59, 32768, 1068, 99, 117, 116, 101, 59, 32768, 346, 1280, 59, 97, 101, 105, 121, 4867, 4869, 4875, 4881, 4886, 32768, 10940, 114, 111, 110, 59, 32768, 352, 100, 105, 108, 59, 32768, 350, 114, 99, 59, 32768, 348, 59, 32768, 1057, 114, 59, 32896, 55349, 56598, 111, 114, 116, 1024, 68, 76, 82, 85, 4906, 4917, 4928, 4940, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8594, 112, 65, 114, 114, 111, 119, 59, 32768, 8593, 103, 109, 97, 59, 32768, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 32768, 8728, 112, 102, 59, 32896, 55349, 56650, 1091, 4979, 0, 0, 4983, 116, 59, 32768, 8730, 97, 114, 101, 1024, 59, 73, 83, 85, 4994, 4996, 5010, 5052, 32768, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 32768, 8851, 117, 512, 98, 112, 5016, 5033, 115, 101, 116, 512, 59, 69, 5024, 5026, 32768, 8847, 113, 117, 97, 108, 59, 32768, 8849, 101, 114, 115, 101, 116, 512, 59, 69, 5043, 5045, 32768, 8848, 113, 117, 97, 108, 59, 32768, 8850, 110, 105, 111, 110, 59, 32768, 8852, 99, 114, 59, 32896, 55349, 56494, 97, 114, 59, 32768, 8902, 1024, 98, 99, 109, 112, 5079, 5102, 5155, 5158, 512, 59, 115, 5084, 5086, 32768, 8912, 101, 116, 512, 59, 69, 5093, 5095, 32768, 8912, 113, 117, 97, 108, 59, 32768, 8838, 512, 99, 104, 5107, 5148, 101, 101, 100, 115, 1024, 59, 69, 83, 84, 5120, 5122, 5129, 5141, 32768, 8827, 113, 117, 97, 108, 59, 32768, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8829, 105, 108, 100, 101, 59, 32768, 8831, 84, 104, 97, 116, 59, 32768, 8715, 59, 32768, 8721, 768, 59, 101, 115, 5165, 5167, 5185, 32768, 8913, 114, 115, 101, 116, 512, 59, 69, 5176, 5178, 32768, 8835, 113, 117, 97, 108, 59, 32768, 8839, 101, 116, 59, 32768, 8913, 2816, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5213, 5221, 5227, 5241, 5252, 5274, 5279, 5323, 5362, 5368, 5378, 79, 82, 78, 33024, 222, 59, 32768, 222, 65, 68, 69, 59, 32768, 8482, 512, 72, 99, 5232, 5237, 99, 121, 59, 32768, 1035, 121, 59, 32768, 1062, 512, 98, 117, 5246, 5249, 59, 32768, 9, 59, 32768, 932, 768, 97, 101, 121, 5259, 5265, 5271, 114, 111, 110, 59, 32768, 356, 100, 105, 108, 59, 32768, 354, 59, 32768, 1058, 114, 59, 32896, 55349, 56599, 512, 101, 105, 5284, 5300, 835, 5289, 0, 5297, 101, 102, 111, 114, 101, 59, 32768, 8756, 97, 59, 32768, 920, 512, 99, 110, 5305, 5315, 107, 83, 112, 97, 99, 101, 59, 32896, 8287, 8202, 83, 112, 97, 99, 101, 59, 32768, 8201, 108, 100, 101, 1024, 59, 69, 70, 84, 5335, 5337, 5344, 5355, 32768, 8764, 113, 117, 97, 108, 59, 32768, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8773, 105, 108, 100, 101, 59, 32768, 8776, 112, 102, 59, 32896, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 32768, 8411, 512, 99, 116, 5383, 5388, 114, 59, 32896, 55349, 56495, 114, 111, 107, 59, 32768, 358, 5426, 5417, 5444, 5458, 5473, 0, 5480, 5485, 0, 0, 0, 0, 0, 5494, 5500, 5564, 5579, 0, 5726, 5732, 5738, 5745, 512, 99, 114, 5421, 5429, 117, 116, 101, 33024, 218, 59, 32768, 218, 114, 512, 59, 111, 5435, 5437, 32768, 8607, 99, 105, 114, 59, 32768, 10569, 114, 820, 5449, 0, 5453, 121, 59, 32768, 1038, 118, 101, 59, 32768, 364, 512, 105, 121, 5462, 5469, 114, 99, 33024, 219, 59, 32768, 219, 59, 32768, 1059, 98, 108, 97, 99, 59, 32768, 368, 114, 59, 32896, 55349, 56600, 114, 97, 118, 101, 33024, 217, 59, 32768, 217, 97, 99, 114, 59, 32768, 362, 512, 100, 105, 5504, 5548, 101, 114, 512, 66, 80, 5511, 5535, 512, 97, 114, 5516, 5520, 114, 59, 32768, 95, 97, 99, 512, 101, 107, 5527, 5530, 59, 32768, 9183, 101, 116, 59, 32768, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 32768, 9181, 111, 110, 512, 59, 80, 5555, 5557, 32768, 8899, 108, 117, 115, 59, 32768, 8846, 512, 103, 112, 5568, 5573, 111, 110, 59, 32768, 370, 102, 59, 32896, 55349, 56652, 2048, 65, 68, 69, 84, 97, 100, 112, 115, 5595, 5624, 5635, 5648, 5664, 5671, 5682, 5712, 114, 114, 111, 119, 768, 59, 66, 68, 5606, 5608, 5613, 32768, 8593, 97, 114, 59, 32768, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 10606, 101, 101, 512, 59, 65, 5655, 5657, 32768, 8869, 114, 114, 111, 119, 59, 32768, 8613, 114, 114, 111, 119, 59, 32768, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 32768, 8661, 101, 114, 512, 76, 82, 5689, 5700, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8599, 105, 512, 59, 108, 5718, 5720, 32768, 978, 111, 110, 59, 32768, 933, 105, 110, 103, 59, 32768, 366, 99, 114, 59, 32896, 55349, 56496, 105, 108, 100, 101, 59, 32768, 360, 109, 108, 33024, 220, 59, 32768, 220, 2304, 68, 98, 99, 100, 101, 102, 111, 115, 118, 5770, 5776, 5781, 5785, 5798, 5878, 5883, 5889, 5895, 97, 115, 104, 59, 32768, 8875, 97, 114, 59, 32768, 10987, 121, 59, 32768, 1042, 97, 115, 104, 512, 59, 108, 5793, 5795, 32768, 8873, 59, 32768, 10982, 512, 101, 114, 5803, 5806, 59, 32768, 8897, 768, 98, 116, 121, 5813, 5818, 5866, 97, 114, 59, 32768, 8214, 512, 59, 105, 5823, 5825, 32768, 8214, 99, 97, 108, 1024, 66, 76, 83, 84, 5837, 5842, 5848, 5859, 97, 114, 59, 32768, 8739, 105, 110, 101, 59, 32768, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 32768, 10072, 105, 108, 100, 101, 59, 32768, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 32768, 8202, 114, 59, 32896, 55349, 56601, 112, 102, 59, 32896, 55349, 56653, 99, 114, 59, 32896, 55349, 56497, 100, 97, 115, 104, 59, 32768, 8874, 1280, 99, 101, 102, 111, 115, 5913, 5919, 5925, 5930, 5936, 105, 114, 99, 59, 32768, 372, 100, 103, 101, 59, 32768, 8896, 114, 59, 32896, 55349, 56602, 112, 102, 59, 32896, 55349, 56654, 99, 114, 59, 32896, 55349, 56498, 1024, 102, 105, 111, 115, 5951, 5956, 5959, 5965, 114, 59, 32896, 55349, 56603, 59, 32768, 926, 112, 102, 59, 32896, 55349, 56655, 99, 114, 59, 32896, 55349, 56499, 2304, 65, 73, 85, 97, 99, 102, 111, 115, 117, 5990, 5995, 6000, 6005, 6014, 6027, 6032, 6038, 6044, 99, 121, 59, 32768, 1071, 99, 121, 59, 32768, 1031, 99, 121, 59, 32768, 1070, 99, 117, 116, 101, 33024, 221, 59, 32768, 221, 512, 105, 121, 6019, 6024, 114, 99, 59, 32768, 374, 59, 32768, 1067, 114, 59, 32896, 55349, 56604, 112, 102, 59, 32896, 55349, 56656, 99, 114, 59, 32896, 55349, 56500, 109, 108, 59, 32768, 376, 2048, 72, 97, 99, 100, 101, 102, 111, 115, 6066, 6071, 6078, 6092, 6097, 6119, 6123, 6128, 99, 121, 59, 32768, 1046, 99, 117, 116, 101, 59, 32768, 377, 512, 97, 121, 6083, 6089, 114, 111, 110, 59, 32768, 381, 59, 32768, 1047, 111, 116, 59, 32768, 379, 835, 6102, 0, 6116, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 32768, 8203, 97, 59, 32768, 918, 114, 59, 32768, 8488, 112, 102, 59, 32768, 8484, 99, 114, 59, 32896, 55349, 56501, 5938, 6159, 6168, 6175, 0, 6214, 6222, 6233, 0, 0, 0, 0, 6242, 6267, 6290, 6429, 6444, 0, 6495, 6503, 6531, 6540, 0, 6547, 99, 117, 116, 101, 33024, 225, 59, 32768, 225, 114, 101, 118, 101, 59, 32768, 259, 1536, 59, 69, 100, 105, 117, 121, 6187, 6189, 6193, 6196, 6203, 6210, 32768, 8766, 59, 32896, 8766, 819, 59, 32768, 8767, 114, 99, 33024, 226, 59, 32768, 226, 116, 101, 33024, 180, 59, 32768, 180, 59, 32768, 1072, 108, 105, 103, 33024, 230, 59, 32768, 230, 512, 59, 114, 6226, 6228, 32768, 8289, 59, 32896, 55349, 56606, 114, 97, 118, 101, 33024, 224, 59, 32768, 224, 512, 101, 112, 6246, 6261, 512, 102, 112, 6251, 6257, 115, 121, 109, 59, 32768, 8501, 104, 59, 32768, 8501, 104, 97, 59, 32768, 945, 512, 97, 112, 6271, 6284, 512, 99, 108, 6276, 6280, 114, 59, 32768, 257, 103, 59, 32768, 10815, 33024, 38, 59, 32768, 38, 1077, 6295, 0, 0, 6326, 1280, 59, 97, 100, 115, 118, 6305, 6307, 6312, 6315, 6322, 32768, 8743, 110, 100, 59, 32768, 10837, 59, 32768, 10844, 108, 111, 112, 101, 59, 32768, 10840, 59, 32768, 10842, 1792, 59, 101, 108, 109, 114, 115, 122, 6340, 6342, 6345, 6349, 6391, 6410, 6422, 32768, 8736, 59, 32768, 10660, 101, 59, 32768, 8736, 115, 100, 512, 59, 97, 6356, 6358, 32768, 8737, 2098, 6368, 6371, 6374, 6377, 6380, 6383, 6386, 6389, 59, 32768, 10664, 59, 32768, 10665, 59, 32768, 10666, 59, 32768, 10667, 59, 32768, 10668, 59, 32768, 10669, 59, 32768, 10670, 59, 32768, 10671, 116, 512, 59, 118, 6397, 6399, 32768, 8735, 98, 512, 59, 100, 6405, 6407, 32768, 8894, 59, 32768, 10653, 512, 112, 116, 6415, 6419, 104, 59, 32768, 8738, 59, 32768, 197, 97, 114, 114, 59, 32768, 9084, 512, 103, 112, 6433, 6438, 111, 110, 59, 32768, 261, 102, 59, 32896, 55349, 56658, 1792, 59, 69, 97, 101, 105, 111, 112, 6458, 6460, 6463, 6469, 6472, 6476, 6480, 32768, 8776, 59, 32768, 10864, 99, 105, 114, 59, 32768, 10863, 59, 32768, 8778, 100, 59, 32768, 8779, 115, 59, 32768, 39, 114, 111, 120, 512, 59, 101, 6488, 6490, 32768, 8776, 113, 59, 32768, 8778, 105, 110, 103, 33024, 229, 59, 32768, 229, 768, 99, 116, 121, 6509, 6514, 6517, 114, 59, 32896, 55349, 56502, 59, 32768, 42, 109, 112, 512, 59, 101, 6524, 6526, 32768, 8776, 113, 59, 32768, 8781, 105, 108, 100, 101, 33024, 227, 59, 32768, 227, 109, 108, 33024, 228, 59, 32768, 228, 512, 99, 105, 6551, 6559, 111, 110, 105, 110, 116, 59, 32768, 8755, 110, 116, 59, 32768, 10769, 4096, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 6597, 6602, 6673, 6688, 6701, 6707, 6768, 6773, 6891, 6898, 6999, 7023, 7309, 7316, 7334, 7383, 111, 116, 59, 32768, 10989, 512, 99, 114, 6607, 6652, 107, 1024, 99, 101, 112, 115, 6617, 6623, 6632, 6639, 111, 110, 103, 59, 32768, 8780, 112, 115, 105, 108, 111, 110, 59, 32768, 1014, 114, 105, 109, 101, 59, 32768, 8245, 105, 109, 512, 59, 101, 6646, 6648, 32768, 8765, 113, 59, 32768, 8909, 583, 6656, 6661, 101, 101, 59, 32768, 8893, 101, 100, 512, 59, 103, 6667, 6669, 32768, 8965, 101, 59, 32768, 8965, 114, 107, 512, 59, 116, 6680, 6682, 32768, 9141, 98, 114, 107, 59, 32768, 9142, 512, 111, 121, 6693, 6698, 110, 103, 59, 32768, 8780, 59, 32768, 1073, 113, 117, 111, 59, 32768, 8222, 1280, 99, 109, 112, 114, 116, 6718, 6731, 6738, 6743, 6749, 97, 117, 115, 512, 59, 101, 6726, 6728, 32768, 8757, 59, 32768, 8757, 112, 116, 121, 118, 59, 32768, 10672, 115, 105, 59, 32768, 1014, 110, 111, 117, 59, 32768, 8492, 768, 97, 104, 119, 6756, 6759, 6762, 59, 32768, 946, 59, 32768, 8502, 101, 101, 110, 59, 32768, 8812, 114, 59, 32896, 55349, 56607, 103, 1792, 99, 111, 115, 116, 117, 118, 119, 6789, 6809, 6834, 6850, 6872, 6879, 6884, 768, 97, 105, 117, 6796, 6800, 6805, 112, 59, 32768, 8898, 114, 99, 59, 32768, 9711, 112, 59, 32768, 8899, 768, 100, 112, 116, 6816, 6821, 6827, 111, 116, 59, 32768, 10752, 108, 117, 115, 59, 32768, 10753, 105, 109, 101, 115, 59, 32768, 10754, 1090, 6840, 0, 0, 6846, 99, 117, 112, 59, 32768, 10758, 97, 114, 59, 32768, 9733, 114, 105, 97, 110, 103, 108, 101, 512, 100, 117, 6862, 6868, 111, 119, 110, 59, 32768, 9661, 112, 59, 32768, 9651, 112, 108, 117, 115, 59, 32768, 10756, 101, 101, 59, 32768, 8897, 101, 100, 103, 101, 59, 32768, 8896, 97, 114, 111, 119, 59, 32768, 10509, 768, 97, 107, 111, 6905, 6976, 6994, 512, 99, 110, 6910, 6972, 107, 768, 108, 115, 116, 6918, 6927, 6935, 111, 122, 101, 110, 103, 101, 59, 32768, 10731, 113, 117, 97, 114, 101, 59, 32768, 9642, 114, 105, 97, 110, 103, 108, 101, 1024, 59, 100, 108, 114, 6951, 6953, 6959, 6965, 32768, 9652, 111, 119, 110, 59, 32768, 9662, 101, 102, 116, 59, 32768, 9666, 105, 103, 104, 116, 59, 32768, 9656, 107, 59, 32768, 9251, 770, 6981, 0, 6991, 771, 6985, 0, 6988, 59, 32768, 9618, 59, 32768, 9617, 52, 59, 32768, 9619, 99, 107, 59, 32768, 9608, 512, 101, 111, 7004, 7019, 512, 59, 113, 7009, 7012, 32896, 61, 8421, 117, 105, 118, 59, 32896, 8801, 8421, 116, 59, 32768, 8976, 1024, 112, 116, 119, 120, 7032, 7037, 7049, 7055, 102, 59, 32896, 55349, 56659, 512, 59, 116, 7042, 7044, 32768, 8869, 111, 109, 59, 32768, 8869, 116, 105, 101, 59, 32768, 8904, 3072, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7080, 7101, 7126, 7147, 7182, 7187, 7208, 7233, 7240, 7246, 7253, 7274, 1024, 76, 82, 108, 114, 7089, 7092, 7095, 7098, 59, 32768, 9559, 59, 32768, 9556, 59, 32768, 9558, 59, 32768, 9555, 1280, 59, 68, 85, 100, 117, 7112, 7114, 7117, 7120, 7123, 32768, 9552, 59, 32768, 9574, 59, 32768, 9577, 59, 32768, 9572, 59, 32768, 9575, 1024, 76, 82, 108, 114, 7135, 7138, 7141, 7144, 59, 32768, 9565, 59, 32768, 9562, 59, 32768, 9564, 59, 32768, 9561, 1792, 59, 72, 76, 82, 104, 108, 114, 7162, 7164, 7167, 7170, 7173, 7176, 7179, 32768, 9553, 59, 32768, 9580, 59, 32768, 9571, 59, 32768, 9568, 59, 32768, 9579, 59, 32768, 9570, 59, 32768, 9567, 111, 120, 59, 32768, 10697, 1024, 76, 82, 108, 114, 7196, 7199, 7202, 7205, 59, 32768, 9557, 59, 32768, 9554, 59, 32768, 9488, 59, 32768, 9484, 1280, 59, 68, 85, 100, 117, 7219, 7221, 7224, 7227, 7230, 32768, 9472, 59, 32768, 9573, 59, 32768, 9576, 59, 32768, 9516, 59, 32768, 9524, 105, 110, 117, 115, 59, 32768, 8863, 108, 117, 115, 59, 32768, 8862, 105, 109, 101, 115, 59, 32768, 8864, 1024, 76, 82, 108, 114, 7262, 7265, 7268, 7271, 59, 32768, 9563, 59, 32768, 9560, 59, 32768, 9496, 59, 32768, 9492, 1792, 59, 72, 76, 82, 104, 108, 114, 7289, 7291, 7294, 7297, 7300, 7303, 7306, 32768, 9474, 59, 32768, 9578, 59, 32768, 9569, 59, 32768, 9566, 59, 32768, 9532, 59, 32768, 9508, 59, 32768, 9500, 114, 105, 109, 101, 59, 32768, 8245, 512, 101, 118, 7321, 7326, 118, 101, 59, 32768, 728, 98, 97, 114, 33024, 166, 59, 32768, 166, 1024, 99, 101, 105, 111, 7343, 7348, 7353, 7364, 114, 59, 32896, 55349, 56503, 109, 105, 59, 32768, 8271, 109, 512, 59, 101, 7359, 7361, 32768, 8765, 59, 32768, 8909, 108, 768, 59, 98, 104, 7372, 7374, 7377, 32768, 92, 59, 32768, 10693, 115, 117, 98, 59, 32768, 10184, 573, 7387, 7399, 108, 512, 59, 101, 7392, 7394, 32768, 8226, 116, 59, 32768, 8226, 112, 768, 59, 69, 101, 7406, 7408, 7411, 32768, 8782, 59, 32768, 10926, 512, 59, 113, 7416, 7418, 32768, 8783, 59, 32768, 8783, 6450, 7448, 0, 7523, 7571, 7576, 7613, 0, 7618, 7647, 0, 0, 7764, 0, 0, 7779, 0, 0, 7899, 7914, 7949, 7955, 0, 8158, 0, 8176, 768, 99, 112, 114, 7454, 7460, 7509, 117, 116, 101, 59, 32768, 263, 1536, 59, 97, 98, 99, 100, 115, 7473, 7475, 7480, 7487, 7500, 7505, 32768, 8745, 110, 100, 59, 32768, 10820, 114, 99, 117, 112, 59, 32768, 10825, 512, 97, 117, 7492, 7496, 112, 59, 32768, 10827, 112, 59, 32768, 10823, 111, 116, 59, 32768, 10816, 59, 32896, 8745, 65024, 512, 101, 111, 7514, 7518, 116, 59, 32768, 8257, 110, 59, 32768, 711, 1024, 97, 101, 105, 117, 7531, 7544, 7552, 7557, 833, 7536, 0, 7540, 115, 59, 32768, 10829, 111, 110, 59, 32768, 269, 100, 105, 108, 33024, 231, 59, 32768, 231, 114, 99, 59, 32768, 265, 112, 115, 512, 59, 115, 7564, 7566, 32768, 10828, 109, 59, 32768, 10832, 111, 116, 59, 32768, 267, 768, 100, 109, 110, 7582, 7589, 7596, 105, 108, 33024, 184, 59, 32768, 184, 112, 116, 121, 118, 59, 32768, 10674, 116, 33280, 162, 59, 101, 7603, 7605, 32768, 162, 114, 100, 111, 116, 59, 32768, 183, 114, 59, 32896, 55349, 56608, 768, 99, 101, 105, 7624, 7628, 7643, 121, 59, 32768, 1095, 99, 107, 512, 59, 109, 7635, 7637, 32768, 10003, 97, 114, 107, 59, 32768, 10003, 59, 32768, 967, 114, 1792, 59, 69, 99, 101, 102, 109, 115, 7662, 7664, 7667, 7742, 7745, 7752, 7757, 32768, 9675, 59, 32768, 10691, 768, 59, 101, 108, 7674, 7676, 7680, 32768, 710, 113, 59, 32768, 8791, 101, 1074, 7687, 0, 0, 7709, 114, 114, 111, 119, 512, 108, 114, 7695, 7701, 101, 102, 116, 59, 32768, 8634, 105, 103, 104, 116, 59, 32768, 8635, 1280, 82, 83, 97, 99, 100, 7719, 7722, 7725, 7730, 7736, 59, 32768, 174, 59, 32768, 9416, 115, 116, 59, 32768, 8859, 105, 114, 99, 59, 32768, 8858, 97, 115, 104, 59, 32768, 8861, 59, 32768, 8791, 110, 105, 110, 116, 59, 32768, 10768, 105, 100, 59, 32768, 10991, 99, 105, 114, 59, 32768, 10690, 117, 98, 115, 512, 59, 117, 7771, 7773, 32768, 9827, 105, 116, 59, 32768, 9827, 1341, 7785, 7804, 7850, 0, 7871, 111, 110, 512, 59, 101, 7791, 7793, 32768, 58, 512, 59, 113, 7798, 7800, 32768, 8788, 59, 32768, 8788, 1086, 7809, 0, 0, 7820, 97, 512, 59, 116, 7814, 7816, 32768, 44, 59, 32768, 64, 768, 59, 102, 108, 7826, 7828, 7832, 32768, 8705, 110, 59, 32768, 8728, 101, 512, 109, 120, 7838, 7844, 101, 110, 116, 59, 32768, 8705, 101, 115, 59, 32768, 8450, 824, 7854, 0, 7866, 512, 59, 100, 7858, 7860, 32768, 8773, 111, 116, 59, 32768, 10861, 110, 116, 59, 32768, 8750, 768, 102, 114, 121, 7877, 7881, 7886, 59, 32896, 55349, 56660, 111, 100, 59, 32768, 8720, 33280, 169, 59, 115, 7892, 7894, 32768, 169, 114, 59, 32768, 8471, 512, 97, 111, 7903, 7908, 114, 114, 59, 32768, 8629, 115, 115, 59, 32768, 10007, 512, 99, 117, 7918, 7923, 114, 59, 32896, 55349, 56504, 512, 98, 112, 7928, 7938, 512, 59, 101, 7933, 7935, 32768, 10959, 59, 32768, 10961, 512, 59, 101, 7943, 7945, 32768, 10960, 59, 32768, 10962, 100, 111, 116, 59, 32768, 8943, 1792, 100, 101, 108, 112, 114, 118, 119, 7969, 7983, 7996, 8009, 8057, 8147, 8152, 97, 114, 114, 512, 108, 114, 7977, 7980, 59, 32768, 10552, 59, 32768, 10549, 1089, 7989, 0, 0, 7993, 114, 59, 32768, 8926, 99, 59, 32768, 8927, 97, 114, 114, 512, 59, 112, 8004, 8006, 32768, 8630, 59, 32768, 10557, 1536, 59, 98, 99, 100, 111, 115, 8022, 8024, 8031, 8044, 8049, 8053, 32768, 8746, 114, 99, 97, 112, 59, 32768, 10824, 512, 97, 117, 8036, 8040, 112, 59, 32768, 10822, 112, 59, 32768, 10826, 111, 116, 59, 32768, 8845, 114, 59, 32768, 10821, 59, 32896, 8746, 65024, 1024, 97, 108, 114, 118, 8066, 8078, 8116, 8123, 114, 114, 512, 59, 109, 8073, 8075, 32768, 8631, 59, 32768, 10556, 121, 768, 101, 118, 119, 8086, 8104, 8109, 113, 1089, 8093, 0, 0, 8099, 114, 101, 99, 59, 32768, 8926, 117, 99, 99, 59, 32768, 8927, 101, 101, 59, 32768, 8910, 101, 100, 103, 101, 59, 32768, 8911, 101, 110, 33024, 164, 59, 32768, 164, 101, 97, 114, 114, 111, 119, 512, 108, 114, 8134, 8140, 101, 102, 116, 59, 32768, 8630, 105, 103, 104, 116, 59, 32768, 8631, 101, 101, 59, 32768, 8910, 101, 100, 59, 32768, 8911, 512, 99, 105, 8162, 8170, 111, 110, 105, 110, 116, 59, 32768, 8754, 110, 116, 59, 32768, 8753, 108, 99, 116, 121, 59, 32768, 9005, 4864, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8221, 8226, 8231, 8267, 8282, 8296, 8327, 8351, 8366, 8379, 8466, 8471, 8487, 8621, 8647, 8676, 8697, 8712, 8720, 114, 114, 59, 32768, 8659, 97, 114, 59, 32768, 10597, 1024, 103, 108, 114, 115, 8240, 8246, 8252, 8256, 103, 101, 114, 59, 32768, 8224, 101, 116, 104, 59, 32768, 8504, 114, 59, 32768, 8595, 104, 512, 59, 118, 8262, 8264, 32768, 8208, 59, 32768, 8867, 572, 8271, 8278, 97, 114, 111, 119, 59, 32768, 10511, 97, 99, 59, 32768, 733, 512, 97, 121, 8287, 8293, 114, 111, 110, 59, 32768, 271, 59, 32768, 1076, 768, 59, 97, 111, 8303, 8305, 8320, 32768, 8518, 512, 103, 114, 8310, 8316, 103, 101, 114, 59, 32768, 8225, 114, 59, 32768, 8650, 116, 115, 101, 113, 59, 32768, 10871, 768, 103, 108, 109, 8334, 8339, 8344, 33024, 176, 59, 32768, 176, 116, 97, 59, 32768, 948, 112, 116, 121, 118, 59, 32768, 10673, 512, 105, 114, 8356, 8362, 115, 104, 116, 59, 32768, 10623, 59, 32896, 55349, 56609, 97, 114, 512, 108, 114, 8373, 8376, 59, 32768, 8643, 59, 32768, 8642, 1280, 97, 101, 103, 115, 118, 8390, 8418, 8421, 8428, 8433, 109, 768, 59, 111, 115, 8398, 8400, 8415, 32768, 8900, 110, 100, 512, 59, 115, 8407, 8409, 32768, 8900, 117, 105, 116, 59, 32768, 9830, 59, 32768, 9830, 59, 32768, 168, 97, 109, 109, 97, 59, 32768, 989, 105, 110, 59, 32768, 8946, 768, 59, 105, 111, 8440, 8442, 8461, 32768, 247, 100, 101, 33280, 247, 59, 111, 8450, 8452, 32768, 247, 110, 116, 105, 109, 101, 115, 59, 32768, 8903, 110, 120, 59, 32768, 8903, 99, 121, 59, 32768, 1106, 99, 1088, 8478, 0, 0, 8483, 114, 110, 59, 32768, 8990, 111, 112, 59, 32768, 8973, 1280, 108, 112, 116, 117, 119, 8498, 8504, 8509, 8556, 8570, 108, 97, 114, 59, 32768, 36, 102, 59, 32896, 55349, 56661, 1280, 59, 101, 109, 112, 115, 8520, 8522, 8535, 8542, 8548, 32768, 729, 113, 512, 59, 100, 8528, 8530, 32768, 8784, 111, 116, 59, 32768, 8785, 105, 110, 117, 115, 59, 32768, 8760, 108, 117, 115, 59, 32768, 8724, 113, 117, 97, 114, 101, 59, 32768, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 32768, 8966, 110, 768, 97, 100, 104, 8578, 8585, 8597, 114, 114, 111, 119, 59, 32768, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 32768, 8650, 97, 114, 112, 111, 111, 110, 512, 108, 114, 8608, 8614, 101, 102, 116, 59, 32768, 8643, 105, 103, 104, 116, 59, 32768, 8642, 563, 8625, 8633, 107, 97, 114, 111, 119, 59, 32768, 10512, 1088, 8638, 0, 0, 8643, 114, 110, 59, 32768, 8991, 111, 112, 59, 32768, 8972, 768, 99, 111, 116, 8654, 8666, 8670, 512, 114, 121, 8659, 8663, 59, 32896, 55349, 56505, 59, 32768, 1109, 108, 59, 32768, 10742, 114, 111, 107, 59, 32768, 273, 512, 100, 114, 8681, 8686, 111, 116, 59, 32768, 8945, 105, 512, 59, 102, 8692, 8694, 32768, 9663, 59, 32768, 9662, 512, 97, 104, 8702, 8707, 114, 114, 59, 32768, 8693, 97, 114, 59, 32768, 10607, 97, 110, 103, 108, 101, 59, 32768, 10662, 512, 99, 105, 8725, 8729, 121, 59, 32768, 1119, 103, 114, 97, 114, 114, 59, 32768, 10239, 4608, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 8774, 8788, 8807, 8844, 8849, 8852, 8866, 8895, 8929, 8977, 8989, 9004, 9046, 9136, 9151, 9171, 9184, 9199, 512, 68, 111, 8779, 8784, 111, 116, 59, 32768, 10871, 116, 59, 32768, 8785, 512, 99, 115, 8793, 8801, 117, 116, 101, 33024, 233, 59, 32768, 233, 116, 101, 114, 59, 32768, 10862, 1024, 97, 105, 111, 121, 8816, 8822, 8835, 8841, 114, 111, 110, 59, 32768, 283, 114, 512, 59, 99, 8828, 8830, 32768, 8790, 33024, 234, 59, 32768, 234, 108, 111, 110, 59, 32768, 8789, 59, 32768, 1101, 111, 116, 59, 32768, 279, 59, 32768, 8519, 512, 68, 114, 8857, 8862, 111, 116, 59, 32768, 8786, 59, 32896, 55349, 56610, 768, 59, 114, 115, 8873, 8875, 8883, 32768, 10906, 97, 118, 101, 33024, 232, 59, 32768, 232, 512, 59, 100, 8888, 8890, 32768, 10902, 111, 116, 59, 32768, 10904, 1024, 59, 105, 108, 115, 8904, 8906, 8914, 8917, 32768, 10905, 110, 116, 101, 114, 115, 59, 32768, 9191, 59, 32768, 8467, 512, 59, 100, 8922, 8924, 32768, 10901, 111, 116, 59, 32768, 10903, 768, 97, 112, 115, 8936, 8941, 8960, 99, 114, 59, 32768, 275, 116, 121, 768, 59, 115, 118, 8950, 8952, 8957, 32768, 8709, 101, 116, 59, 32768, 8709, 59, 32768, 8709, 112, 512, 49, 59, 8966, 8975, 516, 8970, 8973, 59, 32768, 8196, 59, 32768, 8197, 32768, 8195, 512, 103, 115, 8982, 8985, 59, 32768, 331, 112, 59, 32768, 8194, 512, 103, 112, 8994, 8999, 111, 110, 59, 32768, 281, 102, 59, 32896, 55349, 56662, 768, 97, 108, 115, 9011, 9023, 9028, 114, 512, 59, 115, 9017, 9019, 32768, 8917, 108, 59, 32768, 10723, 117, 115, 59, 32768, 10865, 105, 768, 59, 108, 118, 9036, 9038, 9043, 32768, 949, 111, 110, 59, 32768, 949, 59, 32768, 1013, 1024, 99, 115, 117, 118, 9055, 9071, 9099, 9128, 512, 105, 111, 9060, 9065, 114, 99, 59, 32768, 8790, 108, 111, 110, 59, 32768, 8789, 1082, 9077, 0, 0, 9081, 109, 59, 32768, 8770, 97, 110, 116, 512, 103, 108, 9088, 9093, 116, 114, 59, 32768, 10902, 101, 115, 115, 59, 32768, 10901, 768, 97, 101, 105, 9106, 9111, 9116, 108, 115, 59, 32768, 61, 115, 116, 59, 32768, 8799, 118, 512, 59, 68, 9122, 9124, 32768, 8801, 68, 59, 32768, 10872, 112, 97, 114, 115, 108, 59, 32768, 10725, 512, 68, 97, 9141, 9146, 111, 116, 59, 32768, 8787, 114, 114, 59, 32768, 10609, 768, 99, 100, 105, 9158, 9162, 9167, 114, 59, 32768, 8495, 111, 116, 59, 32768, 8784, 109, 59, 32768, 8770, 512, 97, 104, 9176, 9179, 59, 32768, 951, 33024, 240, 59, 32768, 240, 512, 109, 114, 9189, 9195, 108, 33024, 235, 59, 32768, 235, 111, 59, 32768, 8364, 768, 99, 105, 112, 9206, 9210, 9215, 108, 59, 32768, 33, 115, 116, 59, 32768, 8707, 512, 101, 111, 9220, 9230, 99, 116, 97, 116, 105, 111, 110, 59, 32768, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 32768, 8519, 4914, 9262, 0, 9276, 0, 9280, 9287, 0, 0, 9318, 9324, 0, 9331, 0, 9352, 9357, 9386, 0, 9395, 9497, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 32768, 8786, 121, 59, 32768, 1092, 109, 97, 108, 101, 59, 32768, 9792, 768, 105, 108, 114, 9293, 9299, 9313, 108, 105, 103, 59, 32768, 64259, 1082, 9305, 0, 0, 9309, 103, 59, 32768, 64256, 105, 103, 59, 32768, 64260, 59, 32896, 55349, 56611, 108, 105, 103, 59, 32768, 64257, 108, 105, 103, 59, 32896, 102, 106, 768, 97, 108, 116, 9337, 9341, 9346, 116, 59, 32768, 9837, 105, 103, 59, 32768, 64258, 110, 115, 59, 32768, 9649, 111, 102, 59, 32768, 402, 833, 9361, 0, 9366, 102, 59, 32896, 55349, 56663, 512, 97, 107, 9370, 9375, 108, 108, 59, 32768, 8704, 512, 59, 118, 9380, 9382, 32768, 8916, 59, 32768, 10969, 97, 114, 116, 105, 110, 116, 59, 32768, 10765, 512, 97, 111, 9399, 9491, 512, 99, 115, 9404, 9487, 1794, 9413, 9443, 9453, 9470, 9474, 0, 9484, 1795, 9421, 9426, 9429, 9434, 9437, 0, 9440, 33024, 189, 59, 32768, 189, 59, 32768, 8531, 33024, 188, 59, 32768, 188, 59, 32768, 8533, 59, 32768, 8537, 59, 32768, 8539, 772, 9447, 0, 9450, 59, 32768, 8532, 59, 32768, 8534, 1285, 9459, 9464, 0, 0, 9467, 33024, 190, 59, 32768, 190, 59, 32768, 8535, 59, 32768, 8540, 53, 59, 32768, 8536, 775, 9478, 0, 9481, 59, 32768, 8538, 59, 32768, 8541, 56, 59, 32768, 8542, 108, 59, 32768, 8260, 119, 110, 59, 32768, 8994, 99, 114, 59, 32896, 55349, 56507, 4352, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 9537, 9547, 9575, 9582, 9595, 9600, 9679, 9684, 9694, 9700, 9705, 9725, 9773, 9779, 9785, 9810, 9917, 512, 59, 108, 9542, 9544, 32768, 8807, 59, 32768, 10892, 768, 99, 109, 112, 9554, 9560, 9572, 117, 116, 101, 59, 32768, 501, 109, 97, 512, 59, 100, 9567, 9569, 32768, 947, 59, 32768, 989, 59, 32768, 10886, 114, 101, 118, 101, 59, 32768, 287, 512, 105, 121, 9587, 9592, 114, 99, 59, 32768, 285, 59, 32768, 1075, 111, 116, 59, 32768, 289, 1024, 59, 108, 113, 115, 9609, 9611, 9614, 9633, 32768, 8805, 59, 32768, 8923, 768, 59, 113, 115, 9621, 9623, 9626, 32768, 8805, 59, 32768, 8807, 108, 97, 110, 116, 59, 32768, 10878, 1024, 59, 99, 100, 108, 9642, 9644, 9648, 9667, 32768, 10878, 99, 59, 32768, 10921, 111, 116, 512, 59, 111, 9655, 9657, 32768, 10880, 512, 59, 108, 9662, 9664, 32768, 10882, 59, 32768, 10884, 512, 59, 101, 9672, 9675, 32896, 8923, 65024, 115, 59, 32768, 10900, 114, 59, 32896, 55349, 56612, 512, 59, 103, 9689, 9691, 32768, 8811, 59, 32768, 8921, 109, 101, 108, 59, 32768, 8503, 99, 121, 59, 32768, 1107, 1024, 59, 69, 97, 106, 9714, 9716, 9719, 9722, 32768, 8823, 59, 32768, 10898, 59, 32768, 10917, 59, 32768, 10916, 1024, 69, 97, 101, 115, 9734, 9737, 9751, 9768, 59, 32768, 8809, 112, 512, 59, 112, 9743, 9745, 32768, 10890, 114, 111, 120, 59, 32768, 10890, 512, 59, 113, 9756, 9758, 32768, 10888, 512, 59, 113, 9763, 9765, 32768, 10888, 59, 32768, 8809, 105, 109, 59, 32768, 8935, 112, 102, 59, 32896, 55349, 56664, 97, 118, 101, 59, 32768, 96, 512, 99, 105, 9790, 9794, 114, 59, 32768, 8458, 109, 768, 59, 101, 108, 9802, 9804, 9807, 32768, 8819, 59, 32768, 10894, 59, 32768, 10896, 34304, 62, 59, 99, 100, 108, 113, 114, 9824, 9826, 9838, 9843, 9849, 9856, 32768, 62, 512, 99, 105, 9831, 9834, 59, 32768, 10919, 114, 59, 32768, 10874, 111, 116, 59, 32768, 8919, 80, 97, 114, 59, 32768, 10645, 117, 101, 115, 116, 59, 32768, 10876, 1280, 97, 100, 101, 108, 115, 9867, 9882, 9887, 9906, 9912, 833, 9872, 0, 9879, 112, 114, 111, 120, 59, 32768, 10886, 114, 59, 32768, 10616, 111, 116, 59, 32768, 8919, 113, 512, 108, 113, 9893, 9899, 101, 115, 115, 59, 32768, 8923, 108, 101, 115, 115, 59, 32768, 10892, 101, 115, 115, 59, 32768, 8823, 105, 109, 59, 32768, 8819, 512, 101, 110, 9922, 9932, 114, 116, 110, 101, 113, 113, 59, 32896, 8809, 65024, 69, 59, 32896, 8809, 65024, 2560, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 9958, 9963, 10015, 10020, 10026, 10060, 10065, 10085, 10147, 10171, 114, 114, 59, 32768, 8660, 1024, 105, 108, 109, 114, 9972, 9978, 9982, 9988, 114, 115, 112, 59, 32768, 8202, 102, 59, 32768, 189, 105, 108, 116, 59, 32768, 8459, 512, 100, 114, 9993, 9998, 99, 121, 59, 32768, 1098, 768, 59, 99, 119, 10005, 10007, 10012, 32768, 8596, 105, 114, 59, 32768, 10568, 59, 32768, 8621, 97, 114, 59, 32768, 8463, 105, 114, 99, 59, 32768, 293, 768, 97, 108, 114, 10033, 10048, 10054, 114, 116, 115, 512, 59, 117, 10041, 10043, 32768, 9829, 105, 116, 59, 32768, 9829, 108, 105, 112, 59, 32768, 8230, 99, 111, 110, 59, 32768, 8889, 114, 59, 32896, 55349, 56613, 115, 512, 101, 119, 10071, 10078, 97, 114, 111, 119, 59, 32768, 10533, 97, 114, 111, 119, 59, 32768, 10534, 1280, 97, 109, 111, 112, 114, 10096, 10101, 10107, 10136, 10141, 114, 114, 59, 32768, 8703, 116, 104, 116, 59, 32768, 8763, 107, 512, 108, 114, 10113, 10124, 101, 102, 116, 97, 114, 114, 111, 119, 59, 32768, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8618, 102, 59, 32896, 55349, 56665, 98, 97, 114, 59, 32768, 8213, 768, 99, 108, 116, 10154, 10159, 10165, 114, 59, 32896, 55349, 56509, 97, 115, 104, 59, 32768, 8463, 114, 111, 107, 59, 32768, 295, 512, 98, 112, 10176, 10182, 117, 108, 108, 59, 32768, 8259, 104, 101, 110, 59, 32768, 8208, 5426, 10211, 0, 10220, 0, 10239, 10255, 10267, 0, 10276, 10312, 0, 0, 10318, 10371, 10458, 10485, 10491, 0, 10500, 10545, 10558, 99, 117, 116, 101, 33024, 237, 59, 32768, 237, 768, 59, 105, 121, 10226, 10228, 10235, 32768, 8291, 114, 99, 33024, 238, 59, 32768, 238, 59, 32768, 1080, 512, 99, 120, 10243, 10247, 121, 59, 32768, 1077, 99, 108, 33024, 161, 59, 32768, 161, 512, 102, 114, 10259, 10262, 59, 32768, 8660, 59, 32896, 55349, 56614, 114, 97, 118, 101, 33024, 236, 59, 32768, 236, 1024, 59, 105, 110, 111, 10284, 10286, 10300, 10306, 32768, 8520, 512, 105, 110, 10291, 10296, 110, 116, 59, 32768, 10764, 116, 59, 32768, 8749, 102, 105, 110, 59, 32768, 10716, 116, 97, 59, 32768, 8489, 108, 105, 103, 59, 32768, 307, 768, 97, 111, 112, 10324, 10361, 10365, 768, 99, 103, 116, 10331, 10335, 10357, 114, 59, 32768, 299, 768, 101, 108, 112, 10342, 10345, 10351, 59, 32768, 8465, 105, 110, 101, 59, 32768, 8464, 97, 114, 116, 59, 32768, 8465, 104, 59, 32768, 305, 102, 59, 32768, 8887, 101, 100, 59, 32768, 437, 1280, 59, 99, 102, 111, 116, 10381, 10383, 10389, 10403, 10409, 32768, 8712, 97, 114, 101, 59, 32768, 8453, 105, 110, 512, 59, 116, 10396, 10398, 32768, 8734, 105, 101, 59, 32768, 10717, 100, 111, 116, 59, 32768, 305, 1280, 59, 99, 101, 108, 112, 10420, 10422, 10427, 10444, 10451, 32768, 8747, 97, 108, 59, 32768, 8890, 512, 103, 114, 10432, 10438, 101, 114, 115, 59, 32768, 8484, 99, 97, 108, 59, 32768, 8890, 97, 114, 104, 107, 59, 32768, 10775, 114, 111, 100, 59, 32768, 10812, 1024, 99, 103, 112, 116, 10466, 10470, 10475, 10480, 121, 59, 32768, 1105, 111, 110, 59, 32768, 303, 102, 59, 32896, 55349, 56666, 97, 59, 32768, 953, 114, 111, 100, 59, 32768, 10812, 117, 101, 115, 116, 33024, 191, 59, 32768, 191, 512, 99, 105, 10504, 10509, 114, 59, 32896, 55349, 56510, 110, 1280, 59, 69, 100, 115, 118, 10521, 10523, 10526, 10531, 10541, 32768, 8712, 59, 32768, 8953, 111, 116, 59, 32768, 8949, 512, 59, 118, 10536, 10538, 32768, 8948, 59, 32768, 8947, 59, 32768, 8712, 512, 59, 105, 10549, 10551, 32768, 8290, 108, 100, 101, 59, 32768, 297, 828, 10562, 0, 10567, 99, 121, 59, 32768, 1110, 108, 33024, 239, 59, 32768, 239, 1536, 99, 102, 109, 111, 115, 117, 10585, 10598, 10603, 10609, 10615, 10630, 512, 105, 121, 10590, 10595, 114, 99, 59, 32768, 309, 59, 32768, 1081, 114, 59, 32896, 55349, 56615, 97, 116, 104, 59, 32768, 567, 112, 102, 59, 32896, 55349, 56667, 820, 10620, 0, 10625, 114, 59, 32896, 55349, 56511, 114, 99, 121, 59, 32768, 1112, 107, 99, 121, 59, 32768, 1108, 2048, 97, 99, 102, 103, 104, 106, 111, 115, 10653, 10666, 10680, 10685, 10692, 10697, 10702, 10708, 112, 112, 97, 512, 59, 118, 10661, 10663, 32768, 954, 59, 32768, 1008, 512, 101, 121, 10671, 10677, 100, 105, 108, 59, 32768, 311, 59, 32768, 1082, 114, 59, 32896, 55349, 56616, 114, 101, 101, 110, 59, 32768, 312, 99, 121, 59, 32768, 1093, 99, 121, 59, 32768, 1116, 112, 102, 59, 32896, 55349, 56668, 99, 114, 59, 32896, 55349, 56512, 5888, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 10761, 10783, 10789, 10799, 10804, 10957, 11011, 11047, 11094, 11349, 11372, 11382, 11409, 11414, 11451, 11478, 11526, 11698, 11711, 11755, 11823, 11910, 11929, 768, 97, 114, 116, 10768, 10773, 10777, 114, 114, 59, 32768, 8666, 114, 59, 32768, 8656, 97, 105, 108, 59, 32768, 10523, 97, 114, 114, 59, 32768, 10510, 512, 59, 103, 10794, 10796, 32768, 8806, 59, 32768, 10891, 97, 114, 59, 32768, 10594, 4660, 10824, 0, 10830, 0, 10838, 0, 0, 0, 0, 0, 10844, 10850, 0, 10867, 10870, 10877, 0, 10933, 117, 116, 101, 59, 32768, 314, 109, 112, 116, 121, 118, 59, 32768, 10676, 114, 97, 110, 59, 32768, 8466, 98, 100, 97, 59, 32768, 955, 103, 768, 59, 100, 108, 10857, 10859, 10862, 32768, 10216, 59, 32768, 10641, 101, 59, 32768, 10216, 59, 32768, 10885, 117, 111, 33024, 171, 59, 32768, 171, 114, 2048, 59, 98, 102, 104, 108, 112, 115, 116, 10894, 10896, 10907, 10911, 10915, 10919, 10923, 10928, 32768, 8592, 512, 59, 102, 10901, 10903, 32768, 8676, 115, 59, 32768, 10527, 115, 59, 32768, 10525, 107, 59, 32768, 8617, 112, 59, 32768, 8619, 108, 59, 32768, 10553, 105, 109, 59, 32768, 10611, 108, 59, 32768, 8610, 768, 59, 97, 101, 10939, 10941, 10946, 32768, 10923, 105, 108, 59, 32768, 10521, 512, 59, 115, 10951, 10953, 32768, 10925, 59, 32896, 10925, 65024, 768, 97, 98, 114, 10964, 10969, 10974, 114, 114, 59, 32768, 10508, 114, 107, 59, 32768, 10098, 512, 97, 107, 10979, 10991, 99, 512, 101, 107, 10985, 10988, 59, 32768, 123, 59, 32768, 91, 512, 101, 115, 10996, 10999, 59, 32768, 10635, 108, 512, 100, 117, 11005, 11008, 59, 32768, 10639, 59, 32768, 10637, 1024, 97, 101, 117, 121, 11020, 11026, 11040, 11044, 114, 111, 110, 59, 32768, 318, 512, 100, 105, 11031, 11036, 105, 108, 59, 32768, 316, 108, 59, 32768, 8968, 98, 59, 32768, 123, 59, 32768, 1083, 1024, 99, 113, 114, 115, 11056, 11060, 11072, 11090, 97, 59, 32768, 10550, 117, 111, 512, 59, 114, 11067, 11069, 32768, 8220, 59, 32768, 8222, 512, 100, 117, 11077, 11083, 104, 97, 114, 59, 32768, 10599, 115, 104, 97, 114, 59, 32768, 10571, 104, 59, 32768, 8626, 1280, 59, 102, 103, 113, 115, 11105, 11107, 11228, 11231, 11250, 32768, 8804, 116, 1280, 97, 104, 108, 114, 116, 11119, 11136, 11157, 11169, 11216, 114, 114, 111, 119, 512, 59, 116, 11128, 11130, 32768, 8592, 97, 105, 108, 59, 32768, 8610, 97, 114, 112, 111, 111, 110, 512, 100, 117, 11147, 11153, 111, 119, 110, 59, 32768, 8637, 112, 59, 32768, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 32768, 8647, 105, 103, 104, 116, 768, 97, 104, 115, 11180, 11194, 11204, 114, 114, 111, 119, 512, 59, 115, 11189, 11191, 32768, 8596, 59, 32768, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 32768, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 32768, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 32768, 8907, 59, 32768, 8922, 768, 59, 113, 115, 11238, 11240, 11243, 32768, 8804, 59, 32768, 8806, 108, 97, 110, 116, 59, 32768, 10877, 1280, 59, 99, 100, 103, 115, 11261, 11263, 11267, 11286, 11298, 32768, 10877, 99, 59, 32768, 10920, 111, 116, 512, 59, 111, 11274, 11276, 32768, 10879, 512, 59, 114, 11281, 11283, 32768, 10881, 59, 32768, 10883, 512, 59, 101, 11291, 11294, 32896, 8922, 65024, 115, 59, 32768, 10899, 1280, 97, 100, 101, 103, 115, 11309, 11317, 11322, 11339, 11344, 112, 112, 114, 111, 120, 59, 32768, 10885, 111, 116, 59, 32768, 8918, 113, 512, 103, 113, 11328, 11333, 116, 114, 59, 32768, 8922, 103, 116, 114, 59, 32768, 10891, 116, 114, 59, 32768, 8822, 105, 109, 59, 32768, 8818, 768, 105, 108, 114, 11356, 11362, 11368, 115, 104, 116, 59, 32768, 10620, 111, 111, 114, 59, 32768, 8970, 59, 32896, 55349, 56617, 512, 59, 69, 11377, 11379, 32768, 8822, 59, 32768, 10897, 562, 11386, 11405, 114, 512, 100, 117, 11391, 11394, 59, 32768, 8637, 512, 59, 108, 11399, 11401, 32768, 8636, 59, 32768, 10602, 108, 107, 59, 32768, 9604, 99, 121, 59, 32768, 1113, 1280, 59, 97, 99, 104, 116, 11425, 11427, 11432, 11440, 11446, 32768, 8810, 114, 114, 59, 32768, 8647, 111, 114, 110, 101, 114, 59, 32768, 8990, 97, 114, 100, 59, 32768, 10603, 114, 105, 59, 32768, 9722, 512, 105, 111, 11456, 11462, 100, 111, 116, 59, 32768, 320, 117, 115, 116, 512, 59, 97, 11470, 11472, 32768, 9136, 99, 104, 101, 59, 32768, 9136, 1024, 69, 97, 101, 115, 11487, 11490, 11504, 11521, 59, 32768, 8808, 112, 512, 59, 112, 11496, 11498, 32768, 10889, 114, 111, 120, 59, 32768, 10889, 512, 59, 113, 11509, 11511, 32768, 10887, 512, 59, 113, 11516, 11518, 32768, 10887, 59, 32768, 8808, 105, 109, 59, 32768, 8934, 2048, 97, 98, 110, 111, 112, 116, 119, 122, 11543, 11556, 11561, 11616, 11640, 11660, 11667, 11680, 512, 110, 114, 11548, 11552, 103, 59, 32768, 10220, 114, 59, 32768, 8701, 114, 107, 59, 32768, 10214, 103, 768, 108, 109, 114, 11569, 11596, 11604, 101, 102, 116, 512, 97, 114, 11577, 11584, 114, 114, 111, 119, 59, 32768, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10231, 97, 112, 115, 116, 111, 59, 32768, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10230, 112, 97, 114, 114, 111, 119, 512, 108, 114, 11627, 11633, 101, 102, 116, 59, 32768, 8619, 105, 103, 104, 116, 59, 32768, 8620, 768, 97, 102, 108, 11647, 11651, 11655, 114, 59, 32768, 10629, 59, 32896, 55349, 56669, 117, 115, 59, 32768, 10797, 105, 109, 101, 115, 59, 32768, 10804, 562, 11671, 11676, 115, 116, 59, 32768, 8727, 97, 114, 59, 32768, 95, 768, 59, 101, 102, 11687, 11689, 11695, 32768, 9674, 110, 103, 101, 59, 32768, 9674, 59, 32768, 10731, 97, 114, 512, 59, 108, 11705, 11707, 32768, 40, 116, 59, 32768, 10643, 1280, 97, 99, 104, 109, 116, 11722, 11727, 11735, 11747, 11750, 114, 114, 59, 32768, 8646, 111, 114, 110, 101, 114, 59, 32768, 8991, 97, 114, 512, 59, 100, 11742, 11744, 32768, 8651, 59, 32768, 10605, 59, 32768, 8206, 114, 105, 59, 32768, 8895, 1536, 97, 99, 104, 105, 113, 116, 11768, 11774, 11779, 11782, 11798, 11817, 113, 117, 111, 59, 32768, 8249, 114, 59, 32896, 55349, 56513, 59, 32768, 8624, 109, 768, 59, 101, 103, 11790, 11792, 11795, 32768, 8818, 59, 32768, 10893, 59, 32768, 10895, 512, 98, 117, 11803, 11806, 59, 32768, 91, 111, 512, 59, 114, 11812, 11814, 32768, 8216, 59, 32768, 8218, 114, 111, 107, 59, 32768, 322, 34816, 60, 59, 99, 100, 104, 105, 108, 113, 114, 11841, 11843, 11855, 11860, 11866, 11872, 11878, 11885, 32768, 60, 512, 99, 105, 11848, 11851, 59, 32768, 10918, 114, 59, 32768, 10873, 111, 116, 59, 32768, 8918, 114, 101, 101, 59, 32768, 8907, 109, 101, 115, 59, 32768, 8905, 97, 114, 114, 59, 32768, 10614, 117, 101, 115, 116, 59, 32768, 10875, 512, 80, 105, 11890, 11895, 97, 114, 59, 32768, 10646, 768, 59, 101, 102, 11902, 11904, 11907, 32768, 9667, 59, 32768, 8884, 59, 32768, 9666, 114, 512, 100, 117, 11916, 11923, 115, 104, 97, 114, 59, 32768, 10570, 104, 97, 114, 59, 32768, 10598, 512, 101, 110, 11934, 11944, 114, 116, 110, 101, 113, 113, 59, 32896, 8808, 65024, 69, 59, 32896, 8808, 65024, 3584, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 11978, 11984, 12061, 12075, 12081, 12095, 12100, 12104, 12170, 12181, 12188, 12204, 12207, 12223, 68, 111, 116, 59, 32768, 8762, 1024, 99, 108, 112, 114, 11993, 11999, 12019, 12055, 114, 33024, 175, 59, 32768, 175, 512, 101, 116, 12004, 12007, 59, 32768, 9794, 512, 59, 101, 12012, 12014, 32768, 10016, 115, 101, 59, 32768, 10016, 512, 59, 115, 12024, 12026, 32768, 8614, 116, 111, 1024, 59, 100, 108, 117, 12037, 12039, 12045, 12051, 32768, 8614, 111, 119, 110, 59, 32768, 8615, 101, 102, 116, 59, 32768, 8612, 112, 59, 32768, 8613, 107, 101, 114, 59, 32768, 9646, 512, 111, 121, 12066, 12072, 109, 109, 97, 59, 32768, 10793, 59, 32768, 1084, 97, 115, 104, 59, 32768, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 32768, 8737, 114, 59, 32896, 55349, 56618, 111, 59, 32768, 8487, 768, 99, 100, 110, 12111, 12118, 12146, 114, 111, 33024, 181, 59, 32768, 181, 1024, 59, 97, 99, 100, 12127, 12129, 12134, 12139, 32768, 8739, 115, 116, 59, 32768, 42, 105, 114, 59, 32768, 10992, 111, 116, 33024, 183, 59, 32768, 183, 117, 115, 768, 59, 98, 100, 12155, 12157, 12160, 32768, 8722, 59, 32768, 8863, 512, 59, 117, 12165, 12167, 32768, 8760, 59, 32768, 10794, 564, 12174, 12178, 112, 59, 32768, 10971, 114, 59, 32768, 8230, 112, 108, 117, 115, 59, 32768, 8723, 512, 100, 112, 12193, 12199, 101, 108, 115, 59, 32768, 8871, 102, 59, 32896, 55349, 56670, 59, 32768, 8723, 512, 99, 116, 12212, 12217, 114, 59, 32896, 55349, 56514, 112, 111, 115, 59, 32768, 8766, 768, 59, 108, 109, 12230, 12232, 12240, 32768, 956, 116, 105, 109, 97, 112, 59, 32768, 8888, 97, 112, 59, 32768, 8888, 6144, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 12294, 12315, 12364, 12376, 12393, 12472, 12496, 12547, 12553, 12636, 12641, 12703, 12725, 12747, 12752, 12876, 12881, 12957, 13033, 13089, 13294, 13359, 13384, 13499, 512, 103, 116, 12299, 12303, 59, 32896, 8921, 824, 512, 59, 118, 12308, 12311, 32896, 8811, 8402, 59, 32896, 8811, 824, 768, 101, 108, 116, 12322, 12348, 12352, 102, 116, 512, 97, 114, 12329, 12336, 114, 114, 111, 119, 59, 32768, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8654, 59, 32896, 8920, 824, 512, 59, 118, 12357, 12360, 32896, 8810, 8402, 59, 32896, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8655, 512, 68, 100, 12381, 12387, 97, 115, 104, 59, 32768, 8879, 97, 115, 104, 59, 32768, 8878, 1280, 98, 99, 110, 112, 116, 12404, 12409, 12415, 12420, 12452, 108, 97, 59, 32768, 8711, 117, 116, 101, 59, 32768, 324, 103, 59, 32896, 8736, 8402, 1280, 59, 69, 105, 111, 112, 12431, 12433, 12437, 12442, 12446, 32768, 8777, 59, 32896, 10864, 824, 100, 59, 32896, 8779, 824, 115, 59, 32768, 329, 114, 111, 120, 59, 32768, 8777, 117, 114, 512, 59, 97, 12459, 12461, 32768, 9838, 108, 512, 59, 115, 12467, 12469, 32768, 9838, 59, 32768, 8469, 836, 12477, 0, 12483, 112, 33024, 160, 59, 32768, 160, 109, 112, 512, 59, 101, 12489, 12492, 32896, 8782, 824, 59, 32896, 8783, 824, 1280, 97, 101, 111, 117, 121, 12507, 12519, 12525, 12540, 12544, 833, 12512, 0, 12515, 59, 32768, 10819, 111, 110, 59, 32768, 328, 100, 105, 108, 59, 32768, 326, 110, 103, 512, 59, 100, 12532, 12534, 32768, 8775, 111, 116, 59, 32896, 10861, 824, 112, 59, 32768, 10818, 59, 32768, 1085, 97, 115, 104, 59, 32768, 8211, 1792, 59, 65, 97, 100, 113, 115, 120, 12568, 12570, 12575, 12596, 12602, 12608, 12623, 32768, 8800, 114, 114, 59, 32768, 8663, 114, 512, 104, 114, 12581, 12585, 107, 59, 32768, 10532, 512, 59, 111, 12590, 12592, 32768, 8599, 119, 59, 32768, 8599, 111, 116, 59, 32896, 8784, 824, 117, 105, 118, 59, 32768, 8802, 512, 101, 105, 12613, 12618, 97, 114, 59, 32768, 10536, 109, 59, 32896, 8770, 824, 105, 115, 116, 512, 59, 115, 12631, 12633, 32768, 8708, 59, 32768, 8708, 114, 59, 32896, 55349, 56619, 1024, 69, 101, 115, 116, 12650, 12654, 12688, 12693, 59, 32896, 8807, 824, 768, 59, 113, 115, 12661, 12663, 12684, 32768, 8817, 768, 59, 113, 115, 12670, 12672, 12676, 32768, 8817, 59, 32896, 8807, 824, 108, 97, 110, 116, 59, 32896, 10878, 824, 59, 32896, 10878, 824, 105, 109, 59, 32768, 8821, 512, 59, 114, 12698, 12700, 32768, 8815, 59, 32768, 8815, 768, 65, 97, 112, 12710, 12715, 12720, 114, 114, 59, 32768, 8654, 114, 114, 59, 32768, 8622, 97, 114, 59, 32768, 10994, 768, 59, 115, 118, 12732, 12734, 12744, 32768, 8715, 512, 59, 100, 12739, 12741, 32768, 8956, 59, 32768, 8954, 59, 32768, 8715, 99, 121, 59, 32768, 1114, 1792, 65, 69, 97, 100, 101, 115, 116, 12767, 12772, 12776, 12781, 12785, 12853, 12858, 114, 114, 59, 32768, 8653, 59, 32896, 8806, 824, 114, 114, 59, 32768, 8602, 114, 59, 32768, 8229, 1024, 59, 102, 113, 115, 12794, 12796, 12821, 12842, 32768, 8816, 116, 512, 97, 114, 12802, 12809, 114, 114, 111, 119, 59, 32768, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8622, 768, 59, 113, 115, 12828, 12830, 12834, 32768, 8816, 59, 32896, 8806, 824, 108, 97, 110, 116, 59, 32896, 10877, 824, 512, 59, 115, 12847, 12850, 32896, 10877, 824, 59, 32768, 8814, 105, 109, 59, 32768, 8820, 512, 59, 114, 12863, 12865, 32768, 8814, 105, 512, 59, 101, 12871, 12873, 32768, 8938, 59, 32768, 8940, 105, 100, 59, 32768, 8740, 512, 112, 116, 12886, 12891, 102, 59, 32896, 55349, 56671, 33536, 172, 59, 105, 110, 12899, 12901, 12936, 32768, 172, 110, 1024, 59, 69, 100, 118, 12911, 12913, 12917, 12923, 32768, 8713, 59, 32896, 8953, 824, 111, 116, 59, 32896, 8949, 824, 818, 12928, 12931, 12934, 59, 32768, 8713, 59, 32768, 8951, 59, 32768, 8950, 105, 512, 59, 118, 12942, 12944, 32768, 8716, 818, 12949, 12952, 12955, 59, 32768, 8716, 59, 32768, 8958, 59, 32768, 8957, 768, 97, 111, 114, 12964, 12992, 12999, 114, 1024, 59, 97, 115, 116, 12974, 12976, 12983, 12988, 32768, 8742, 108, 108, 101, 108, 59, 32768, 8742, 108, 59, 32896, 11005, 8421, 59, 32896, 8706, 824, 108, 105, 110, 116, 59, 32768, 10772, 768, 59, 99, 101, 13006, 13008, 13013, 32768, 8832, 117, 101, 59, 32768, 8928, 512, 59, 99, 13018, 13021, 32896, 10927, 824, 512, 59, 101, 13026, 13028, 32768, 8832, 113, 59, 32896, 10927, 824, 1024, 65, 97, 105, 116, 13042, 13047, 13066, 13077, 114, 114, 59, 32768, 8655, 114, 114, 768, 59, 99, 119, 13056, 13058, 13062, 32768, 8603, 59, 32896, 10547, 824, 59, 32896, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8603, 114, 105, 512, 59, 101, 13084, 13086, 32768, 8939, 59, 32768, 8941, 1792, 99, 104, 105, 109, 112, 113, 117, 13104, 13128, 13151, 13169, 13174, 13179, 13194, 1024, 59, 99, 101, 114, 13113, 13115, 13120, 13124, 32768, 8833, 117, 101, 59, 32768, 8929, 59, 32896, 10928, 824, 59, 32896, 55349, 56515, 111, 114, 116, 1086, 13137, 0, 0, 13142, 105, 100, 59, 32768, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 32768, 8742, 109, 512, 59, 101, 13157, 13159, 32768, 8769, 512, 59, 113, 13164, 13166, 32768, 8772, 59, 32768, 8772, 105, 100, 59, 32768, 8740, 97, 114, 59, 32768, 8742, 115, 117, 512, 98, 112, 13186, 13190, 101, 59, 32768, 8930, 101, 59, 32768, 8931, 768, 98, 99, 112, 13201, 13241, 13254, 1024, 59, 69, 101, 115, 13210, 13212, 13216, 13219, 32768, 8836, 59, 32896, 10949, 824, 59, 32768, 8840, 101, 116, 512, 59, 101, 13226, 13229, 32896, 8834, 8402, 113, 512, 59, 113, 13235, 13237, 32768, 8840, 59, 32896, 10949, 824, 99, 512, 59, 101, 13247, 13249, 32768, 8833, 113, 59, 32896, 10928, 824, 1024, 59, 69, 101, 115, 13263, 13265, 13269, 13272, 32768, 8837, 59, 32896, 10950, 824, 59, 32768, 8841, 101, 116, 512, 59, 101, 13279, 13282, 32896, 8835, 8402, 113, 512, 59, 113, 13288, 13290, 32768, 8841, 59, 32896, 10950, 824, 1024, 103, 105, 108, 114, 13303, 13307, 13315, 13319, 108, 59, 32768, 8825, 108, 100, 101, 33024, 241, 59, 32768, 241, 103, 59, 32768, 8824, 105, 97, 110, 103, 108, 101, 512, 108, 114, 13330, 13344, 101, 102, 116, 512, 59, 101, 13338, 13340, 32768, 8938, 113, 59, 32768, 8940, 105, 103, 104, 116, 512, 59, 101, 13353, 13355, 32768, 8939, 113, 59, 32768, 8941, 512, 59, 109, 13364, 13366, 32768, 957, 768, 59, 101, 115, 13373, 13375, 13380, 32768, 35, 114, 111, 59, 32768, 8470, 112, 59, 32768, 8199, 2304, 68, 72, 97, 100, 103, 105, 108, 114, 115, 13403, 13409, 13415, 13420, 13426, 13439, 13446, 13476, 13493, 97, 115, 104, 59, 32768, 8877, 97, 114, 114, 59, 32768, 10500, 112, 59, 32896, 8781, 8402, 97, 115, 104, 59, 32768, 8876, 512, 101, 116, 13431, 13435, 59, 32896, 8805, 8402, 59, 32896, 62, 8402, 110, 102, 105, 110, 59, 32768, 10718, 768, 65, 101, 116, 13453, 13458, 13462, 114, 114, 59, 32768, 10498, 59, 32896, 8804, 8402, 512, 59, 114, 13467, 13470, 32896, 60, 8402, 105, 101, 59, 32896, 8884, 8402, 512, 65, 116, 13481, 13486, 114, 114, 59, 32768, 10499, 114, 105, 101, 59, 32896, 8885, 8402, 105, 109, 59, 32896, 8764, 8402, 768, 65, 97, 110, 13506, 13511, 13532, 114, 114, 59, 32768, 8662, 114, 512, 104, 114, 13517, 13521, 107, 59, 32768, 10531, 512, 59, 111, 13526, 13528, 32768, 8598, 119, 59, 32768, 8598, 101, 97, 114, 59, 32768, 10535, 9252, 13576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13579, 0, 13596, 13617, 13653, 13659, 13673, 13695, 13708, 0, 0, 13713, 13750, 0, 13788, 13794, 0, 13815, 13890, 13913, 13937, 13944, 59, 32768, 9416, 512, 99, 115, 13583, 13591, 117, 116, 101, 33024, 243, 59, 32768, 243, 116, 59, 32768, 8859, 512, 105, 121, 13600, 13613, 114, 512, 59, 99, 13606, 13608, 32768, 8858, 33024, 244, 59, 32768, 244, 59, 32768, 1086, 1280, 97, 98, 105, 111, 115, 13627, 13632, 13638, 13642, 13646, 115, 104, 59, 32768, 8861, 108, 97, 99, 59, 32768, 337, 118, 59, 32768, 10808, 116, 59, 32768, 8857, 111, 108, 100, 59, 32768, 10684, 108, 105, 103, 59, 32768, 339, 512, 99, 114, 13663, 13668, 105, 114, 59, 32768, 10687, 59, 32896, 55349, 56620, 1600, 13680, 0, 0, 13684, 0, 13692, 110, 59, 32768, 731, 97, 118, 101, 33024, 242, 59, 32768, 242, 59, 32768, 10689, 512, 98, 109, 13699, 13704, 97, 114, 59, 32768, 10677, 59, 32768, 937, 110, 116, 59, 32768, 8750, 1024, 97, 99, 105, 116, 13721, 13726, 13741, 13746, 114, 114, 59, 32768, 8634, 512, 105, 114, 13731, 13735, 114, 59, 32768, 10686, 111, 115, 115, 59, 32768, 10683, 110, 101, 59, 32768, 8254, 59, 32768, 10688, 768, 97, 101, 105, 13756, 13761, 13766, 99, 114, 59, 32768, 333, 103, 97, 59, 32768, 969, 768, 99, 100, 110, 13773, 13779, 13782, 114, 111, 110, 59, 32768, 959, 59, 32768, 10678, 117, 115, 59, 32768, 8854, 112, 102, 59, 32896, 55349, 56672, 768, 97, 101, 108, 13800, 13804, 13809, 114, 59, 32768, 10679, 114, 112, 59, 32768, 10681, 117, 115, 59, 32768, 8853, 1792, 59, 97, 100, 105, 111, 115, 118, 13829, 13831, 13836, 13869, 13875, 13879, 13886, 32768, 8744, 114, 114, 59, 32768, 8635, 1024, 59, 101, 102, 109, 13845, 13847, 13859, 13864, 32768, 10845, 114, 512, 59, 111, 13853, 13855, 32768, 8500, 102, 59, 32768, 8500, 33024, 170, 59, 32768, 170, 33024, 186, 59, 32768, 186, 103, 111, 102, 59, 32768, 8886, 114, 59, 32768, 10838, 108, 111, 112, 101, 59, 32768, 10839, 59, 32768, 10843, 768, 99, 108, 111, 13896, 13900, 13908, 114, 59, 32768, 8500, 97, 115, 104, 33024, 248, 59, 32768, 248, 108, 59, 32768, 8856, 105, 573, 13917, 13924, 100, 101, 33024, 245, 59, 32768, 245, 101, 115, 512, 59, 97, 13930, 13932, 32768, 8855, 115, 59, 32768, 10806, 109, 108, 33024, 246, 59, 32768, 246, 98, 97, 114, 59, 32768, 9021, 5426, 13972, 0, 14013, 0, 14017, 14053, 0, 14058, 14086, 0, 0, 14107, 14199, 0, 14202, 0, 0, 14229, 14425, 0, 14438, 114, 1024, 59, 97, 115, 116, 13981, 13983, 13997, 14009, 32768, 8741, 33280, 182, 59, 108, 13989, 13991, 32768, 182, 108, 101, 108, 59, 32768, 8741, 1082, 14003, 0, 0, 14007, 109, 59, 32768, 10995, 59, 32768, 11005, 59, 32768, 8706, 121, 59, 32768, 1087, 114, 1280, 99, 105, 109, 112, 116, 14028, 14033, 14038, 14043, 14046, 110, 116, 59, 32768, 37, 111, 100, 59, 32768, 46, 105, 108, 59, 32768, 8240, 59, 32768, 8869, 101, 110, 107, 59, 32768, 8241, 114, 59, 32896, 55349, 56621, 768, 105, 109, 111, 14064, 14074, 14080, 512, 59, 118, 14069, 14071, 32768, 966, 59, 32768, 981, 109, 97, 116, 59, 32768, 8499, 110, 101, 59, 32768, 9742, 768, 59, 116, 118, 14092, 14094, 14103, 32768, 960, 99, 104, 102, 111, 114, 107, 59, 32768, 8916, 59, 32768, 982, 512, 97, 117, 14111, 14132, 110, 512, 99, 107, 14117, 14128, 107, 512, 59, 104, 14123, 14125, 32768, 8463, 59, 32768, 8462, 118, 59, 32768, 8463, 115, 2304, 59, 97, 98, 99, 100, 101, 109, 115, 116, 14152, 14154, 14160, 14163, 14168, 14179, 14182, 14188, 14193, 32768, 43, 99, 105, 114, 59, 32768, 10787, 59, 32768, 8862, 105, 114, 59, 32768, 10786, 512, 111, 117, 14173, 14176, 59, 32768, 8724, 59, 32768, 10789, 59, 32768, 10866, 110, 33024, 177, 59, 32768, 177, 105, 109, 59, 32768, 10790, 119, 111, 59, 32768, 10791, 59, 32768, 177, 768, 105, 112, 117, 14208, 14216, 14221, 110, 116, 105, 110, 116, 59, 32768, 10773, 102, 59, 32896, 55349, 56673, 110, 100, 33024, 163, 59, 32768, 163, 2560, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 14249, 14251, 14254, 14258, 14263, 14336, 14348, 14367, 14413, 14418, 32768, 8826, 59, 32768, 10931, 112, 59, 32768, 10935, 117, 101, 59, 32768, 8828, 512, 59, 99, 14268, 14270, 32768, 10927, 1536, 59, 97, 99, 101, 110, 115, 14283, 14285, 14293, 14302, 14306, 14331, 32768, 8826, 112, 112, 114, 111, 120, 59, 32768, 10935, 117, 114, 108, 121, 101, 113, 59, 32768, 8828, 113, 59, 32768, 10927, 768, 97, 101, 115, 14313, 14321, 14326, 112, 112, 114, 111, 120, 59, 32768, 10937, 113, 113, 59, 32768, 10933, 105, 109, 59, 32768, 8936, 105, 109, 59, 32768, 8830, 109, 101, 512, 59, 115, 14343, 14345, 32768, 8242, 59, 32768, 8473, 768, 69, 97, 115, 14355, 14358, 14362, 59, 32768, 10933, 112, 59, 32768, 10937, 105, 109, 59, 32768, 8936, 768, 100, 102, 112, 14374, 14377, 14402, 59, 32768, 8719, 768, 97, 108, 115, 14384, 14390, 14396, 108, 97, 114, 59, 32768, 9006, 105, 110, 101, 59, 32768, 8978, 117, 114, 102, 59, 32768, 8979, 512, 59, 116, 14407, 14409, 32768, 8733, 111, 59, 32768, 8733, 105, 109, 59, 32768, 8830, 114, 101, 108, 59, 32768, 8880, 512, 99, 105, 14429, 14434, 114, 59, 32896, 55349, 56517, 59, 32768, 968, 110, 99, 115, 112, 59, 32768, 8200, 1536, 102, 105, 111, 112, 115, 117, 14457, 14462, 14467, 14473, 14480, 14486, 114, 59, 32896, 55349, 56622, 110, 116, 59, 32768, 10764, 112, 102, 59, 32896, 55349, 56674, 114, 105, 109, 101, 59, 32768, 8279, 99, 114, 59, 32896, 55349, 56518, 768, 97, 101, 111, 14493, 14513, 14526, 116, 512, 101, 105, 14499, 14508, 114, 110, 105, 111, 110, 115, 59, 32768, 8461, 110, 116, 59, 32768, 10774, 115, 116, 512, 59, 101, 14520, 14522, 32768, 63, 113, 59, 32768, 8799, 116, 33024, 34, 59, 32768, 34, 5376, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 14575, 14597, 14603, 14608, 14775, 14829, 14865, 14901, 14943, 14966, 15000, 15139, 15159, 15176, 15182, 15236, 15261, 15267, 15309, 15352, 15360, 768, 97, 114, 116, 14582, 14587, 14591, 114, 114, 59, 32768, 8667, 114, 59, 32768, 8658, 97, 105, 108, 59, 32768, 10524, 97, 114, 114, 59, 32768, 10511, 97, 114, 59, 32768, 10596, 1792, 99, 100, 101, 110, 113, 114, 116, 14623, 14637, 14642, 14650, 14672, 14679, 14751, 512, 101, 117, 14628, 14632, 59, 32896, 8765, 817, 116, 101, 59, 32768, 341, 105, 99, 59, 32768, 8730, 109, 112, 116, 121, 118, 59, 32768, 10675, 103, 1024, 59, 100, 101, 108, 14660, 14662, 14665, 14668, 32768, 10217, 59, 32768, 10642, 59, 32768, 10661, 101, 59, 32768, 10217, 117, 111, 33024, 187, 59, 32768, 187, 114, 2816, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 14703, 14705, 14709, 14720, 14723, 14727, 14731, 14735, 14739, 14744, 14748, 32768, 8594, 112, 59, 32768, 10613, 512, 59, 102, 14714, 14716, 32768, 8677, 115, 59, 32768, 10528, 59, 32768, 10547, 115, 59, 32768, 10526, 107, 59, 32768, 8618, 112, 59, 32768, 8620, 108, 59, 32768, 10565, 105, 109, 59, 32768, 10612, 108, 59, 32768, 8611, 59, 32768, 8605, 512, 97, 105, 14756, 14761, 105, 108, 59, 32768, 10522, 111, 512, 59, 110, 14767, 14769, 32768, 8758, 97, 108, 115, 59, 32768, 8474, 768, 97, 98, 114, 14782, 14787, 14792, 114, 114, 59, 32768, 10509, 114, 107, 59, 32768, 10099, 512, 97, 107, 14797, 14809, 99, 512, 101, 107, 14803, 14806, 59, 32768, 125, 59, 32768, 93, 512, 101, 115, 14814, 14817, 59, 32768, 10636, 108, 512, 100, 117, 14823, 14826, 59, 32768, 10638, 59, 32768, 10640, 1024, 97, 101, 117, 121, 14838, 14844, 14858, 14862, 114, 111, 110, 59, 32768, 345, 512, 100, 105, 14849, 14854, 105, 108, 59, 32768, 343, 108, 59, 32768, 8969, 98, 59, 32768, 125, 59, 32768, 1088, 1024, 99, 108, 113, 115, 14874, 14878, 14885, 14897, 97, 59, 32768, 10551, 100, 104, 97, 114, 59, 32768, 10601, 117, 111, 512, 59, 114, 14892, 14894, 32768, 8221, 59, 32768, 8221, 104, 59, 32768, 8627, 768, 97, 99, 103, 14908, 14934, 14938, 108, 1024, 59, 105, 112, 115, 14918, 14920, 14925, 14931, 32768, 8476, 110, 101, 59, 32768, 8475, 97, 114, 116, 59, 32768, 8476, 59, 32768, 8477, 116, 59, 32768, 9645, 33024, 174, 59, 32768, 174, 768, 105, 108, 114, 14950, 14956, 14962, 115, 104, 116, 59, 32768, 10621, 111, 111, 114, 59, 32768, 8971, 59, 32896, 55349, 56623, 512, 97, 111, 14971, 14990, 114, 512, 100, 117, 14977, 14980, 59, 32768, 8641, 512, 59, 108, 14985, 14987, 32768, 8640, 59, 32768, 10604, 512, 59, 118, 14995, 14997, 32768, 961, 59, 32768, 1009, 768, 103, 110, 115, 15007, 15123, 15127, 104, 116, 1536, 97, 104, 108, 114, 115, 116, 15022, 15039, 15060, 15086, 15099, 15111, 114, 114, 111, 119, 512, 59, 116, 15031, 15033, 32768, 8594, 97, 105, 108, 59, 32768, 8611, 97, 114, 112, 111, 111, 110, 512, 100, 117, 15050, 15056, 111, 119, 110, 59, 32768, 8641, 112, 59, 32768, 8640, 101, 102, 116, 512, 97, 104, 15068, 15076, 114, 114, 111, 119, 115, 59, 32768, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 32768, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 32768, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 32768, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 32768, 8908, 103, 59, 32768, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 32768, 8787, 768, 97, 104, 109, 15146, 15151, 15156, 114, 114, 59, 32768, 8644, 97, 114, 59, 32768, 8652, 59, 32768, 8207, 111, 117, 115, 116, 512, 59, 97, 15168, 15170, 32768, 9137, 99, 104, 101, 59, 32768, 9137, 109, 105, 100, 59, 32768, 10990, 1024, 97, 98, 112, 116, 15191, 15204, 15209, 15229, 512, 110, 114, 15196, 15200, 103, 59, 32768, 10221, 114, 59, 32768, 8702, 114, 107, 59, 32768, 10215, 768, 97, 102, 108, 15216, 15220, 15224, 114, 59, 32768, 10630, 59, 32896, 55349, 56675, 117, 115, 59, 32768, 10798, 105, 109, 101, 115, 59, 32768, 10805, 512, 97, 112, 15241, 15253, 114, 512, 59, 103, 15247, 15249, 32768, 41, 116, 59, 32768, 10644, 111, 108, 105, 110, 116, 59, 32768, 10770, 97, 114, 114, 59, 32768, 8649, 1024, 97, 99, 104, 113, 15276, 15282, 15287, 15290, 113, 117, 111, 59, 32768, 8250, 114, 59, 32896, 55349, 56519, 59, 32768, 8625, 512, 98, 117, 15295, 15298, 59, 32768, 93, 111, 512, 59, 114, 15304, 15306, 32768, 8217, 59, 32768, 8217, 768, 104, 105, 114, 15316, 15322, 15328, 114, 101, 101, 59, 32768, 8908, 109, 101, 115, 59, 32768, 8906, 105, 1024, 59, 101, 102, 108, 15338, 15340, 15343, 15346, 32768, 9657, 59, 32768, 8885, 59, 32768, 9656, 116, 114, 105, 59, 32768, 10702, 108, 117, 104, 97, 114, 59, 32768, 10600, 59, 32768, 8478, 6706, 15391, 15398, 15404, 15499, 15516, 15592, 0, 15606, 15660, 0, 0, 15752, 15758, 0, 15827, 15863, 15886, 16000, 16006, 16038, 16086, 0, 16467, 0, 0, 16506, 99, 117, 116, 101, 59, 32768, 347, 113, 117, 111, 59, 32768, 8218, 2560, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 15424, 15426, 15429, 15441, 15446, 15458, 15463, 15482, 15490, 15495, 32768, 8827, 59, 32768, 10932, 833, 15434, 0, 15437, 59, 32768, 10936, 111, 110, 59, 32768, 353, 117, 101, 59, 32768, 8829, 512, 59, 100, 15451, 15453, 32768, 10928, 105, 108, 59, 32768, 351, 114, 99, 59, 32768, 349, 768, 69, 97, 115, 15470, 15473, 15477, 59, 32768, 10934, 112, 59, 32768, 10938, 105, 109, 59, 32768, 8937, 111, 108, 105, 110, 116, 59, 32768, 10771, 105, 109, 59, 32768, 8831, 59, 32768, 1089, 111, 116, 768, 59, 98, 101, 15507, 15509, 15512, 32768, 8901, 59, 32768, 8865, 59, 32768, 10854, 1792, 65, 97, 99, 109, 115, 116, 120, 15530, 15535, 15556, 15562, 15566, 15572, 15587, 114, 114, 59, 32768, 8664, 114, 512, 104, 114, 15541, 15545, 107, 59, 32768, 10533, 512, 59, 111, 15550, 15552, 32768, 8600, 119, 59, 32768, 8600, 116, 33024, 167, 59, 32768, 167, 105, 59, 32768, 59, 119, 97, 114, 59, 32768, 10537, 109, 512, 105, 110, 15578, 15584, 110, 117, 115, 59, 32768, 8726, 59, 32768, 8726, 116, 59, 32768, 10038, 114, 512, 59, 111, 15597, 15600, 32896, 55349, 56624, 119, 110, 59, 32768, 8994, 1024, 97, 99, 111, 121, 15614, 15619, 15632, 15654, 114, 112, 59, 32768, 9839, 512, 104, 121, 15624, 15629, 99, 121, 59, 32768, 1097, 59, 32768, 1096, 114, 116, 1086, 15640, 0, 0, 15645, 105, 100, 59, 32768, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 32768, 8741, 33024, 173, 59, 32768, 173, 512, 103, 109, 15664, 15681, 109, 97, 768, 59, 102, 118, 15673, 15675, 15678, 32768, 963, 59, 32768, 962, 59, 32768, 962, 2048, 59, 100, 101, 103, 108, 110, 112, 114, 15698, 15700, 15705, 15715, 15725, 15735, 15739, 15745, 32768, 8764, 111, 116, 59, 32768, 10858, 512, 59, 113, 15710, 15712, 32768, 8771, 59, 32768, 8771, 512, 59, 69, 15720, 15722, 32768, 10910, 59, 32768, 10912, 512, 59, 69, 15730, 15732, 32768, 10909, 59, 32768, 10911, 101, 59, 32768, 8774, 108, 117, 115, 59, 32768, 10788, 97, 114, 114, 59, 32768, 10610, 97, 114, 114, 59, 32768, 8592, 1024, 97, 101, 105, 116, 15766, 15788, 15796, 15808, 512, 108, 115, 15771, 15783, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 32768, 8726, 104, 112, 59, 32768, 10803, 112, 97, 114, 115, 108, 59, 32768, 10724, 512, 100, 108, 15801, 15804, 59, 32768, 8739, 101, 59, 32768, 8995, 512, 59, 101, 15813, 15815, 32768, 10922, 512, 59, 115, 15820, 15822, 32768, 10924, 59, 32896, 10924, 65024, 768, 102, 108, 112, 15833, 15839, 15857, 116, 99, 121, 59, 32768, 1100, 512, 59, 98, 15844, 15846, 32768, 47, 512, 59, 97, 15851, 15853, 32768, 10692, 114, 59, 32768, 9023, 102, 59, 32896, 55349, 56676, 97, 512, 100, 114, 15868, 15882, 101, 115, 512, 59, 117, 15875, 15877, 32768, 9824, 105, 116, 59, 32768, 9824, 59, 32768, 8741, 768, 99, 115, 117, 15892, 15921, 15977, 512, 97, 117, 15897, 15909, 112, 512, 59, 115, 15903, 15905, 32768, 8851, 59, 32896, 8851, 65024, 112, 512, 59, 115, 15915, 15917, 32768, 8852, 59, 32896, 8852, 65024, 117, 512, 98, 112, 15927, 15952, 768, 59, 101, 115, 15934, 15936, 15939, 32768, 8847, 59, 32768, 8849, 101, 116, 512, 59, 101, 15946, 15948, 32768, 8847, 113, 59, 32768, 8849, 768, 59, 101, 115, 15959, 15961, 15964, 32768, 8848, 59, 32768, 8850, 101, 116, 512, 59, 101, 15971, 15973, 32768, 8848, 113, 59, 32768, 8850, 768, 59, 97, 102, 15984, 15986, 15996, 32768, 9633, 114, 566, 15991, 15994, 59, 32768, 9633, 59, 32768, 9642, 59, 32768, 9642, 97, 114, 114, 59, 32768, 8594, 1024, 99, 101, 109, 116, 16014, 16019, 16025, 16031, 114, 59, 32896, 55349, 56520, 116, 109, 110, 59, 32768, 8726, 105, 108, 101, 59, 32768, 8995, 97, 114, 102, 59, 32768, 8902, 512, 97, 114, 16042, 16053, 114, 512, 59, 102, 16048, 16050, 32768, 9734, 59, 32768, 9733, 512, 97, 110, 16058, 16081, 105, 103, 104, 116, 512, 101, 112, 16067, 16076, 112, 115, 105, 108, 111, 110, 59, 32768, 1013, 104, 105, 59, 32768, 981, 115, 59, 32768, 175, 1280, 98, 99, 109, 110, 112, 16096, 16221, 16288, 16291, 16295, 2304, 59, 69, 100, 101, 109, 110, 112, 114, 115, 16115, 16117, 16120, 16125, 16137, 16143, 16154, 16160, 16166, 32768, 8834, 59, 32768, 10949, 111, 116, 59, 32768, 10941, 512, 59, 100, 16130, 16132, 32768, 8838, 111, 116, 59, 32768, 10947, 117, 108, 116, 59, 32768, 10945, 512, 69, 101, 16148, 16151, 59, 32768, 10955, 59, 32768, 8842, 108, 117, 115, 59, 32768, 10943, 97, 114, 114, 59, 32768, 10617, 768, 101, 105, 117, 16173, 16206, 16210, 116, 768, 59, 101, 110, 16181, 16183, 16194, 32768, 8834, 113, 512, 59, 113, 16189, 16191, 32768, 8838, 59, 32768, 10949, 101, 113, 512, 59, 113, 16201, 16203, 32768, 8842, 59, 32768, 10955, 109, 59, 32768, 10951, 512, 98, 112, 16215, 16218, 59, 32768, 10965, 59, 32768, 10963, 99, 1536, 59, 97, 99, 101, 110, 115, 16235, 16237, 16245, 16254, 16258, 16283, 32768, 8827, 112, 112, 114, 111, 120, 59, 32768, 10936, 117, 114, 108, 121, 101, 113, 59, 32768, 8829, 113, 59, 32768, 10928, 768, 97, 101, 115, 16265, 16273, 16278, 112, 112, 114, 111, 120, 59, 32768, 10938, 113, 113, 59, 32768, 10934, 105, 109, 59, 32768, 8937, 105, 109, 59, 32768, 8831, 59, 32768, 8721, 103, 59, 32768, 9834, 3328, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 16322, 16327, 16332, 16337, 16339, 16342, 16356, 16368, 16382, 16388, 16394, 16405, 16411, 33024, 185, 59, 32768, 185, 33024, 178, 59, 32768, 178, 33024, 179, 59, 32768, 179, 32768, 8835, 59, 32768, 10950, 512, 111, 115, 16347, 16351, 116, 59, 32768, 10942, 117, 98, 59, 32768, 10968, 512, 59, 100, 16361, 16363, 32768, 8839, 111, 116, 59, 32768, 10948, 115, 512, 111, 117, 16374, 16378, 108, 59, 32768, 10185, 98, 59, 32768, 10967, 97, 114, 114, 59, 32768, 10619, 117, 108, 116, 59, 32768, 10946, 512, 69, 101, 16399, 16402, 59, 32768, 10956, 59, 32768, 8843, 108, 117, 115, 59, 32768, 10944, 768, 101, 105, 117, 16418, 16451, 16455, 116, 768, 59, 101, 110, 16426, 16428, 16439, 32768, 8835, 113, 512, 59, 113, 16434, 16436, 32768, 8839, 59, 32768, 10950, 101, 113, 512, 59, 113, 16446, 16448, 32768, 8843, 59, 32768, 10956, 109, 59, 32768, 10952, 512, 98, 112, 16460, 16463, 59, 32768, 10964, 59, 32768, 10966, 768, 65, 97, 110, 16473, 16478, 16499, 114, 114, 59, 32768, 8665, 114, 512, 104, 114, 16484, 16488, 107, 59, 32768, 10534, 512, 59, 111, 16493, 16495, 32768, 8601, 119, 59, 32768, 8601, 119, 97, 114, 59, 32768, 10538, 108, 105, 103, 33024, 223, 59, 32768, 223, 5938, 16538, 16552, 16557, 16579, 16584, 16591, 0, 16596, 16692, 0, 0, 0, 0, 0, 16731, 16780, 0, 16787, 16908, 0, 0, 0, 16938, 1091, 16543, 0, 0, 16549, 103, 101, 116, 59, 32768, 8982, 59, 32768, 964, 114, 107, 59, 32768, 9140, 768, 97, 101, 121, 16563, 16569, 16575, 114, 111, 110, 59, 32768, 357, 100, 105, 108, 59, 32768, 355, 59, 32768, 1090, 111, 116, 59, 32768, 8411, 108, 114, 101, 99, 59, 32768, 8981, 114, 59, 32896, 55349, 56625, 1024, 101, 105, 107, 111, 16604, 16641, 16670, 16684, 835, 16609, 0, 16624, 101, 512, 52, 102, 16614, 16617, 59, 32768, 8756, 111, 114, 101, 59, 32768, 8756, 97, 768, 59, 115, 118, 16631, 16633, 16638, 32768, 952, 121, 109, 59, 32768, 977, 59, 32768, 977, 512, 99, 110, 16646, 16665, 107, 512, 97, 115, 16652, 16660, 112, 112, 114, 111, 120, 59, 32768, 8776, 105, 109, 59, 32768, 8764, 115, 112, 59, 32768, 8201, 512, 97, 115, 16675, 16679, 112, 59, 32768, 8776, 105, 109, 59, 32768, 8764, 114, 110, 33024, 254, 59, 32768, 254, 829, 16696, 16701, 16727, 100, 101, 59, 32768, 732, 101, 115, 33536, 215, 59, 98, 100, 16710, 16712, 16723, 32768, 215, 512, 59, 97, 16717, 16719, 32768, 8864, 114, 59, 32768, 10801, 59, 32768, 10800, 116, 59, 32768, 8749, 768, 101, 112, 115, 16737, 16741, 16775, 97, 59, 32768, 10536, 1024, 59, 98, 99, 102, 16750, 16752, 16757, 16762, 32768, 8868, 111, 116, 59, 32768, 9014, 105, 114, 59, 32768, 10993, 512, 59, 111, 16767, 16770, 32896, 55349, 56677, 114, 107, 59, 32768, 10970, 97, 59, 32768, 10537, 114, 105, 109, 101, 59, 32768, 8244, 768, 97, 105, 112, 16793, 16798, 16899, 100, 101, 59, 32768, 8482, 1792, 97, 100, 101, 109, 112, 115, 116, 16813, 16868, 16873, 16876, 16883, 16889, 16893, 110, 103, 108, 101, 1280, 59, 100, 108, 113, 114, 16828, 16830, 16836, 16850, 16853, 32768, 9653, 111, 119, 110, 59, 32768, 9663, 101, 102, 116, 512, 59, 101, 16844, 16846, 32768, 9667, 113, 59, 32768, 8884, 59, 32768, 8796, 105, 103, 104, 116, 512, 59, 101, 16862, 16864, 32768, 9657, 113, 59, 32768, 8885, 111, 116, 59, 32768, 9708, 59, 32768, 8796, 105, 110, 117, 115, 59, 32768, 10810, 108, 117, 115, 59, 32768, 10809, 98, 59, 32768, 10701, 105, 109, 101, 59, 32768, 10811, 101, 122, 105, 117, 109, 59, 32768, 9186, 768, 99, 104, 116, 16914, 16926, 16931, 512, 114, 121, 16919, 16923, 59, 32896, 55349, 56521, 59, 32768, 1094, 99, 121, 59, 32768, 1115, 114, 111, 107, 59, 32768, 359, 512, 105, 111, 16942, 16947, 120, 116, 59, 32768, 8812, 104, 101, 97, 100, 512, 108, 114, 16956, 16967, 101, 102, 116, 97, 114, 114, 111, 119, 59, 32768, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8608, 4608, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 17016, 17021, 17026, 17043, 17057, 17072, 17095, 17110, 17119, 17139, 17172, 17187, 17202, 17290, 17330, 17336, 17365, 17381, 114, 114, 59, 32768, 8657, 97, 114, 59, 32768, 10595, 512, 99, 114, 17031, 17039, 117, 116, 101, 33024, 250, 59, 32768, 250, 114, 59, 32768, 8593, 114, 820, 17049, 0, 17053, 121, 59, 32768, 1118, 118, 101, 59, 32768, 365, 512, 105, 121, 17062, 17069, 114, 99, 33024, 251, 59, 32768, 251, 59, 32768, 1091, 768, 97, 98, 104, 17079, 17084, 17090, 114, 114, 59, 32768, 8645, 108, 97, 99, 59, 32768, 369, 97, 114, 59, 32768, 10606, 512, 105, 114, 17100, 17106, 115, 104, 116, 59, 32768, 10622, 59, 32896, 55349, 56626, 114, 97, 118, 101, 33024, 249, 59, 32768, 249, 562, 17123, 17135, 114, 512, 108, 114, 17128, 17131, 59, 32768, 8639, 59, 32768, 8638, 108, 107, 59, 32768, 9600, 512, 99, 116, 17144, 17167, 1088, 17150, 0, 0, 17163, 114, 110, 512, 59, 101, 17156, 17158, 32768, 8988, 114, 59, 32768, 8988, 111, 112, 59, 32768, 8975, 114, 105, 59, 32768, 9720, 512, 97, 108, 17177, 17182, 99, 114, 59, 32768, 363, 33024, 168, 59, 32768, 168, 512, 103, 112, 17192, 17197, 111, 110, 59, 32768, 371, 102, 59, 32896, 55349, 56678, 1536, 97, 100, 104, 108, 115, 117, 17215, 17222, 17233, 17257, 17262, 17280, 114, 114, 111, 119, 59, 32768, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 32768, 8597, 97, 114, 112, 111, 111, 110, 512, 108, 114, 17244, 17250, 101, 102, 116, 59, 32768, 8639, 105, 103, 104, 116, 59, 32768, 8638, 117, 115, 59, 32768, 8846, 105, 768, 59, 104, 108, 17270, 17272, 17275, 32768, 965, 59, 32768, 978, 111, 110, 59, 32768, 965, 112, 97, 114, 114, 111, 119, 115, 59, 32768, 8648, 768, 99, 105, 116, 17297, 17320, 17325, 1088, 17303, 0, 0, 17316, 114, 110, 512, 59, 101, 17309, 17311, 32768, 8989, 114, 59, 32768, 8989, 111, 112, 59, 32768, 8974, 110, 103, 59, 32768, 367, 114, 105, 59, 32768, 9721, 99, 114, 59, 32896, 55349, 56522, 768, 100, 105, 114, 17343, 17348, 17354, 111, 116, 59, 32768, 8944, 108, 100, 101, 59, 32768, 361, 105, 512, 59, 102, 17360, 17362, 32768, 9653, 59, 32768, 9652, 512, 97, 109, 17370, 17375, 114, 114, 59, 32768, 8648, 108, 33024, 252, 59, 32768, 252, 97, 110, 103, 108, 101, 59, 32768, 10663, 3840, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 17420, 17425, 17437, 17443, 17613, 17617, 17623, 17667, 17672, 17678, 17693, 17699, 17705, 17711, 17754, 114, 114, 59, 32768, 8661, 97, 114, 512, 59, 118, 17432, 17434, 32768, 10984, 59, 32768, 10985, 97, 115, 104, 59, 32768, 8872, 512, 110, 114, 17448, 17454, 103, 114, 116, 59, 32768, 10652, 1792, 101, 107, 110, 112, 114, 115, 116, 17469, 17478, 17485, 17494, 17515, 17526, 17578, 112, 115, 105, 108, 111, 110, 59, 32768, 1013, 97, 112, 112, 97, 59, 32768, 1008, 111, 116, 104, 105, 110, 103, 59, 32768, 8709, 768, 104, 105, 114, 17501, 17505, 17508, 105, 59, 32768, 981, 59, 32768, 982, 111, 112, 116, 111, 59, 32768, 8733, 512, 59, 104, 17520, 17522, 32768, 8597, 111, 59, 32768, 1009, 512, 105, 117, 17531, 17537, 103, 109, 97, 59, 32768, 962, 512, 98, 112, 17542, 17560, 115, 101, 116, 110, 101, 113, 512, 59, 113, 17553, 17556, 32896, 8842, 65024, 59, 32896, 10955, 65024, 115, 101, 116, 110, 101, 113, 512, 59, 113, 17571, 17574, 32896, 8843, 65024, 59, 32896, 10956, 65024, 512, 104, 114, 17583, 17589, 101, 116, 97, 59, 32768, 977, 105, 97, 110, 103, 108, 101, 512, 108, 114, 17600, 17606, 101, 102, 116, 59, 32768, 8882, 105, 103, 104, 116, 59, 32768, 8883, 121, 59, 32768, 1074, 97, 115, 104, 59, 32768, 8866, 768, 101, 108, 114, 17630, 17648, 17654, 768, 59, 98, 101, 17637, 17639, 17644, 32768, 8744, 97, 114, 59, 32768, 8891, 113, 59, 32768, 8794, 108, 105, 112, 59, 32768, 8942, 512, 98, 116, 17659, 17664, 97, 114, 59, 32768, 124, 59, 32768, 124, 114, 59, 32896, 55349, 56627, 116, 114, 105, 59, 32768, 8882, 115, 117, 512, 98, 112, 17685, 17689, 59, 32896, 8834, 8402, 59, 32896, 8835, 8402, 112, 102, 59, 32896, 55349, 56679, 114, 111, 112, 59, 32768, 8733, 116, 114, 105, 59, 32768, 8883, 512, 99, 117, 17716, 17721, 114, 59, 32896, 55349, 56523, 512, 98, 112, 17726, 17740, 110, 512, 69, 101, 17732, 17736, 59, 32896, 10955, 65024, 59, 32896, 8842, 65024, 110, 512, 69, 101, 17746, 17750, 59, 32896, 10956, 65024, 59, 32896, 8843, 65024, 105, 103, 122, 97, 103, 59, 32768, 10650, 1792, 99, 101, 102, 111, 112, 114, 115, 17777, 17783, 17815, 17820, 17826, 17829, 17842, 105, 114, 99, 59, 32768, 373, 512, 100, 105, 17788, 17809, 512, 98, 103, 17793, 17798, 97, 114, 59, 32768, 10847, 101, 512, 59, 113, 17804, 17806, 32768, 8743, 59, 32768, 8793, 101, 114, 112, 59, 32768, 8472, 114, 59, 32896, 55349, 56628, 112, 102, 59, 32896, 55349, 56680, 59, 32768, 8472, 512, 59, 101, 17834, 17836, 32768, 8768, 97, 116, 104, 59, 32768, 8768, 99, 114, 59, 32896, 55349, 56524, 5428, 17871, 17891, 0, 17897, 0, 17902, 17917, 0, 0, 17920, 17935, 17940, 17945, 0, 0, 17977, 17992, 0, 18008, 18024, 18029, 768, 97, 105, 117, 17877, 17881, 17886, 112, 59, 32768, 8898, 114, 99, 59, 32768, 9711, 112, 59, 32768, 8899, 116, 114, 105, 59, 32768, 9661, 114, 59, 32896, 55349, 56629, 512, 65, 97, 17906, 17911, 114, 114, 59, 32768, 10234, 114, 114, 59, 32768, 10231, 59, 32768, 958, 512, 65, 97, 17924, 17929, 114, 114, 59, 32768, 10232, 114, 114, 59, 32768, 10229, 97, 112, 59, 32768, 10236, 105, 115, 59, 32768, 8955, 768, 100, 112, 116, 17951, 17956, 17970, 111, 116, 59, 32768, 10752, 512, 102, 108, 17961, 17965, 59, 32896, 55349, 56681, 117, 115, 59, 32768, 10753, 105, 109, 101, 59, 32768, 10754, 512, 65, 97, 17981, 17986, 114, 114, 59, 32768, 10233, 114, 114, 59, 32768, 10230, 512, 99, 113, 17996, 18001, 114, 59, 32896, 55349, 56525, 99, 117, 112, 59, 32768, 10758, 512, 112, 116, 18012, 18018, 108, 117, 115, 59, 32768, 10756, 114, 105, 59, 32768, 9651, 101, 101, 59, 32768, 8897, 101, 100, 103, 101, 59, 32768, 8896, 2048, 97, 99, 101, 102, 105, 111, 115, 117, 18052, 18068, 18081, 18087, 18092, 18097, 18103, 18109, 99, 512, 117, 121, 18058, 18065, 116, 101, 33024, 253, 59, 32768, 253, 59, 32768, 1103, 512, 105, 121, 18073, 18078, 114, 99, 59, 32768, 375, 59, 32768, 1099, 110, 33024, 165, 59, 32768, 165, 114, 59, 32896, 55349, 56630, 99, 121, 59, 32768, 1111, 112, 102, 59, 32896, 55349, 56682, 99, 114, 59, 32896, 55349, 56526, 512, 99, 109, 18114, 18118, 121, 59, 32768, 1102, 108, 33024, 255, 59, 32768, 255, 2560, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 18145, 18152, 18166, 18171, 18186, 18191, 18196, 18204, 18210, 18216, 99, 117, 116, 101, 59, 32768, 378, 512, 97, 121, 18157, 18163, 114, 111, 110, 59, 32768, 382, 59, 32768, 1079, 111, 116, 59, 32768, 380, 512, 101, 116, 18176, 18182, 116, 114, 102, 59, 32768, 8488, 97, 59, 32768, 950, 114, 59, 32896, 55349, 56631, 99, 121, 59, 32768, 1078, 103, 114, 97, 114, 114, 59, 32768, 8669, 112, 102, 59, 32896, 55349, 56683, 99, 114, 59, 32896, 55349, 56527, 512, 106, 110, 18221, 18224, 59, 32768, 8205, 106, 59, 32768, 8204]);

var decodeDataXml = {};

Object.defineProperty(decodeDataXml, "__esModule", {
  value: true
});
// Generated using scripts/write-decode-map.ts
// prettier-ignore
decodeDataXml.default = new Uint16Array([1024, 97, 103, 108, 113, 9, 23, 27, 31, 1086, 15, 0, 0, 19, 112, 59, 32768, 38, 111, 115, 59, 32768, 39, 116, 59, 32768, 62, 116, 59, 32768, 60, 117, 111, 116, 59, 32768, 34]);

(function (exports) {

	var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
	  return mod && mod.__esModule ? mod : {
	    "default": mod
	  };
	};
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTML = exports.determineBranch = exports.JUMP_OFFSET_BASE = exports.BinTrieFlags = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
	var decode_data_html_1 = __importDefault(decodeDataHtml);
	exports.htmlDecodeTree = decode_data_html_1.default;
	var decode_data_xml_1 = __importDefault(decodeDataXml);
	exports.xmlDecodeTree = decode_data_xml_1.default;
	var decode_codepoint_1 = __importDefault(decode_codepoint);
	var BinTrieFlags;
	(function (BinTrieFlags) {
	  BinTrieFlags[BinTrieFlags["HAS_VALUE"] = 32768] = "HAS_VALUE";
	  BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 32512] = "BRANCH_LENGTH";
	  BinTrieFlags[BinTrieFlags["MULTI_BYTE"] = 128] = "MULTI_BYTE";
	  BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
	})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
	exports.JUMP_OFFSET_BASE = 48 /* ZERO */ - 1;
	function getDecoder(decodeTree) {
	  return function decodeHTMLBinary(str, strict) {
	    var ret = "";
	    var lastIdx = 0;
	    var strIdx = 0;
	    while ((strIdx = str.indexOf("&", strIdx)) >= 0) {
	      ret += str.slice(lastIdx, strIdx);
	      lastIdx = strIdx;
	      // Skip the "&"
	      strIdx += 1;
	      // If we have a numeric entity, handle this separately.
	      if (str.charCodeAt(strIdx) === 35 /* NUM */) {
	        // Skip the leading "&#". For hex entities, also skip the leading "x".
	        var start = strIdx + 1;
	        var base = 10;
	        var cp = str.charCodeAt(start);
	        if ((cp | 32 /* To_LOWER_BIT */) === 120 /* LOWER_X */) {
	          base = 16;
	          strIdx += 1;
	          start += 1;
	        }
	        while ((cp = str.charCodeAt(++strIdx)) >= 48 /* ZERO */ && cp <= 57 /* NINE */ || base === 16 && (cp | 32 /* To_LOWER_BIT */) >= 97 /* LOWER_A */ && (cp | 32 /* To_LOWER_BIT */) <= 102 /* LOWER_F */);
	        if (start !== strIdx) {
	          var entity = str.substring(start, strIdx);
	          var parsed = parseInt(entity, base);
	          if (str.charCodeAt(strIdx) === 59 /* SEMI */) {
	            strIdx += 1;
	          } else if (strict) {
	            continue;
	          }
	          ret += decode_codepoint_1.default(parsed);
	          lastIdx = strIdx;
	        }
	        continue;
	      }
	      var result = null;
	      var excess = 1;
	      var treeIdx = 0;
	      var current = decodeTree[treeIdx];
	      for (; strIdx < str.length; strIdx++, excess++) {
	        treeIdx = determineBranch(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));
	        if (treeIdx < 0) break;
	        current = decodeTree[treeIdx];
	        // If the branch is a value, store it and continue
	        if (current & BinTrieFlags.HAS_VALUE) {
	          // If we have a legacy entity while parsing strictly, just skip the number of bytes
	          if (strict && str.charCodeAt(strIdx) !== 59 /* SEMI */) {
	            // No need to consider multi-byte values, as the legacy entity is always a single byte
	            treeIdx += 1;
	          } else {
	            // If this is a surrogate pair, combine the higher bits from the node with the next byte
	            result = current & BinTrieFlags.MULTI_BYTE ? String.fromCharCode(decodeTree[++treeIdx], decodeTree[++treeIdx]) : String.fromCharCode(decodeTree[++treeIdx]);
	            excess = 0;
	          }
	        }
	      }
	      if (result != null) {
	        ret += result;
	        lastIdx = strIdx - excess + 1;
	      }
	    }
	    return ret + str.slice(lastIdx);
	  };
	}
	function determineBranch(decodeTree, current, nodeIdx, char) {
	  if (current <= 128) {
	    return char === current ? nodeIdx : -1;
	  }
	  var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 8;
	  if (branchCount === 0) {
	    return -1;
	  }
	  if (branchCount === 1) {
	    return char === decodeTree[nodeIdx] ? nodeIdx + 1 : -1;
	  }
	  var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
	  if (jumpOffset) {
	    var value = char - exports.JUMP_OFFSET_BASE - jumpOffset;
	    return value < 0 || value > branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
	  }
	  // Binary search for the character.
	  var lo = nodeIdx;
	  var hi = lo + branchCount - 1;
	  while (lo <= hi) {
	    var mid = lo + hi >>> 1;
	    var midVal = decodeTree[mid];
	    if (midVal < char) {
	      lo = mid + 1;
	    } else if (midVal > char) {
	      hi = mid - 1;
	    } else {
	      return decodeTree[mid + branchCount];
	    }
	  }
	  return -1;
	}
	exports.determineBranch = determineBranch;
	var htmlDecoder = getDecoder(decode_data_html_1.default);
	var xmlDecoder = getDecoder(decode_data_xml_1.default);
	function decodeHTML(str) {
	  return htmlDecoder(str, false);
	}
	exports.decodeHTML = decodeHTML;
	function decodeHTMLStrict(str) {
	  return htmlDecoder(str, true);
	}
	exports.decodeHTMLStrict = decodeHTMLStrict;
	function decodeXML(str) {
	  return xmlDecoder(str, true);
	}
	exports.decodeXML = decodeXML;
} (decode));

var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(Tokenizer$1, "__esModule", {
  value: true
});
var decode_codepoint_1 = __importDefault$1(decode_codepoint);
var decode_1 = decode;
function isWhitespace$1(c) {
  return c === 32 /* Space */ || c === 10 /* NewLine */ || c === 9 /* Tab */ || c === 12 /* FormFeed */ || c === 13 /* CarriageReturn */;
}

function isEndOfTagSection(c) {
  return c === 47 /* Slash */ || c === 62 /* Gt */ || isWhitespace$1(c);
}
function isNumber$2(c) {
  return c >= 48 /* Zero */ && c <= 57 /* Nine */;
}

function isASCIIAlpha(c) {
  return c >= 97 /* LowerA */ && c <= 122 /* LowerZ */ || c >= 65 /* UpperA */ && c <= 90 /* UpperZ */;
}
/**
 * Sequences used to match longer strings.
 *
 * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
 * sequences with an increased offset.
 */
var Sequences = {
  Cdata: new Uint16Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),
  CdataEnd: new Uint16Array([0x5d, 0x5d, 0x3e]),
  CommentEnd: new Uint16Array([0x2d, 0x2d, 0x3e]),
  ScriptEnd: new Uint16Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),
  StyleEnd: new Uint16Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),
  TitleEnd: new Uint16Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]) // `</title`
};

var Tokenizer = /** @class */function () {
  function Tokenizer(_a, cbs) {
    var _b = _a.xmlMode,
      xmlMode = _b === void 0 ? false : _b,
      _c = _a.decodeEntities,
      decodeEntities = _c === void 0 ? true : _c;
    this.cbs = cbs;
    /** The current state the tokenizer is in. */
    this._state = 1 /* Text */;
    /** The read buffer. */
    this.buffer = "";
    /** The beginning of the section that is currently being read. */
    this.sectionStart = 0;
    /** The index within the buffer that we are currently looking at. */
    this._index = 0;
    /**
     * Data that has already been processed will be removed from the buffer occasionally.
     * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.
     */
    this.bufferOffset = 0;
    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
    this.baseState = 1 /* Text */;
    /** For special parsing behavior inside of script and style tags. */
    this.isSpecial = false;
    /** Indicates whether the tokenizer has been paused. */
    this.running = true;
    /** Indicates whether the tokenizer has finished running / `.end` has been called. */
    this.ended = false;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.trieResult = null;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_1.xmlDecodeTree : decode_1.htmlDecodeTree;
  }
  Tokenizer.prototype.reset = function () {
    this._state = 1 /* Text */;
    this.buffer = "";
    this.sectionStart = 0;
    this._index = 0;
    this.bufferOffset = 0;
    this.baseState = 1 /* Text */;
    this.currentSequence = undefined;
    this.running = true;
    this.ended = false;
  };
  Tokenizer.prototype.write = function (chunk) {
    if (this.ended) return this.cbs.onerror(Error(".write() after done!"));
    this.buffer += chunk;
    this.parse();
  };
  Tokenizer.prototype.end = function (chunk) {
    if (this.ended) return this.cbs.onerror(Error(".end() after done!"));
    if (chunk) this.write(chunk);
    this.ended = true;
    if (this.running) this.finish();
  };
  Tokenizer.prototype.pause = function () {
    this.running = false;
  };
  Tokenizer.prototype.resume = function () {
    this.running = true;
    if (this._index < this.buffer.length) {
      this.parse();
    }
    if (this.ended) {
      this.finish();
    }
  };
  /**
   * The start of the current section.
   */
  Tokenizer.prototype.getAbsoluteSectionStart = function () {
    return this.sectionStart + this.bufferOffset;
  };
  /**
   * The current index within all of the written data.
   */
  Tokenizer.prototype.getAbsoluteIndex = function () {
    return this.bufferOffset + this._index;
  };
  Tokenizer.prototype.stateText = function (c) {
    if (c === 60 /* Lt */ || !this.decodeEntities && this.fastForwardTo(60 /* Lt */)) {
      if (this._index > this.sectionStart) {
        this.cbs.ontext(this.getSection());
      }
      this._state = 2 /* BeforeTagName */;
      this.sectionStart = this._index;
    } else if (this.decodeEntities && c === 38 /* Amp */) {
      this._state = 25 /* BeforeEntity */;
    }
  };

  Tokenizer.prototype.stateSpecialStartSequence = function (c) {
    var isEnd = this.sequenceIndex === this.currentSequence.length;
    var isMatch = isEnd ?
    // If we are at the end of the sequence, make sure the tag name has ended
    isEndOfTagSection(c) :
    // Otherwise, do a case-insensitive comparison
    (c | 0x20) === this.currentSequence[this.sequenceIndex];
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this._state = 3 /* InTagName */;
    this.stateInTagName(c);
  };
  /** Look for an end tag. For <title> tags, also decode entities. */
  Tokenizer.prototype.stateInSpecialTag = function (c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === 62 /* Gt */ || isWhitespace$1(c)) {
        var endOfText = this._index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          // Spoof the index so that reported locations match up.
          var actualIndex = this._index;
          this._index = endOfText;
          this.cbs.ontext(this.getSection());
          this._index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2; // Skip over the `</`
        this.stateInClosingTagName(c);
        return; // We are done; skip the rest of the function.
      }

      this.sequenceIndex = 0;
    }
    if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        // We have to parse entities in <title> tags.
        if (this.decodeEntities && c === 38 /* Amp */) {
          this._state = 25 /* BeforeEntity */;
        }
      } else if (this.fastForwardTo(60 /* Lt */)) {
        // Outside of <title> tags, we can fast-forward.
        this.sequenceIndex = 1;
      }
    } else {
      // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
      this.sequenceIndex = Number(c === 60 /* Lt */);
    }
  };

  Tokenizer.prototype.stateCDATASequence = function (c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this._state = 21 /* InCommentLike */;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this._index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this._state = 16 /* InDeclaration */;
      this.stateInDeclaration(c); // Reconsume the character
    }
  };
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  Tokenizer.prototype.fastForwardTo = function (c) {
    while (++this._index < this.buffer.length) {
      if (this.buffer.charCodeAt(this._index) === c) {
        return true;
      }
    }
    /*
     * We increment the index at the end of the `parse` loop,
     * so set it to `buffer.length - 1` here.
     *
     * TODO: Refactor `parse` to increment index before calling states.
     */
    this._index = this.buffer.length - 1;
    return false;
  };
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  Tokenizer.prototype.stateInCommentLike = function (c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        // Remove 2 trailing chars
        var section = this.buffer.slice(this.sectionStart, this._index - 2);
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(section);
        } else {
          this.cbs.oncomment(section);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this._index + 1;
        this._state = 1 /* Text */;
      }
    } else if (this.sequenceIndex === 0) {
      // Fast-forward to the first character of the sequence
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      // Allow long sequences, eg. --->, ]]]>
      this.sequenceIndex = 0;
    }
  };
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  Tokenizer.prototype.isTagStartChar = function (c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  };
  Tokenizer.prototype.startSpecial = function (sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this._state = 23 /* SpecialStartSequence */;
  };

  Tokenizer.prototype.stateBeforeTagName = function (c) {
    if (c === 33 /* ExclamationMark */) {
      this._state = 15 /* BeforeDeclaration */;
      this.sectionStart = this._index + 1;
    } else if (c === 63 /* Questionmark */) {
      this._state = 17 /* InProcessingInstruction */;
      this.sectionStart = this._index + 1;
    } else if (this.isTagStartChar(c)) {
      var lower = c | 0x20;
      this.sectionStart = this._index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this._state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? 22 /* BeforeSpecialS */ : 3 /* InTagName */;
      }
    } else if (c === 47 /* Slash */) {
      this._state = 5 /* BeforeClosingTagName */;
    } else {
      this._state = 1 /* Text */;
      this.stateText(c);
    }
  };
  Tokenizer.prototype.stateInTagName = function (c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.getSection());
      this.sectionStart = -1;
      this._state = 8 /* BeforeAttributeName */;
      this.stateBeforeAttributeName(c);
    }
  };
  Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
    if (isWhitespace$1(c)) ; else if (c === 62 /* Gt */) {
      this._state = 1 /* Text */;
    } else {
      this._state = this.isTagStartChar(c) ? 6 /* InClosingTagName */ : 20 /* InSpecialComment */;
      this.sectionStart = this._index;
    }
  };
  Tokenizer.prototype.stateInClosingTagName = function (c) {
    if (c === 62 /* Gt */ || isWhitespace$1(c)) {
      this.cbs.onclosetag(this.getSection());
      this.sectionStart = -1;
      this._state = 7 /* AfterClosingTagName */;
      this.stateAfterClosingTagName(c);
    }
  };
  Tokenizer.prototype.stateAfterClosingTagName = function (c) {
    // Skip everything until ">"
    if (c === 62 /* Gt */ || this.fastForwardTo(62 /* Gt */)) {
      this._state = 1 /* Text */;
      this.sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype.stateBeforeAttributeName = function (c) {
    if (c === 62 /* Gt */) {
      this.cbs.onopentagend();
      if (this.isSpecial) {
        this._state = 24 /* InSpecialTag */;
        this.sequenceIndex = 0;
      } else {
        this._state = 1 /* Text */;
      }

      this.baseState = this._state;
      this.sectionStart = this._index + 1;
    } else if (c === 47 /* Slash */) {
      this._state = 4 /* InSelfClosingTag */;
    } else if (!isWhitespace$1(c)) {
      this._state = 9 /* InAttributeName */;
      this.sectionStart = this._index;
    }
  };
  Tokenizer.prototype.stateInSelfClosingTag = function (c) {
    if (c === 62 /* Gt */) {
      this.cbs.onselfclosingtag();
      this._state = 1 /* Text */;
      this.baseState = 1 /* Text */;
      this.sectionStart = this._index + 1;
      this.isSpecial = false; // Reset special state, in case of self-closing special tags
    } else if (!isWhitespace$1(c)) {
      this._state = 8 /* BeforeAttributeName */;
      this.stateBeforeAttributeName(c);
    }
  };
  Tokenizer.prototype.stateInAttributeName = function (c) {
    if (c === 61 /* Eq */ || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.getSection());
      this.sectionStart = -1;
      this._state = 10 /* AfterAttributeName */;
      this.stateAfterAttributeName(c);
    }
  };
  Tokenizer.prototype.stateAfterAttributeName = function (c) {
    if (c === 61 /* Eq */) {
      this._state = 11 /* BeforeAttributeValue */;
    } else if (c === 47 /* Slash */ || c === 62 /* Gt */) {
      this.cbs.onattribend(undefined);
      this._state = 8 /* BeforeAttributeName */;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace$1(c)) {
      this.cbs.onattribend(undefined);
      this._state = 9 /* InAttributeName */;
      this.sectionStart = this._index;
    }
  };
  Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
    if (c === 34 /* DoubleQuote */) {
      this._state = 12 /* InAttributeValueDq */;
      this.sectionStart = this._index + 1;
    } else if (c === 39 /* SingleQuote */) {
      this._state = 13 /* InAttributeValueSq */;
      this.sectionStart = this._index + 1;
    } else if (!isWhitespace$1(c)) {
      this.sectionStart = this._index;
      this._state = 14 /* InAttributeValueNq */;
      this.stateInAttributeValueNoQuotes(c); // Reconsume token
    }
  };

  Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.getSection());
      this.sectionStart = -1;
      this.cbs.onattribend(String.fromCharCode(quote));
      this._state = 8 /* BeforeAttributeName */;
    } else if (this.decodeEntities && c === 38 /* Amp */) {
      this.baseState = this._state;
      this._state = 25 /* BeforeEntity */;
    }
  };

  Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
    this.handleInAttributeValue(c, 34 /* DoubleQuote */);
  };

  Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
    this.handleInAttributeValue(c, 39 /* SingleQuote */);
  };

  Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
    if (isWhitespace$1(c) || c === 62 /* Gt */) {
      this.cbs.onattribdata(this.getSection());
      this.sectionStart = -1;
      this.cbs.onattribend(null);
      this._state = 8 /* BeforeAttributeName */;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === 38 /* Amp */) {
      this.baseState = this._state;
      this._state = 25 /* BeforeEntity */;
    }
  };

  Tokenizer.prototype.stateBeforeDeclaration = function (c) {
    if (c === 91 /* OpeningSquareBracket */) {
      this._state = 19 /* CDATASequence */;
      this.sequenceIndex = 0;
    } else {
      this._state = c === 45 /* Dash */ ? 18 /* BeforeComment */ : 16 /* InDeclaration */;
    }
  };

  Tokenizer.prototype.stateInDeclaration = function (c) {
    if (c === 62 /* Gt */ || this.fastForwardTo(62 /* Gt */)) {
      this.cbs.ondeclaration(this.getSection());
      this._state = 1 /* Text */;
      this.sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype.stateInProcessingInstruction = function (c) {
    if (c === 62 /* Gt */ || this.fastForwardTo(62 /* Gt */)) {
      this.cbs.onprocessinginstruction(this.getSection());
      this._state = 1 /* Text */;
      this.sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype.stateBeforeComment = function (c) {
    if (c === 45 /* Dash */) {
      this._state = 21 /* InCommentLike */;
      this.currentSequence = Sequences.CommentEnd;
      // Allow short comments (eg. <!-->)
      this.sequenceIndex = 2;
      this.sectionStart = this._index + 1;
    } else {
      this._state = 16 /* InDeclaration */;
    }
  };

  Tokenizer.prototype.stateInSpecialComment = function (c) {
    if (c === 62 /* Gt */ || this.fastForwardTo(62 /* Gt */)) {
      this.cbs.oncomment(this.getSection());
      this._state = 1 /* Text */;
      this.sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype.stateBeforeSpecialS = function (c) {
    var lower = c | 0x20;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this._state = 3 /* InTagName */;
      this.stateInTagName(c); // Consume the token again
    }
  };

  Tokenizer.prototype.stateBeforeEntity = function (c) {
    // Start excess with 1 to include the '&'
    this.entityExcess = 1;
    if (c === 35 /* Num */) {
      this._state = 26 /* BeforeNumericEntity */;
    } else if (c === 38 /* Amp */) ; else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.trieResult = null;
      this._state = 27 /* InNamedEntity */;
      this.stateInNamedEntity(c);
    }
  };
  Tokenizer.prototype.stateInNamedEntity = function (c) {
    this.entityExcess += 1;
    this.trieIndex = (0, decode_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this._index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    // If the branch is a value, store it and continue
    if (this.trieCurrent & decode_1.BinTrieFlags.HAS_VALUE) {
      // If we have a legacy entity while parsing strictly, just skip the number of bytes
      if (!this.allowLegacyEntity() && c !== 59 /* Semi */) {
        // No need to consider multi-byte values, as the legacy entity is always a single byte
        this.trieIndex += 1;
      } else {
        // Add 1 as we have already incremented the excess
        var entityStart = this._index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.buffer.substring(this.sectionStart, entityStart));
        }
        // If this is a surrogate pair, combine the higher bits from the node with the next byte
        this.trieResult = this.trieCurrent & decode_1.BinTrieFlags.MULTI_BYTE ? String.fromCharCode(this.entityTrie[++this.trieIndex], this.entityTrie[++this.trieIndex]) : String.fromCharCode(this.entityTrie[++this.trieIndex]);
        this.entityExcess = 0;
        this.sectionStart = this._index + 1;
      }
    }
  };
  Tokenizer.prototype.emitNamedEntity = function () {
    if (this.trieResult) {
      this.emitPartial(this.trieResult);
    }
    this._state = this.baseState;
  };
  Tokenizer.prototype.stateBeforeNumericEntity = function (c) {
    if ((c | 0x20) === 120 /* LowerX */) {
      this.entityExcess++;
      this._state = 29 /* InHexEntity */;
    } else {
      this._state = 28 /* InNumericEntity */;
      this.stateInNumericEntity(c);
    }
  };
  Tokenizer.prototype.decodeNumericEntity = function (base, strict) {
    var entityStart = this._index - this.entityExcess - 1;
    var numberStart = entityStart + 2 + (base >> 4);
    if (numberStart !== this._index) {
      // Emit leading data if any
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.buffer.substring(this.sectionStart, entityStart));
      }
      // Parse entity
      var entity = this.buffer.substring(numberStart, this._index);
      var parsed = parseInt(entity, base);
      this.emitPartial((0, decode_codepoint_1.default)(parsed));
      this.sectionStart = this._index + Number(strict);
    }
    this._state = this.baseState;
  };
  Tokenizer.prototype.stateInNumericEntity = function (c) {
    if (c === 59 /* Semi */) {
      this.decodeNumericEntity(10, true);
    } else if (!isNumber$2(c)) {
      if (this.allowLegacyEntity()) {
        this.decodeNumericEntity(10, false);
      } else {
        this._state = this.baseState;
      }
      this._index--;
    } else {
      this.entityExcess++;
    }
  };
  Tokenizer.prototype.stateInHexEntity = function (c) {
    if (c === 59 /* Semi */) {
      this.decodeNumericEntity(16, true);
    } else if ((c < 97 /* LowerA */ || c > 102 /* LowerF */) && (c < 65 /* UpperA */ || c > 70 /* UpperF */) && !isNumber$2(c)) {
      if (this.allowLegacyEntity()) {
        this.decodeNumericEntity(16, false);
      } else {
        this._state = this.baseState;
      }
      this._index--;
    } else {
      this.entityExcess++;
    }
  };
  Tokenizer.prototype.allowLegacyEntity = function () {
    return !this.xmlMode && (this.baseState === 1 /* Text */ || this.baseState === 24 /* InSpecialTag */);
  };
  /**
   * Remove data that has already been consumed from the buffer.
   */
  Tokenizer.prototype.cleanup = function () {
    // If we are inside of text, emit what we already have.
    if (this.running && this.sectionStart !== this._index && (this._state === 1 /* Text */ || this._state === 24 /* InSpecialTag */ && this.sequenceIndex === 0)) {
      // TODO: We could emit attribute data here as well.
      this.cbs.ontext(this.buffer.substr(this.sectionStart));
      this.sectionStart = this._index;
    }
    var start = this.sectionStart < 0 ? this._index : this.sectionStart;
    this.buffer = start === this.buffer.length ? "" : this.buffer.substr(start);
    this._index -= start;
    this.bufferOffset += start;
    if (this.sectionStart > 0) {
      this.sectionStart = 0;
    }
  };
  Tokenizer.prototype.shouldContinue = function () {
    return this._index < this.buffer.length && this.running;
  };
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  Tokenizer.prototype.parse = function () {
    while (this.shouldContinue()) {
      var c = this.buffer.charCodeAt(this._index);
      if (this._state === 1 /* Text */) {
        this.stateText(c);
      } else if (this._state === 23 /* SpecialStartSequence */) {
        this.stateSpecialStartSequence(c);
      } else if (this._state === 24 /* InSpecialTag */) {
        this.stateInSpecialTag(c);
      } else if (this._state === 19 /* CDATASequence */) {
        this.stateCDATASequence(c);
      } else if (this._state === 12 /* InAttributeValueDq */) {
        this.stateInAttributeValueDoubleQuotes(c);
      } else if (this._state === 9 /* InAttributeName */) {
        this.stateInAttributeName(c);
      } else if (this._state === 21 /* InCommentLike */) {
        this.stateInCommentLike(c);
      } else if (this._state === 20 /* InSpecialComment */) {
        this.stateInSpecialComment(c);
      } else if (this._state === 8 /* BeforeAttributeName */) {
        this.stateBeforeAttributeName(c);
      } else if (this._state === 3 /* InTagName */) {
        this.stateInTagName(c);
      } else if (this._state === 6 /* InClosingTagName */) {
        this.stateInClosingTagName(c);
      } else if (this._state === 2 /* BeforeTagName */) {
        this.stateBeforeTagName(c);
      } else if (this._state === 10 /* AfterAttributeName */) {
        this.stateAfterAttributeName(c);
      } else if (this._state === 13 /* InAttributeValueSq */) {
        this.stateInAttributeValueSingleQuotes(c);
      } else if (this._state === 11 /* BeforeAttributeValue */) {
        this.stateBeforeAttributeValue(c);
      } else if (this._state === 5 /* BeforeClosingTagName */) {
        this.stateBeforeClosingTagName(c);
      } else if (this._state === 7 /* AfterClosingTagName */) {
        this.stateAfterClosingTagName(c);
      } else if (this._state === 22 /* BeforeSpecialS */) {
        this.stateBeforeSpecialS(c);
      } else if (this._state === 14 /* InAttributeValueNq */) {
        this.stateInAttributeValueNoQuotes(c);
      } else if (this._state === 4 /* InSelfClosingTag */) {
        this.stateInSelfClosingTag(c);
      } else if (this._state === 16 /* InDeclaration */) {
        this.stateInDeclaration(c);
      } else if (this._state === 15 /* BeforeDeclaration */) {
        this.stateBeforeDeclaration(c);
      } else if (this._state === 18 /* BeforeComment */) {
        this.stateBeforeComment(c);
      } else if (this._state === 17 /* InProcessingInstruction */) {
        this.stateInProcessingInstruction(c);
      } else if (this._state === 27 /* InNamedEntity */) {
        this.stateInNamedEntity(c);
      } else if (this._state === 25 /* BeforeEntity */) {
        this.stateBeforeEntity(c);
      } else if (this._state === 29 /* InHexEntity */) {
        this.stateInHexEntity(c);
      } else if (this._state === 28 /* InNumericEntity */) {
        this.stateInNumericEntity(c);
      } else {
        // `this._state === State.BeforeNumericEntity`
        this.stateBeforeNumericEntity(c);
      }
      this._index++;
    }
    this.cleanup();
  };
  Tokenizer.prototype.finish = function () {
    if (this._state === 27 /* InNamedEntity */) {
      this.emitNamedEntity();
    }
    // If there is remaining data, emit it in a reasonable way
    if (this.sectionStart < this._index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  };
  /** Handle any trailing data. */
  Tokenizer.prototype.handleTrailingData = function () {
    var data = this.buffer.substr(this.sectionStart);
    if (this._state === 21 /* InCommentLike */) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(data);
      } else {
        this.cbs.oncomment(data);
      }
    } else if (this._state === 28 /* InNumericEntity */ && this.allowLegacyEntity()) {
      this.decodeNumericEntity(10, false);
      // All trailing data will have been consumed
    } else if (this._state === 29 /* InHexEntity */ && this.allowLegacyEntity()) {
      this.decodeNumericEntity(16, false);
      // All trailing data will have been consumed
    } else if (this._state === 3 /* InTagName */ || this._state === 8 /* BeforeAttributeName */ || this._state === 11 /* BeforeAttributeValue */ || this._state === 10 /* AfterAttributeName */ || this._state === 9 /* InAttributeName */ || this._state === 13 /* InAttributeValueSq */ || this._state === 12 /* InAttributeValueDq */ || this._state === 14 /* InAttributeValueNq */ || this._state === 6 /* InClosingTagName */) ; else {
      this.cbs.ontext(data);
    }
  };
  Tokenizer.prototype.getSection = function () {
    return this.buffer.substring(this.sectionStart, this._index);
  };
  Tokenizer.prototype.emitPartial = function (value) {
    if (this.baseState !== 1 /* Text */ && this.baseState !== 24 /* InSpecialTag */) {
      this.cbs.onattribdata(value);
    } else {
      this.cbs.ontext(value);
    }
  };
  return Tokenizer;
}();
Tokenizer$1.default = Tokenizer;

var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(Parser$3, "__esModule", {
  value: true
});
Parser$3.Parser = void 0;
var Tokenizer_1 = __importDefault(Tokenizer$1);
var formTags = new Set(["input", "option", "optgroup", "select", "button", "datalist", "textarea"]);
var pTag = new Set(["p"]);
var tableSectionTags = new Set(["thead", "tbody"]);
var ddtTags = new Set(["dd", "dt"]);
var rtpTags = new Set(["rt", "rp"]);
var openImpliesClose = new Map([["tr", new Set(["tr", "th", "td"])], ["th", new Set(["th"])], ["td", new Set(["thead", "th", "td"])], ["body", new Set(["head", "link", "script"])], ["li", new Set(["li"])], ["p", pTag], ["h1", pTag], ["h2", pTag], ["h3", pTag], ["h4", pTag], ["h5", pTag], ["h6", pTag], ["select", formTags], ["input", formTags], ["output", formTags], ["button", formTags], ["datalist", formTags], ["textarea", formTags], ["option", new Set(["option"])], ["optgroup", new Set(["optgroup", "option"])], ["dd", ddtTags], ["dt", ddtTags], ["address", pTag], ["article", pTag], ["aside", pTag], ["blockquote", pTag], ["details", pTag], ["div", pTag], ["dl", pTag], ["fieldset", pTag], ["figcaption", pTag], ["figure", pTag], ["footer", pTag], ["form", pTag], ["header", pTag], ["hr", pTag], ["main", pTag], ["nav", pTag], ["ol", pTag], ["pre", pTag], ["section", pTag], ["table", pTag], ["ul", pTag], ["rt", rtpTags], ["rp", rtpTags], ["tbody", tableSectionTags], ["tfoot", tableSectionTags]]);
var voidElements = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignobject", "desc", "title"]);
var reNameEnd = /\s|\//;
var Parser$2 = /** @class */function () {
  function Parser(cbs, options) {
    if (options === void 0) {
      options = {};
    }
    var _a, _b, _c, _d, _e;
    this.options = options;
    /** The start index of the last event. */
    this.startIndex = 0;
    /** The end index of the last event. */
    this.endIndex = 0;
    /**
     * Store the start index of the current open tag,
     * so we can update the start index for attributes.
     */
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
  }
  // Tokenizer event handlers
  /** @internal */
  Parser.prototype.ontext = function (data) {
    var _a, _b;
    var idx = this.tokenizer.getAbsoluteIndex();
    this.endIndex = idx - 1;
    (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
    this.startIndex = idx;
  };
  Parser.prototype.isVoidElement = function (name) {
    return !this.options.xmlMode && voidElements.has(name);
  };
  /** @internal */
  Parser.prototype.onopentagname = function (name) {
    this.endIndex = this.tokenizer.getAbsoluteIndex();
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this.emitOpenTag(name);
  };
  Parser.prototype.emitOpenTag = function (name) {
    var _a, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name;
    var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        var el = this.stack.pop();
        (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, el, true);
      }
    }
    if (!this.isVoidElement(name)) {
      this.stack.push(name);
      if (foreignContextElements.has(name)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
    if (this.cbs.onopentag) this.attribs = {};
  };
  Parser.prototype.endOpenTag = function (isImplied) {
    var _a, _b;
    this.startIndex = this.openTagStart;
    this.endIndex = this.tokenizer.getAbsoluteIndex();
    if (this.attribs) {
      (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  };
  /** @internal */
  Parser.prototype.onopentagend = function () {
    this.endOpenTag(false);
    // Set `startIndex` for next node
    this.startIndex = this.endIndex + 1;
  };
  /** @internal */
  Parser.prototype.onclosetag = function (name) {
    var _a, _b, _c, _d, _e, _f;
    this.endIndex = this.tokenizer.getAbsoluteIndex();
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name)) {
      var pos = this.stack.lastIndexOf(name);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          var count = this.stack.length - pos;
          while (count--) {
            // We know the stack has sufficient elements.
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else this.stack.length = pos;
      } else if (!this.options.xmlMode && name === "p") {
        this.emitOpenTag(name);
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name === "br") {
      // We can't go through `emitOpenTag` here, as `br` would be implicitly closed.
      (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name);
      (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, name, {}, true);
      (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, name, false);
    }
    // Set `startIndex` for next node
    this.startIndex = this.endIndex + 1;
  };
  /** @internal */
  Parser.prototype.onselfclosingtag = function () {
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      // Set `startIndex` for next node
      this.startIndex = this.endIndex + 1;
    } else {
      // Ignore the fact that the tag is self-closing.
      this.onopentagend();
    }
  };
  Parser.prototype.closeCurrentTag = function (isOpenImplied) {
    var _a, _b;
    var name = this.tagname;
    this.endOpenTag(isOpenImplied);
    // Self-closing tags will be on the top of the stack
    if (this.stack[this.stack.length - 1] === name) {
      // If the opening tag isn't implied, the closing tag has to be implied.
      (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
      this.stack.pop();
    }
  };
  /** @internal */
  Parser.prototype.onattribname = function (name) {
    this.startIndex = this.tokenizer.getAbsoluteSectionStart();
    if (this.lowerCaseAttributeNames) {
      name = name.toLowerCase();
    }
    this.attribname = name;
  };
  /** @internal */
  Parser.prototype.onattribdata = function (value) {
    this.attribvalue += value;
  };
  /** @internal */
  Parser.prototype.onattribend = function (quote) {
    var _a, _b;
    this.endIndex = this.tokenizer.getAbsoluteIndex();
    (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribname = "";
    this.attribvalue = "";
  };
  Parser.prototype.getInstructionName = function (value) {
    var idx = value.search(reNameEnd);
    var name = idx < 0 ? value : value.substr(0, idx);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  };
  /** @internal */
  Parser.prototype.ondeclaration = function (value) {
    this.endIndex = this.tokenizer.getAbsoluteIndex();
    if (this.cbs.onprocessinginstruction) {
      var name_1 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
    }
    // Set `startIndex` for next node
    this.startIndex = this.endIndex + 1;
  };
  /** @internal */
  Parser.prototype.onprocessinginstruction = function (value) {
    this.endIndex = this.tokenizer.getAbsoluteIndex();
    if (this.cbs.onprocessinginstruction) {
      var name_2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
    }
    // Set `startIndex` for next node
    this.startIndex = this.endIndex + 1;
  };
  /** @internal */
  Parser.prototype.oncomment = function (value) {
    var _a, _b, _c, _d;
    this.endIndex = this.tokenizer.getAbsoluteIndex();
    (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    // Set `startIndex` for next node
    this.startIndex = this.endIndex + 1;
  };
  /** @internal */
  Parser.prototype.oncdata = function (value) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = this.tokenizer.getAbsoluteIndex();
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[" + value + "]]");
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    // Set `startIndex` for next node
    this.startIndex = this.endIndex + 1;
  };
  /** @internal */
  Parser.prototype.onerror = function (err) {
    var _a, _b;
    (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  /** @internal */
  Parser.prototype.onend = function () {
    var _a, _b;
    if (this.cbs.onclosetag) {
      // Set the end index for all remaining tags
      this.endIndex = this.startIndex;
      for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true));
    }
    (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  Parser.prototype.reset = function () {
    var _a, _b, _c, _d;
    (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack = [];
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
  };
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  Parser.prototype.parseComplete = function (data) {
    this.reset();
    this.end(data);
  };
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  Parser.prototype.write = function (chunk) {
    this.tokenizer.write(chunk);
  };
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  Parser.prototype.end = function (chunk) {
    this.tokenizer.end(chunk);
  };
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  Parser.prototype.pause = function () {
    this.tokenizer.pause();
  };
  /**
   * Resumes parsing after `pause` was called.
   */
  Parser.prototype.resume = function () {
    this.tokenizer.resume();
  };
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  Parser.prototype.parseChunk = function (chunk) {
    this.write(chunk);
  };
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  Parser.prototype.done = function (chunk) {
    this.end(chunk);
  };
  return Parser;
}();
Parser$3.Parser = Parser$2;

var lib$1 = {};

var lib = {};

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib;
	hasRequiredLib$1 = 1;
	(function (exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
		/** Types of elements found in htmlparser2's DOM */
		var ElementType;
		(function (ElementType) {
		  /** Type for the root element of a document */
		  ElementType["Root"] = "root";
		  /** Type for Text */
		  ElementType["Text"] = "text";
		  /** Type for <? ... ?> */
		  ElementType["Directive"] = "directive";
		  /** Type for <!-- ... --> */
		  ElementType["Comment"] = "comment";
		  /** Type for <script> tags */
		  ElementType["Script"] = "script";
		  /** Type for <style> tags */
		  ElementType["Style"] = "style";
		  /** Type for Any tag */
		  ElementType["Tag"] = "tag";
		  /** Type for <![CDATA[ ... ]]> */
		  ElementType["CDATA"] = "cdata";
		  /** Type for <!doctype ...> */
		  ElementType["Doctype"] = "doctype";
		})(ElementType = exports.ElementType || (exports.ElementType = {}));
		/**
		 * Tests whether an element is a tag or not.
		 *
		 * @param elem Element to test
		 */
		function isTag(elem) {
		  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
		}
		exports.isTag = isTag;
		// Exports for backwards compatibility
		/** Type for the root element of a document */
		exports.Root = ElementType.Root;
		/** Type for Text */
		exports.Text = ElementType.Text;
		/** Type for <? ... ?> */
		exports.Directive = ElementType.Directive;
		/** Type for <!-- ... --> */
		exports.Comment = ElementType.Comment;
		/** Type for <script> tags */
		exports.Script = ElementType.Script;
		/** Type for <style> tags */
		exports.Style = ElementType.Style;
		/** Type for Any tag */
		exports.Tag = ElementType.Tag;
		/** Type for <![CDATA[ ... ]]> */
		exports.CDATA = ElementType.CDATA;
		/** Type for <!doctype ...> */
		exports.Doctype = ElementType.Doctype;
} (lib));
	return lib;
}

var node = {};

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;

	var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	var __assign = commonjsGlobal && commonjsGlobal.__assign || function () {
	  __assign = Object.assign || function (t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];
	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }
	    return t;
	  };
	  return __assign.apply(this, arguments);
	};
	Object.defineProperty(node, "__esModule", {
	  value: true
	});
	node.cloneNode = node.hasChildren = node.isDocument = node.isDirective = node.isComment = node.isText = node.isCDATA = node.isTag = node.Element = node.Document = node.NodeWithChildren = node.ProcessingInstruction = node.Comment = node.Text = node.DataNode = node.Node = void 0;
	var domelementtype_1 = requireLib$1();
	var nodeTypes = new Map([[domelementtype_1.ElementType.Tag, 1], [domelementtype_1.ElementType.Script, 1], [domelementtype_1.ElementType.Style, 1], [domelementtype_1.ElementType.Directive, 1], [domelementtype_1.ElementType.Text, 3], [domelementtype_1.ElementType.CDATA, 4], [domelementtype_1.ElementType.Comment, 8], [domelementtype_1.ElementType.Root, 9]]);
	/**
	 * This object will be used as the prototype for Nodes when creating a
	 * DOM-Level-1-compliant structure.
	 */
	var Node = /** @class */function () {
	  /**
	   *
	   * @param type The type of the node.
	   */
	  function Node(type) {
	    this.type = type;
	    /** Parent of the node */
	    this.parent = null;
	    /** Previous sibling */
	    this.prev = null;
	    /** Next sibling */
	    this.next = null;
	    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
	    this.startIndex = null;
	    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
	    this.endIndex = null;
	  }
	  Object.defineProperty(Node.prototype, "nodeType", {
	    // Read-only aliases
	    /**
	     * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
	     * node {@link type}.
	     */
	    get: function () {
	      var _a;
	      return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Node.prototype, "parentNode", {
	    // Read-write aliases for properties
	    /**
	     * Same as {@link parent}.
	     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	     */
	    get: function () {
	      return this.parent;
	    },
	    set: function (parent) {
	      this.parent = parent;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Node.prototype, "previousSibling", {
	    /**
	     * Same as {@link prev}.
	     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	     */
	    get: function () {
	      return this.prev;
	    },
	    set: function (prev) {
	      this.prev = prev;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Node.prototype, "nextSibling", {
	    /**
	     * Same as {@link next}.
	     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	     */
	    get: function () {
	      return this.next;
	    },
	    set: function (next) {
	      this.next = next;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  /**
	   * Clone this node, and optionally its children.
	   *
	   * @param recursive Clone child nodes as well.
	   * @returns A clone of the node.
	   */
	  Node.prototype.cloneNode = function (recursive) {
	    if (recursive === void 0) {
	      recursive = false;
	    }
	    return cloneNode(this, recursive);
	  };
	  return Node;
	}();
	node.Node = Node;
	/**
	 * A node that contains some data.
	 */
	var DataNode = /** @class */function (_super) {
	  __extends(DataNode, _super);
	  /**
	   * @param type The type of the node
	   * @param data The content of the data node
	   */
	  function DataNode(type, data) {
	    var _this = _super.call(this, type) || this;
	    _this.data = data;
	    return _this;
	  }
	  Object.defineProperty(DataNode.prototype, "nodeValue", {
	    /**
	     * Same as {@link data}.
	     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	     */
	    get: function () {
	      return this.data;
	    },
	    set: function (data) {
	      this.data = data;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  return DataNode;
	}(Node);
	node.DataNode = DataNode;
	/**
	 * Text within the document.
	 */
	var Text = /** @class */function (_super) {
	  __extends(Text, _super);
	  function Text(data) {
	    return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
	  }
	  return Text;
	}(DataNode);
	node.Text = Text;
	/**
	 * Comments within the document.
	 */
	var Comment = /** @class */function (_super) {
	  __extends(Comment, _super);
	  function Comment(data) {
	    return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
	  }
	  return Comment;
	}(DataNode);
	node.Comment = Comment;
	/**
	 * Processing instructions, including doc types.
	 */
	var ProcessingInstruction = /** @class */function (_super) {
	  __extends(ProcessingInstruction, _super);
	  function ProcessingInstruction(name, data) {
	    var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
	    _this.name = name;
	    return _this;
	  }
	  return ProcessingInstruction;
	}(DataNode);
	node.ProcessingInstruction = ProcessingInstruction;
	/**
	 * A `Node` that can have children.
	 */
	var NodeWithChildren = /** @class */function (_super) {
	  __extends(NodeWithChildren, _super);
	  /**
	   * @param type Type of the node.
	   * @param children Children of the node. Only certain node types can have children.
	   */
	  function NodeWithChildren(type, children) {
	    var _this = _super.call(this, type) || this;
	    _this.children = children;
	    return _this;
	  }
	  Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
	    // Aliases
	    /** First child of the node. */
	    get: function () {
	      var _a;
	      return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
	    /** Last child of the node. */
	    get: function () {
	      return this.children.length > 0 ? this.children[this.children.length - 1] : null;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
	    /**
	     * Same as {@link children}.
	     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	     */
	    get: function () {
	      return this.children;
	    },
	    set: function (children) {
	      this.children = children;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  return NodeWithChildren;
	}(Node);
	node.NodeWithChildren = NodeWithChildren;
	/**
	 * The root node of the document.
	 */
	var Document = /** @class */function (_super) {
	  __extends(Document, _super);
	  function Document(children) {
	    return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
	  }
	  return Document;
	}(NodeWithChildren);
	node.Document = Document;
	/**
	 * An element within the DOM.
	 */
	var Element = /** @class */function (_super) {
	  __extends(Element, _super);
	  /**
	   * @param name Name of the tag, eg. `div`, `span`.
	   * @param attribs Object mapping attribute names to attribute values.
	   * @param children Children of the node.
	   */
	  function Element(name, attribs, children, type) {
	    if (children === void 0) {
	      children = [];
	    }
	    if (type === void 0) {
	      type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
	    }
	    var _this = _super.call(this, type, children) || this;
	    _this.name = name;
	    _this.attribs = attribs;
	    return _this;
	  }
	  Object.defineProperty(Element.prototype, "tagName", {
	    // DOM Level 1 aliases
	    /**
	     * Same as {@link name}.
	     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	     */
	    get: function () {
	      return this.name;
	    },
	    set: function (name) {
	      this.name = name;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Element.prototype, "attributes", {
	    get: function () {
	      var _this = this;
	      return Object.keys(this.attribs).map(function (name) {
	        var _a, _b;
	        return {
	          name: name,
	          value: _this.attribs[name],
	          namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
	          prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
	        };
	      });
	    },
	    enumerable: false,
	    configurable: true
	  });
	  return Element;
	}(NodeWithChildren);
	node.Element = Element;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node is a `Element`, `false` otherwise.
	 */
	function isTag(node) {
	  return (0, domelementtype_1.isTag)(node);
	}
	node.isTag = isTag;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
	 */
	function isCDATA(node) {
	  return node.type === domelementtype_1.ElementType.CDATA;
	}
	node.isCDATA = isCDATA;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `Text`, `false` otherwise.
	 */
	function isText(node) {
	  return node.type === domelementtype_1.ElementType.Text;
	}
	node.isText = isText;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `Comment`, `false` otherwise.
	 */
	function isComment(node) {
	  return node.type === domelementtype_1.ElementType.Comment;
	}
	node.isComment = isComment;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
	 */
	function isDirective(node) {
	  return node.type === domelementtype_1.ElementType.Directive;
	}
	node.isDirective = isDirective;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
	 */
	function isDocument(node) {
	  return node.type === domelementtype_1.ElementType.Root;
	}
	node.isDocument = isDocument;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
	 */
	function hasChildren(node) {
	  return Object.prototype.hasOwnProperty.call(node, "children");
	}
	node.hasChildren = hasChildren;
	/**
	 * Clone a node, and optionally its children.
	 *
	 * @param recursive Clone child nodes as well.
	 * @returns A clone of the node.
	 */
	function cloneNode(node, recursive) {
	  if (recursive === void 0) {
	    recursive = false;
	  }
	  var result;
	  if (isText(node)) {
	    result = new Text(node.data);
	  } else if (isComment(node)) {
	    result = new Comment(node.data);
	  } else if (isTag(node)) {
	    var children = recursive ? cloneChildren(node.children) : [];
	    var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
	    children.forEach(function (child) {
	      return child.parent = clone_1;
	    });
	    if (node.namespace != null) {
	      clone_1.namespace = node.namespace;
	    }
	    if (node["x-attribsNamespace"]) {
	      clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
	    }
	    if (node["x-attribsPrefix"]) {
	      clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
	    }
	    result = clone_1;
	  } else if (isCDATA(node)) {
	    var children = recursive ? cloneChildren(node.children) : [];
	    var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
	    children.forEach(function (child) {
	      return child.parent = clone_2;
	    });
	    result = clone_2;
	  } else if (isDocument(node)) {
	    var children = recursive ? cloneChildren(node.children) : [];
	    var clone_3 = new Document(children);
	    children.forEach(function (child) {
	      return child.parent = clone_3;
	    });
	    if (node["x-mode"]) {
	      clone_3["x-mode"] = node["x-mode"];
	    }
	    result = clone_3;
	  } else if (isDirective(node)) {
	    var instruction = new ProcessingInstruction(node.name, node.data);
	    if (node["x-name"] != null) {
	      instruction["x-name"] = node["x-name"];
	      instruction["x-publicId"] = node["x-publicId"];
	      instruction["x-systemId"] = node["x-systemId"];
	    }
	    result = instruction;
	  } else {
	    throw new Error("Not implemented yet: ".concat(node.type));
	  }
	  result.startIndex = node.startIndex;
	  result.endIndex = node.endIndex;
	  if (node.sourceCodeLocation != null) {
	    result.sourceCodeLocation = node.sourceCodeLocation;
	  }
	  return result;
	}
	node.cloneNode = cloneNode;
	function cloneChildren(childs) {
	  var children = childs.map(function (child) {
	    return cloneNode(child, true);
	  });
	  for (var i = 1; i < children.length; i++) {
	    children[i].prev = children[i - 1];
	    children[i - 1].next = children[i];
	  }
	  return children;
	}
	return node;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib$1;
	hasRequiredLib = 1;
	(function (exports) {

		var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
		  if (k2 === undefined) k2 = k;
		  var desc = Object.getOwnPropertyDescriptor(m, k);
		  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		    desc = {
		      enumerable: true,
		      get: function () {
		        return m[k];
		      }
		    };
		  }
		  Object.defineProperty(o, k2, desc);
		} : function (o, m, k, k2) {
		  if (k2 === undefined) k2 = k;
		  o[k2] = m[k];
		});
		var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
		  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.DomHandler = void 0;
		var domelementtype_1 = requireLib$1();
		var node_1 = requireNode();
		__exportStar(requireNode(), exports);
		var reWhitespace = /\s+/g;
		// Default options
		var defaultOpts = {
		  normalizeWhitespace: false,
		  withStartIndices: false,
		  withEndIndices: false,
		  xmlMode: false
		};
		var DomHandler = /** @class */function () {
		  /**
		   * @param callback Called once parsing has completed.
		   * @param options Settings for the handler.
		   * @param elementCB Callback whenever a tag is closed.
		   */
		  function DomHandler(callback, options, elementCB) {
		    /** The elements of the DOM */
		    this.dom = [];
		    /** The root element for the DOM */
		    this.root = new node_1.Document(this.dom);
		    /** Indicated whether parsing has been completed. */
		    this.done = false;
		    /** Stack of open tags. */
		    this.tagStack = [this.root];
		    /** A data node that is still being written to. */
		    this.lastNode = null;
		    /** Reference to the parser instance. Used for location information. */
		    this.parser = null;
		    // Make it possible to skip arguments, for backwards-compatibility
		    if (typeof options === "function") {
		      elementCB = options;
		      options = defaultOpts;
		    }
		    if (typeof callback === "object") {
		      options = callback;
		      callback = undefined;
		    }
		    this.callback = callback !== null && callback !== void 0 ? callback : null;
		    this.options = options !== null && options !== void 0 ? options : defaultOpts;
		    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
		  }
		  DomHandler.prototype.onparserinit = function (parser) {
		    this.parser = parser;
		  };
		  // Resets the handler back to starting state
		  DomHandler.prototype.onreset = function () {
		    this.dom = [];
		    this.root = new node_1.Document(this.dom);
		    this.done = false;
		    this.tagStack = [this.root];
		    this.lastNode = null;
		    this.parser = null;
		  };
		  // Signals the handler that parsing is done
		  DomHandler.prototype.onend = function () {
		    if (this.done) return;
		    this.done = true;
		    this.parser = null;
		    this.handleCallback(null);
		  };
		  DomHandler.prototype.onerror = function (error) {
		    this.handleCallback(error);
		  };
		  DomHandler.prototype.onclosetag = function () {
		    this.lastNode = null;
		    var elem = this.tagStack.pop();
		    if (this.options.withEndIndices) {
		      elem.endIndex = this.parser.endIndex;
		    }
		    if (this.elementCB) this.elementCB(elem);
		  };
		  DomHandler.prototype.onopentag = function (name, attribs) {
		    var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
		    var element = new node_1.Element(name, attribs, undefined, type);
		    this.addNode(element);
		    this.tagStack.push(element);
		  };
		  DomHandler.prototype.ontext = function (data) {
		    var normalizeWhitespace = this.options.normalizeWhitespace;
		    var lastNode = this.lastNode;
		    if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
		      if (normalizeWhitespace) {
		        lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
		      } else {
		        lastNode.data += data;
		      }
		      if (this.options.withEndIndices) {
		        lastNode.endIndex = this.parser.endIndex;
		      }
		    } else {
		      if (normalizeWhitespace) {
		        data = data.replace(reWhitespace, " ");
		      }
		      var node = new node_1.Text(data);
		      this.addNode(node);
		      this.lastNode = node;
		    }
		  };
		  DomHandler.prototype.oncomment = function (data) {
		    if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
		      this.lastNode.data += data;
		      return;
		    }
		    var node = new node_1.Comment(data);
		    this.addNode(node);
		    this.lastNode = node;
		  };
		  DomHandler.prototype.oncommentend = function () {
		    this.lastNode = null;
		  };
		  DomHandler.prototype.oncdatastart = function () {
		    var text = new node_1.Text("");
		    var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
		    this.addNode(node);
		    text.parent = node;
		    this.lastNode = text;
		  };
		  DomHandler.prototype.oncdataend = function () {
		    this.lastNode = null;
		  };
		  DomHandler.prototype.onprocessinginstruction = function (name, data) {
		    var node = new node_1.ProcessingInstruction(name, data);
		    this.addNode(node);
		  };
		  DomHandler.prototype.handleCallback = function (error) {
		    if (typeof this.callback === "function") {
		      this.callback(error, this.dom);
		    } else if (error) {
		      throw error;
		    }
		  };
		  DomHandler.prototype.addNode = function (node) {
		    var parent = this.tagStack[this.tagStack.length - 1];
		    var previousSibling = parent.children[parent.children.length - 1];
		    if (this.options.withStartIndices) {
		      node.startIndex = this.parser.startIndex;
		    }
		    if (this.options.withEndIndices) {
		      node.endIndex = this.parser.endIndex;
		    }
		    parent.children.push(node);
		    if (previousSibling) {
		      node.prev = previousSibling;
		      previousSibling.next = node;
		    }
		    node.parent = parent;
		    this.lastNode = null;
		  };
		  return DomHandler;
		}();
		exports.DomHandler = DomHandler;
		exports.default = DomHandler;
} (lib$1));
	return lib$1;
}

/**
 * Sets root parent to null.
 *
 * @param  {Array<Comment|Element|ProcessingInstruction|Text>} nodes
 * @return {Array<Comment|Element|ProcessingInstruction|Text>}
 */

function unsetRootParent$1(nodes) {
  for (var index = 0, len = nodes.length; index < len; index++) {
    var node = nodes[index];
    node.parent = null;
  }
  return nodes;
}
var utilities = {
  unsetRootParent: unsetRootParent$1
};

var Parser$1 = Parser$3.Parser;
var DomHandler = requireLib().DomHandler;
var unsetRootParent = utilities.unsetRootParent;

/**
 * Parses HTML string to DOM nodes in Node.js.
 *
 * This is the same method as `require('htmlparser2').parseDOM`
 * https://github.com/fb55/htmlparser2/blob/v6.0.0/src/index.ts#L29-L41
 *
 * @param  {string}            html      - HTML markup.
 * @param  {DomHandlerOptions} [options] - Parser options (https://github.com/fb55/domhandler/tree/v4.0.0#readme).
 * @return {Array<Comment|Element|ProcessingInstruction|Text>} - DOM nodes.
 */
function HTMLDOMParser(html, options) {
  if (typeof html !== 'string') {
    throw new TypeError('First argument must be a string.');
  }
  if (html === '') {
    return [];
  }
  var handler = new DomHandler(undefined, options);
  new Parser$1(handler, options).end(html);
  return unsetRootParent(handler.dom);
}
var htmlToDom = HTMLDOMParser;

/**
 * When running on Node.js, use the server parser.
 * When bundling for the browser, use the client parser.
 *
 * @see {@link https://github.com/substack/node-browserify#browser-field}
 */

(function (module) {
	module.exports = htmlToDom;
} (htmlDomParser));

var domToReact = domToReact_1;
var attributesToProps = attributesToProps$2;
var htmlToDOM = htmlDomParser.exports;

// support backwards compatibility for ES Module
htmlToDOM = /* istanbul ignore next */
typeof htmlToDOM.default === 'function' ? htmlToDOM.default : htmlToDOM;
var domParserOptions = {
  lowerCaseAttributeNames: false
};

/**
 * Converts HTML string to React elements.
 *
 * @param {string} html - HTML string.
 * @param {object} [options] - Parser options.
 * @param {object} [options.htmlparser2] - htmlparser2 options.
 * @param {object} [options.library] - Library for React, Preact, etc.
 * @param {Function} [options.replace] - Replace method.
 * @returns {JSX.Element|JSX.Element[]|string} - React element(s), empty array, or string.
 */
function HTMLReactParser(html, options) {
  if (typeof html !== 'string') {
    throw new TypeError('First argument must be a string');
  }
  if (html === '') {
    return [];
  }
  options = options || {};
  return domToReact(htmlToDOM(html, options.htmlparser2 || domParserOptions), options);
}
HTMLReactParser.domToReact = domToReact;
HTMLReactParser.htmlToDOM = htmlToDOM;
HTMLReactParser.attributesToProps = attributesToProps;
HTMLReactParser.Element = requireLib().Element;

// support CommonJS and ES Modules
htmlReactParser.exports = HTMLReactParser;
htmlReactParser.exports.default = HTMLReactParser;

htmlReactParser.exports.domToReact;
htmlReactParser.exports.htmlToDOM;
htmlReactParser.exports.attributesToProps;
htmlReactParser.exports.Element;
var parse$4 = htmlReactParser.exports;

const Math$1 = dynamic$1(() => Promise.resolve().then(function () { return require('./Math-ab19be04.js'); }), {
  ssr: false
});
const RenderHtml = ({
  content
}) => {
  return parse$4(content);
};
const superscript = ({
  children
}) => /*#__PURE__*/React__default["default"].createElement("sup", null, children);
const NextLink = ({
  href,
  target,
  children
}) => {
  return /*#__PURE__*/React__default["default"].createElement(Link__default["default"], {
    href: href,
    passHref: true
  }, /*#__PURE__*/React__default["default"].createElement("a", {
    target: target
  }, children));
};
const Div = ({
  className,
  id = "",
  title = "",
  children
}) => {
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: className,
    id: id,
    title: title
  }, children);
};
const Iframe = ({
  className,
  width,
  height,
  src,
  children
}) => {
  return /*#__PURE__*/React__default["default"].createElement("iframe", {
    width: width,
    height: height,
    src: src
  });
};
function MarkdownParse({
  post
}) {
  const tokeniser = new Markdoc.Tokenizer({
    html: true,
    linkify: true
  });
  const tokens = tokeniser.tokenize(post.content);
  const ast = Markdoc.parse(tokens);
  const footnotedAst = footnoteParse(ast);
  const finalAst = uniqHead(footnotedAst);
  return Markdoc.transform(finalAst, {
    nodes: {
      fence,
      heading,
      image,
      link,
      footnoteItem,
      footnoteRef,
      html,
      sup
    },
    tags: {
      tabs,
      tab,
      button,
      callout,
      RenderHtml,
      superscript,
      link,
      div,
      iframe,
      math
    }
  });
}
function MarkdownRender({
  content
}) {
  return Markdoc.renderers.react(content, React__default["default"], {
    components: {
      Fence,
      Tabs,
      Tab,
      Button,
      Callout,
      RenderHtml,
      NextLink,
      Div,
      Iframe,
      Math: Math$1
    }
  });
}
const uniqHead = ast => {
  const uniqueHeadings = new Map([]);
  function generateID(children, attributes) {
    if (attributes.id && typeof attributes.id === "string") {
      return attributes.id;
    }
    const getBottom = children => {
      if (children?.attributes?.content) {
        if (uniqueHeadings.has(children.attributes.content)) {
          uniqueHeadings.set(children.attributes.content, uniqueHeadings.get(children.attributes.content) + 1);
          return `${children.attributes.content}-${uniqueHeadings.get(children.attributes.content)}`;
        } else {
          uniqueHeadings.set(children.attributes.content, 0);
          return children.attributes.content;
        }
      } else if (children[0]?.children) {
        return children[0]?.children.flatMap(child => getBottom(child));
      } else if (children?.children) {
        return children.children.flatMap(child => getBottom(child));
      } else {
        return children;
      }
    };
    return getBottom(children).join("").replace(/[=?!><:;,+#^|$&~"*@\.%/]/g, "").replace(/\s+/g, "-").toLowerCase();
  }
  let newAst = ast;
  newAst.children = ast.children.map(e => {
    if (e.type === "heading") {
      return new ast_default.Node(e.type, {
        ...e.attributes,
        id: generateID(e.children, e.attributes)
      }, e.children);
    } else {
      return e;
    }
  });
  return newAst;
};
const footnoteParse = partialAst => {
  const endNotePattern = /\[\^(\d+)\]:\s/m;
  const inlineFnPattern = /\[\^(\d+)\](?!:)/gm;
  function* getFootnoteItemNodes(nodes) {
    let results = [];
    let itemsProcessed = 0;
    for (const n of nodes) {
      itemsProcessed += 1;
      if (n.type !== "softbreak") results.push(n);
      if (n.type === "softbreak" || itemsProcessed === nodes.length) {
        yield results;
        results = [];
      }
    }
  }
  function findFootnoteContainerNode(ast) {
    const generator = ast.walk();
    let container;
    let match = false;
    for (const node of generator) {
      if (node.attributes.content && endNotePattern.test(node.attributes.content)) {
        match = true;
        generator.return();
      }
      if (node.type === "inline") container = node;
    }
    return match ? container : undefined;
  }
  function processFootnotes(ast) {
    // Get a refrence to the node containing endNotes; if not present, early return
    const fnContainerNode = findFootnoteContainerNode(ast);
    if (!fnContainerNode) return;
    // We have footnotes, so create a new list node which will contain the list of endNotes
    const fnList = new ast_default.Node("list", {
      ordered: true,
      class: "footnotes"
    });
    // Get the children nodes for each footnote item
    const fnItems = getFootnoteItemNodes(fnContainerNode.children);
    for (const fn of fnItems) {
      const token = endNotePattern.exec(fn[0].attributes.content);
      if (token) {
        // Remove the markdown footnote syntax (e.g. [^1]) from the string
        fn[0].attributes.content = fn[0].attributes.content.replace(token[0], "");
        // Create a new footnote item and append to the fnList
        const id = token[1];
        const fnItem = new ast_default.Node("footnoteItem", {
          id: `fn${id}`,
          href: `#fnref${id}`
        }, fn);
        fnList.push(fnItem);
      }
    }
    ast.children.pop(); // remove the last paragraph in the doc being replaced by the fnList
    ast.push(fnList);
  }
  function processFootnoteRefs(ast) {
    let parent = ast;
    for (const node of ast.walk()) {
      if (node.attributes.content) {
        // Check if there's a footnote ref token
        const token = inlineFnPattern.exec(node.attributes.content);
        if (token) {
          // Break the string where the foonote ref is, assign first part of string to the current node content
          const [prevText, nextText] = node.attributes.content.split(token[0]);
          node.attributes.content = prevText;

          // Create a footnote node and insert it in the tree
          const id = token[1];
          const fn = new ast_default.Node("footnoteRef", {
            id: `fnref${id}`,
            href: `#fn${id}`,
            label: `${id}`
          });
          parent.push(fn);

          // Create a text node for the text which follows after the footnote and insert it in the tree
          const next = new ast_default.Node("text", {
            content: nextText
          });
          parent.push(next);
        }
      }
      // If the node is of inline type, update parent
      if (node.type == "inline") parent = node;
    }
  }
  processFootnoteRefs(partialAst);
  processFootnotes(partialAst);
  return partialAst;
};
const Markdown = {
  parse: MarkdownParse,
  render: MarkdownRender
};

var toString = Object.prototype.toString;
var kindOf = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';
  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }
  if (isArray(val)) return 'array';
  if (isBuffer$1(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate$1(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';
  switch (ctorName(val)) {
    case 'Symbol':
      return 'symbol';
    case 'Promise':
      return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap':
      return 'weakmap';
    case 'WeakSet':
      return 'weakset';
    case 'Map':
      return 'map';
    case 'Set':
      return 'set';

    // 8-bit typed arrays
    case 'Int8Array':
      return 'int8array';
    case 'Uint8Array':
      return 'uint8array';
    case 'Uint8ClampedArray':
      return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array':
      return 'int16array';
    case 'Uint16Array':
      return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array':
      return 'int32array';
    case 'Uint32Array':
      return 'uint32array';
    case 'Float32Array':
      return 'float32array';
    case 'Float64Array':
      return 'float64array';
  }
  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString.call(val);
  switch (type) {
    case '[object Object]':
      return 'object';
    // iterators
    case '[object Map Iterator]':
      return 'mapiterator';
    case '[object Set Iterator]':
      return 'setiterator';
    case '[object String Iterator]':
      return 'stringiterator';
    case '[object Array Iterator]':
      return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};
function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}
function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}
function isError(val) {
  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
}
function isDate$1(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
}
function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string' && typeof val.ignoreCase === 'boolean' && typeof val.multiline === 'boolean' && typeof val.global === 'boolean';
}
function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}
function isGeneratorObj(val) {
  return typeof val.throw === 'function' && typeof val.return === 'function' && typeof val.next === 'function';
}
function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer$1(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}

/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

var isExtendable = function isExtendable(val) {
  return typeof val !== 'undefined' && val !== null && (typeof val === 'object' || typeof val === 'function');
};

var isObject$1 = isExtendable;
var extendShallow = function extend(o /*, objects*/) {
  if (!isObject$1(o)) {
    o = {};
  }
  var len = arguments.length;
  for (var i = 1; i < len; i++) {
    var obj = arguments[i];
    if (isObject$1(obj)) {
      assign(o, obj);
    }
  }
  return o;
};
function assign(a, b) {
  for (var key in b) {
    if (hasOwn(b, key)) {
      a[key] = b[key];
    }
  }
}

/**
 * Returns true if the given `key` is an own property of `obj`.
 */

function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

var typeOf$2 = kindOf;
var extend$1 = extendShallow;

/**
 * Parse sections in `input` with the given `options`.
 *
 * ```js
 * var sections = require('{%= name %}');
 * var result = sections(input, options);
 * // { content: 'Content before sections', sections: [] }
 * ```
 * @param {String|Buffer|Object} `input` If input is an object, it's `content` property must be a string or buffer.
 * @param {Object} options
 * @return {Object} Returns an object with a `content` string and an array of `sections` objects.
 * @api public
 */

var sectionMatter = function (input, options) {
  if (typeof options === 'function') {
    options = {
      parse: options
    };
  }
  var file = toObject(input);
  var defaults = {
    section_delimiter: '---',
    parse: identity
  };
  var opts = extend$1({}, defaults, options);
  var delim = opts.section_delimiter;
  var lines = file.content.split(/\r?\n/);
  var sections = null;
  var section = createSection();
  var content = [];
  var stack = [];
  function initSections(val) {
    file.content = val;
    sections = [];
    content = [];
  }
  function closeSection(val) {
    if (stack.length) {
      section.key = getKey(stack[0], delim);
      section.content = val;
      opts.parse(section, sections);
      sections.push(section);
      section = createSection();
      content = [];
      stack = [];
    }
  }
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var len = stack.length;
    var ln = line.trim();
    if (isDelimiter(ln, delim)) {
      if (ln.length === 3 && i !== 0) {
        if (len === 0 || len === 2) {
          content.push(line);
          continue;
        }
        stack.push(ln);
        section.data = content.join('\n');
        content = [];
        continue;
      }
      if (sections === null) {
        initSections(content.join('\n'));
      }
      if (len === 2) {
        closeSection(content.join('\n'));
      }
      stack.push(ln);
      continue;
    }
    content.push(line);
  }
  if (sections === null) {
    initSections(content.join('\n'));
  } else {
    closeSection(content.join('\n'));
  }
  file.sections = sections;
  return file;
};
function isDelimiter(line, delim) {
  if (line.slice(0, delim.length) !== delim) {
    return false;
  }
  if (line.charAt(delim.length + 1) === delim.slice(-1)) {
    return false;
  }
  return true;
}
function toObject(input) {
  if (typeOf$2(input) !== 'object') {
    input = {
      content: input
    };
  }
  if (typeof input.content !== 'string' && !isBuffer(input.content)) {
    throw new TypeError('expected a buffer or string');
  }
  input.content = input.content.toString();
  input.sections = [];
  return input;
}
function getKey(val, delim) {
  return val ? val.slice(delim.length).trim() : '';
}
function createSection() {
  return {
    key: '',
    data: '',
    content: ''
  };
}
function identity(val) {
  return val;
}
function isBuffer(val) {
  if (val && val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}

var engines$2 = {exports: {}};

var jsYaml$1 = {};

var loader$1 = {};

var common$6 = {};

function isNothing(subject) {
  return typeof subject === 'undefined' || subject === null;
}
function isObject(subject) {
  return typeof subject === 'object' && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = '',
    cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
common$6.isNothing = isNothing;
common$6.isObject = isObject;
common$6.toArray = toArray;
common$6.repeat = repeat;
common$6.isNegativeZero = isNegativeZero;
common$6.extend = extend;

function YAMLException$4(reason, mark) {
  // Super constructor
  Error.call(this);
  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = new Error().stack || '';
  }
}

// Inherit from Error
YAMLException$4.prototype = Object.create(Error.prototype);
YAMLException$4.prototype.constructor = YAMLException$4;
YAMLException$4.prototype.toString = function toString(compact) {
  var result = this.name + ': ';
  result += this.reason || '(unknown reason)';
  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }
  return result;
};
var exception = YAMLException$4;

var common$5 = common$6;
function Mark$1(name, buffer, position, line, column) {
  this.name = name;
  this.buffer = buffer;
  this.position = position;
  this.line = line;
  this.column = column;
}
Mark$1.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;
  if (!this.buffer) return null;
  indent = indent || 4;
  maxLength = maxLength || 75;
  head = '';
  start = this.position;
  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > maxLength / 2 - 1) {
      head = ' ... ';
      start += 5;
      break;
    }
  }
  tail = '';
  end = this.position;
  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > maxLength / 2 - 1) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }
  snippet = this.buffer.slice(start, end);
  return common$5.repeat(' ', indent) + head + snippet + tail + '\n' + common$5.repeat(' ', indent + this.position - start + head.length) + '^';
};
Mark$1.prototype.toString = function toString(compact) {
  var snippet,
    where = '';
  if (this.name) {
    where += 'in "' + this.name + '" ';
  }
  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
  if (!compact) {
    snippet = this.getSnippet();
    if (snippet) {
      where += ':\n' + snippet;
    }
  }
  return where;
};
var mark = Mark$1;

var YAMLException$3 = exception;
var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];
var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];
function compileStyleAliases(map) {
  var result = {};
  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$h(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag = tag;
  this.kind = options['kind'] || null;
  this.resolve = options['resolve'] || function () {
    return true;
  };
  this.construct = options['construct'] || function (data) {
    return data;
  };
  this.instanceOf = options['instanceOf'] || null;
  this.predicate = options['predicate'] || null;
  this.represent = options['represent'] || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$h;

/*eslint-disable max-len*/
var common$4 = common$6;
var YAMLException$2 = exception;
var Type$g = type;
function compileList(schema, name, result) {
  var exclude = [];
  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });
  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });
    result.push(currentType);
  });
  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}
function compileMap( /* lists... */
) {
  var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    },
    index,
    length;
  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$5(definition) {
  this.include = definition.include || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];
  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException$2('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });
  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
}
Schema$5.DEFAULT = null;
Schema$5.create = function createSchema() {
  var schemas, types;
  switch (arguments.length) {
    case 1:
      schemas = Schema$5.DEFAULT;
      types = arguments[0];
      break;
    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;
    default:
      throw new YAMLException$2('Wrong number of arguments for Schema.create function');
  }
  schemas = common$4.toArray(schemas);
  types = common$4.toArray(types);
  if (!schemas.every(function (schema) {
    return schema instanceof Schema$5;
  })) {
    throw new YAMLException$2('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }
  if (!types.every(function (type) {
    return type instanceof Type$g;
  })) {
    throw new YAMLException$2('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }
  return new Schema$5({
    include: schemas,
    explicit: types
  });
};
var schema = Schema$5;

var Type$f = type;
var str = new Type$f('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) {
    return data !== null ? data : '';
  }
});

var Type$e = type;
var seq = new Type$e('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) {
    return data !== null ? data : [];
  }
});

var Type$d = type;
var map = new Type$d('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) {
    return data !== null ? data : {};
  }
});

var Schema$4 = schema;
var failsafe = new Schema$4({
  explicit: [str, seq, map]
});

var Type$c = type;
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new Type$c('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () {
      return '~';
    },
    lowercase: function () {
      return 'null';
    },
    uppercase: function () {
      return 'NULL';
    },
    camelcase: function () {
      return 'Null';
    }
  },
  defaultStyle: 'lowercase'
});

var Type$b = type;
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
}
function constructYamlBoolean(data) {
  return data === 'true' || data === 'True' || data === 'TRUE';
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}
var bool = new Type$b('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) {
      return object ? 'true' : 'false';
    },
    uppercase: function (object) {
      return object ? 'TRUE' : 'FALSE';
    },
    camelcase: function (object) {
      return object ? 'True' : 'False';
    }
  },
  defaultStyle: 'lowercase'
});

var common$3 = common$6;
var Type$a = type;
function isHexCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */ || 0x41 /* A */ <= c && c <= 0x46 /* F */ || 0x61 /* a */ <= c && c <= 0x66 /* f */;
}

function isOctCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */;
}

function isDecCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */;
}

function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length,
    index = 0,
    hasDigits = false,
    ch;
  if (!max) return false;
  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }
  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }
    if (ch === 'x') {
      // base 16
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function constructYamlInteger(data) {
  var value = data,
    sign = 1,
    ch,
    base,
    digits = [];
  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }
  ch = value[0];
  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === '0') return 0;
  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }
  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });
    value = 0;
    base = 1;
    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });
    return sign * value;
  }
  return sign * parseInt(value, 10);
}
function isInteger$2(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common$3.isNegativeZero(object);
}
var int$1 = new Type$a('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger$2,
  represent: {
    binary: function (obj) {
      return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
    },
    octal: function (obj) {
      return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);
    },
    decimal: function (obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function (obj) {
      return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary: [2, 'bin'],
    octal: [8, 'oct'],
    decimal: [10, 'dec'],
    hexadecimal: [16, 'hex']
  }
});

var common$2 = common$6;
var Type$9 = type;
var YAML_FLOAT_PATTERN = new RegExp(
// 2.5e4, 2.5 and integers
'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
// .2e4, .2
// special case, seems not from spec
'|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
// 20:59
'|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
// .inf
'|[-+]?\\.(?:inf|Inf|INF)' +
// .nan
'|\\.(?:nan|NaN|NAN))$');
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) ||
  // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === '_') {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign, base, digits;
  value = data.replace(/_/g, '').toLowerCase();
  sign = value[0] === '-' ? -1 : 1;
  digits = [];
  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === '.inf') {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === '.nan') {
    return NaN;
  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });
    value = 0.0;
    base = 1;
    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });
    return sign * value;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case 'lowercase':
        return '.nan';
      case 'uppercase':
        return '.NAN';
      case 'camelcase':
        return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '.inf';
      case 'uppercase':
        return '.INF';
      case 'camelcase':
        return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '-.inf';
      case 'uppercase':
        return '-.INF';
      case 'camelcase':
        return '-.Inf';
    }
  } else if (common$2.isNegativeZero(object)) {
    return '-0.0';
  }
  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}
function isFloat$1(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common$2.isNegativeZero(object));
}
var float = new Type$9('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat$1,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

var Schema$3 = schema;
var json = new Schema$3({
  include: [failsafe],
  implicit: [_null, bool, int$1, float]
});

var Schema$2 = schema;
var core = new Schema$2({
  include: [json]
});

var Type$8 = type;
var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +
// [1] year
'-([0-9][0-9])' +
// [2] month
'-([0-9][0-9])$'); // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +
// [1] year
'-([0-9][0-9]?)' +
// [2] month
'-([0-9][0-9]?)' +
// [3] day
'(?:[Tt]|[ \\t]+)' +
// ...
'([0-9][0-9]?)' +
// [4] hour
':([0-9][0-9])' +
// [5] minute
':([0-9][0-9])' +
// [6] second
'(?:\\.([0-9]*))?' +
// [7] fraction
'(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' +
// [8] tz [9] tz_sign [10] tz_hour
'(?::([0-9][0-9]))?))?$'); // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match,
    year,
    month,
    day,
    hour,
    minute,
    second,
    fraction = 0,
    delta = null,
    tz_hour,
    tz_minute,
    date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +match[1];
  month = +match[2] - 1; // JS month starts with 0
  day = +match[3];
  if (!match[4]) {
    // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}
var timestamp = new Type$8('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

var Type$7 = type;
function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}
var merge = new Type$7('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

/*eslint-disable no-bitwise*/
var NodeBuffer;
try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require$1 = commonjsRequire;
  NodeBuffer = _require$1('buffer').Buffer;
} catch (__) {}
var Type$6 = type;

// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code,
    idx,
    bitlen = 0,
    max = data.length,
    map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;
    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx,
    tailbits,
    input = data.replace(/[\r\n=]/g, ''),
    // remove CR/LF & padding to simplify scan
    max = input.length,
    map = BASE64_MAP,
    bits = 0,
    result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 0xFF);
      result.push(bits >> 8 & 0xFF);
      result.push(bits & 0xFF);
    }
    bits = bits << 6 | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 0xFF);
    result.push(bits >> 8 & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 0xFF);
    result.push(bits >> 2 & 0xFF);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }
  return result;
}
function representYamlBinary(object /*, style*/) {
  var result = '',
    bits = 0,
    idx,
    tail,
    max = object.length,
    map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map[bits >> 18 & 0x3F];
      result += map[bits >> 12 & 0x3F];
      result += map[bits >> 6 & 0x3F];
      result += map[bits & 0x3F];
    }
    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;
  if (tail === 0) {
    result += map[bits >> 18 & 0x3F];
    result += map[bits >> 12 & 0x3F];
    result += map[bits >> 6 & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[bits >> 10 & 0x3F];
    result += map[bits >> 4 & 0x3F];
    result += map[bits << 2 & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[bits >> 2 & 0x3F];
    result += map[bits << 4 & 0x3F];
    result += map[64];
    result += map[64];
  }
  return result;
}
function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}
var binary = new Type$6('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

var Type$5 = type;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [],
    index,
    length,
    pair,
    pairKey,
    pairHasKey,
    object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== '[object Object]') return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new Type$5('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

var Type$4 = type;
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index,
    length,
    pair,
    keys,
    result,
    object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== '[object Object]') return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index,
    length,
    pair,
    keys,
    result,
    object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new Type$4('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

var Type$3 = type;
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key,
    object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new Type$3('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

var Schema$1 = schema;
var default_safe = new Schema$1({
  include: [core],
  implicit: [timestamp, merge],
  explicit: [binary, omap, pairs, set]
});

var Type$2 = type;
function resolveJavascriptUndefined() {
  return true;
}
function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}
function representJavascriptUndefined() {
  return '';
}
function isUndefined$1(object) {
  return typeof object === 'undefined';
}
var _undefined = new Type$2('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined$1,
  represent: representJavascriptUndefined
});

var Type$1 = type;
function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;
  var regexp = data,
    tail = /\/([gim]*)$/.exec(data),
    modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }
  return true;
}
function constructJavascriptRegExp(data) {
  var regexp = data,
    tail = /\/([gim]*)$/.exec(data),
    modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }
  return new RegExp(regexp, modifiers);
}
function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';
  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';
  return result;
}
function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}
var regexp = new Type$1('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = commonjsRequire;
  esprima = _require('esprima');
} catch (_) {
  /* eslint-disable no-redeclare */
  /* global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}
var Type = type;
function resolveJavascriptFunction(data) {
  if (data === null) return false;
  try {
    var source = '(' + data + ')',
      ast = esprima.parse(source, {
        range: true
      });
    if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
    ast = esprima.parse(source, {
      range: true
    }),
    params = [],
    body;
  if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
    throw new Error('Failed to resolve function');
  }
  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });
  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}
function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}
function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}
var _function = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

var Schema = schema;
var default_full = Schema.DEFAULT = new Schema({
  include: [default_safe],
  explicit: [_undefined, regexp, _function]
});

/*eslint-disable max-len,no-use-before-define*/
var common$1 = common$6;
var YAMLException$1 = exception;
var Mark = mark;
var DEFAULT_SAFE_SCHEMA$1 = default_safe;
var DEFAULT_FULL_SCHEMA$1 = default_full;
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 0x0A /* LF */ || c === 0x0D /* CR */;
}

function is_WHITE_SPACE(c) {
  return c === 0x09 /* Tab */ || c === 0x20 /* Space */;
}

function is_WS_OR_EOL(c) {
  return c === 0x09 /* Tab */ || c === 0x20 /* Space */ || c === 0x0A /* LF */ || c === 0x0D /* CR */;
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C /* , */ || c === 0x5B /* [ */ || c === 0x5D /* ] */ || c === 0x7B /* { */ || c === 0x7D /* } */;
}

function fromHexCode(c) {
  var lc;
  if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;
  if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
    return lc - 0x61 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 0x78 /* x */) {
    return 2;
  }
  if (c === 0x75 /* u */) {
    return 4;
  }
  if (c === 0x55 /* U */) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
    return c - 0x30;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return c === 0x30 /* 0 */ ? '\x00' : c === 0x61 /* a */ ? '\x07' : c === 0x62 /* b */ ? '\x08' : c === 0x74 /* t */ ? '\x09' : c === 0x09 /* Tab */ ? '\x09' : c === 0x6E /* n */ ? '\x0A' : c === 0x76 /* v */ ? '\x0B' : c === 0x66 /* f */ ? '\x0C' : c === 0x72 /* r */ ? '\x0D' : c === 0x65 /* e */ ? '\x1B' : c === 0x20 /* Space */ ? ' ' : c === 0x22 /* " */ ? '\x22' : c === 0x2F /* / */ ? '/' : c === 0x5C /* \ */ ? '\x5C' : c === 0x4E /* N */ ? '\x85' : c === 0x5F /* _ */ ? '\xA0' : c === 0x4C /* L */ ? '\u2028' : c === 0x50 /* P */ ? '\u2029' : '';
}
function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}
var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$2(input, options) {
  this.input = input;
  this.filename = options['filename'] || null;
  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA$1;
  this.onWarning = options['onWarning'] || null;
  this.legacy = options['legacy'] || false;
  this.json = options['json'] || false;
  this.listener = options['listener'] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
}

function generateError(state, message) {
  return new YAMLException$1(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }
    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common$1.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }
      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 0x0A /* LF */) {
    state.position++;
  } else if (ch === 0x0D /* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A /* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }
  state.line += 1;
  state.lineStart = state.position;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
    ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 0x23 /* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A /* LF */ && ch !== 0x0D /* CR */ && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 0x20 /* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position,
    ch;
  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D /* - */ || ch === 0x2E /* . */) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common$1.repeat('\n', count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
    following,
    captureStart,
    captureEnd,
    hasPendingContent,
    _line,
    _lineStart,
    _lineIndent,
    _kind = state.kind,
    _result = state.result,
    ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */ || ch === 0x26 /* & */ || ch === 0x2A /* * */ || ch === 0x21 /* ! */ || ch === 0x7C /* | */ || ch === 0x3E /* > */ || ch === 0x27 /* ' */ || ch === 0x22 /* " */ || ch === 0x25 /* % */ || ch === 0x40 /* @ */ || ch === 0x60 /* ` */) {
    return false;
  }
  if (ch === 0x3F /* ? */ || ch === 0x2D /* - */) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 0x3A /* : */) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 0x23 /* # */) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x27 /* ' */) {
    return false;
  }
  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27 /* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 0x27 /* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x22 /* " */) {
    return false;
  }
  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22 /* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 0x5C /* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, 'unknown escape sequence');
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true,
    _line,
    _tag = state.tag,
    _result,
    _anchor = state.anchor,
    following,
    terminator,
    isPair,
    isExplicitPair,
    isMapping,
    overridableKeys = {},
    keyNode,
    keyTag,
    valueNode,
    ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 0x5B /* [ */) {
    terminator = 0x5D; /* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B /* { */) {
    terminator = 0x7D; /* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 0x3F /* ? */) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x2C /* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, 'unexpected end of the stream within a flow collection');
}
function readBlockScalar(state, nodeIndent) {
  var captureStart,
    folding,
    chomping = CHOMPING_CLIP,
    didReadContent = false,
    detectedIndent = false,
    textIndent = nodeIndent,
    emptyLines = 0,
    atMoreIndented = false,
    tmp,
    ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 0x7C /* | */) {
    folding = false;
  } else if (ch === 0x3E /* > */) {
    folding = true;
  } else {
    return false;
  }
  state.kind = 'scalar';
  state.result = '';
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 0x2B /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 0x23 /* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {
      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {
      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

        // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common$1.repeat('\n', emptyLines + 1);

        // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) {
          // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

        // Several line breaks - perceive as different lines.
      } else {
        state.result += common$1.repeat('\n', emptyLines);
      }

      // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line,
    _tag = state.tag,
    _anchor = state.anchor,
    _result = [],
    following,
    detected = false,
    ch;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (ch !== 0x2D /* - */) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
    allowCompact,
    _line,
    _pos,
    _tag = state.tag,
    _anchor = state.anchor,
    _result = {},
    overridableKeys = {},
    keyTag = null,
    keyNode = null,
    valueNode = null,
    atExplicitKey = false,
    detected = false,
    ch;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F /* ? */ || ch === 0x3A /* : */) && is_WS_OR_EOL(following)) {
      if (ch === 0x3F /* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }
      state.position += 1;
      ch = following;

      //
      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
      //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 0x3A /* : */) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if (state.lineIndent > nodeIndent && ch !== 0) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position,
    isVerbatim = false,
    isNamed = false,
    tagHandle,
    tagName,
    ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x21 /* ! */) return false;
  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 0x3C /* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 0x21 /* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = '!';
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 0x3E /* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 0x21 /* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;
  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x26 /* & */) return false;
  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x2A /* * */) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
    allowBlockScalars,
    allowBlockCollections,
    indentStatus = 1,
    // 1: this>parent, 0: this=parent, -1: this<parent
    atNewLine = false,
    hasContent = false,
    typeIndex,
    typeQuantity,
    type,
    flowIndent,
    blockIndent;
  if (state.listener !== null) {
    state.listener('open', state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = '?';
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];
        if (type.resolve(state.result)) {
          // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];
      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }
      if (!type.resolve(state.result)) {
        // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }
  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position,
    _position,
    directiveName,
    directiveArgs,
    hasDirectives = false,
    ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 0x25 /* % */) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 0x23 /* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */ && state.input.charCodeAt(state.position + 1) === 0x2D /* - */ && state.input.charCodeAt(state.position + 2) === 0x2D /* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 0x2E /* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */ && input.charCodeAt(input.length - 1) !== 0x0D /* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }
  var state = new State$2(input, options);
  var nullpos = input.indexOf('\0');
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';
  while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== 'function') {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException$1('expected a single document in the stream, but found more');
}
function safeLoadAll(input, iterator, options) {
  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }
  return loadAll(input, iterator, common$1.extend({
    schema: DEFAULT_SAFE_SCHEMA$1
  }, options));
}
function safeLoad(input, options) {
  return load(input, common$1.extend({
    schema: DEFAULT_SAFE_SCHEMA$1
  }, options));
}
loader$1.loadAll = loadAll;
loader$1.load = load;
loader$1.safeLoadAll = safeLoadAll;
loader$1.safeLoad = safeLoad;

var dumper$1 = {};

/*eslint-disable no-use-before-define*/
var common = common$6;
var YAMLException = exception;
var DEFAULT_FULL_SCHEMA = default_full;
var DEFAULT_SAFE_SCHEMA = default_safe;
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_TAB = 0x09; /* Tab */
var CHAR_LINE_FEED = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */
var CHAR_SPACE = 0x20; /* Space */
var CHAR_EXCLAMATION = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE = 0x22; /* " */
var CHAR_SHARP = 0x23; /* # */
var CHAR_PERCENT = 0x25; /* % */
var CHAR_AMPERSAND = 0x26; /* & */
var CHAR_SINGLE_QUOTE = 0x27; /* ' */
var CHAR_ASTERISK = 0x2A; /* * */
var CHAR_COMMA$1 = 0x2C; /* , */
var CHAR_MINUS = 0x2D; /* - */
var CHAR_COLON$1 = 0x3A; /* : */
var CHAR_EQUALS$1 = 0x3D; /* = */
var CHAR_GREATER_THAN = 0x3E; /* > */
var CHAR_QUESTION = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */
var CHAR_VERTICAL_LINE = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0x00] = '\\0';
ESCAPE_SEQUENCES[0x07] = '\\a';
ESCAPE_SEQUENCES[0x08] = '\\b';
ESCAPE_SEQUENCES[0x09] = '\\t';
ESCAPE_SEQUENCES[0x0A] = '\\n';
ESCAPE_SEQUENCES[0x0B] = '\\v';
ESCAPE_SEQUENCES[0x0C] = '\\f';
ESCAPE_SEQUENCES[0x0D] = '\\r';
ESCAPE_SEQUENCES[0x1B] = '\\e';
ESCAPE_SEQUENCES[0x22] = '\\"';
ESCAPE_SEQUENCES[0x5C] = '\\\\';
ESCAPE_SEQUENCES[0x85] = '\\N';
ESCAPE_SEQUENCES[0xA0] = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';
var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];
function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;
  if (map === null) return {};
  result = {};
  keys = Object.keys(map);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);
    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];
    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }
  return '\\' + handle + common.repeat('0', length - string.length) + string;
}
function State$1(options) {
  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent = Math.max(1, options['indent'] || 2);
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys = options['sortKeys'] || false;
  this.lineWidth = options['lineWidth'] || 80;
  this.noRefs = options['noRefs'] || false;
  this.noCompatMode = options['noCompatMode'] || false;
  this.condenseFlow = options['condenseFlow'] || false;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = '';
  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
    position = 0,
    next = -1,
    result = '',
    line,
    length = string.length;
  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== '\n') result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}
function testImplicitResolving(state, str) {
  var index, length, type;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];
    if (type.resolve(str)) {
      return true;
    }
  }
  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF /* BOM */ || 0x10000 <= c && c <= 0x10FFFF;
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function isNsChar(c) {
  return isPrintable(c) && !isWhitespace(c)
  // byte-order-mark
  && c !== 0xFEFF
  // b-char
  && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c, prev) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
  // - c-flow-indicator
  && c !== CHAR_COMMA$1 && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
  // - ":" - "#"
  // /* An ns-char preceding */ "#"
  && c !== CHAR_COLON$1 && (c !== CHAR_SHARP || prev && isNsChar(prev));
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white
  // - (c-indicator ::=
  // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON$1 && c !== CHAR_COMMA$1 && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
  // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS$1 && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE
  // | “%” | “@” | “`”)
  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1,
  STYLE_SINGLE = 2,
  STYLE_LITERAL = 3,
  STYLE_FOLDED = 4,
  STYLE_DOUBLE = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
          // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }
    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
    // No block styles in flow mode.
    || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }
    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString$1(string) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }();
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip = string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : clip ? '' : '-';
  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1],
      line = match[2];
    moreIndented = line[0] === ' ';
    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0,
    end,
    curr = 0,
    next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while (match = breakRe.exec(line)) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = curr > start ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1; // derive start <= length-1
    }

    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString$1(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;
  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF /* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF /* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++;
        continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = '',
    _tag = state.tag,
    index,
    length;
  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = '[' + _result + ']';
}
function writeBlockSequence(state, level, object, compact) {
  var _result = '',
    _tag = state.tag,
    index,
    length;
  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result = '',
    _tag = state.tag,
    objectKeyList = Object.keys(object),
    index,
    length,
    objectKey,
    objectValue,
    pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';
    if (index !== 0) pairBuffer += ', ';
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';
    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');
    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = '{' + _result + '}';
}
function writeBlockMapping(state, level, object, compact) {
  var _result = '',
    _tag = state.tag,
    objectKeyList = Object.keys(object),
    index,
    length,
    objectKey,
    objectValue,
    explicitPair,
    pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';
    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }
    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];
    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
      state.tag = explicit ? type.tag : '?';
      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;
        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type = _toString.call(state.dump);
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type === '[object Object]' || type === '[object Array]',
    duplicateIndex,
    duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
      if (block && state.dump.length !== 0) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }
    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [],
    duplicatesIndexes = [],
    index,
    length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump(input, options) {
  options = options || {};
  var state = new State$1(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';
  return '';
}
function safeDump(input, options) {
  return dump(input, common.extend({
    schema: DEFAULT_SAFE_SCHEMA
  }, options));
}
dumper$1.dump = dump;
dumper$1.safeDump = safeDump;

var loader = loader$1;
var dumper = dumper$1;
function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}
jsYaml$1.Type = type;
jsYaml$1.Schema = schema;
jsYaml$1.FAILSAFE_SCHEMA = failsafe;
jsYaml$1.JSON_SCHEMA = json;
jsYaml$1.CORE_SCHEMA = core;
jsYaml$1.DEFAULT_SAFE_SCHEMA = default_safe;
jsYaml$1.DEFAULT_FULL_SCHEMA = default_full;
jsYaml$1.load = loader.load;
jsYaml$1.loadAll = loader.loadAll;
jsYaml$1.safeLoad = loader.safeLoad;
jsYaml$1.safeLoadAll = loader.safeLoadAll;
jsYaml$1.dump = dumper.dump;
jsYaml$1.safeDump = dumper.safeDump;
jsYaml$1.YAMLException = exception;

// Deprecated schema names from JS-YAML 2.0.x
jsYaml$1.MINIMAL_SCHEMA = failsafe;
jsYaml$1.SAFE_SCHEMA = default_safe;
jsYaml$1.DEFAULT_SCHEMA = default_full;

// Deprecated functions from JS-YAML 1.x.x
jsYaml$1.scan = deprecated('scan');
jsYaml$1.parse = deprecated('parse');
jsYaml$1.compose = deprecated('compose');
jsYaml$1.addConstructor = deprecated('addConstructor');

var yaml = jsYaml$1;
var jsYaml = yaml;

(function (module, exports) {

	const yaml = jsYaml;

	/**
	 * Default engines
	 */

	const engines = module.exports;

	/**
	 * YAML
	 */

	engines.yaml = {
	  parse: yaml.safeLoad.bind(yaml),
	  stringify: yaml.safeDump.bind(yaml)
	};

	/**
	 * JSON
	 */

	engines.json = {
	  parse: JSON.parse.bind(JSON),
	  stringify: function (obj, options) {
	    const opts = Object.assign({
	      replacer: null,
	      space: 2
	    }, options);
	    return JSON.stringify(obj, opts.replacer, opts.space);
	  }
	};

	/**
	 * JavaScript
	 */

	engines.javascript = {
	  parse: function parse(str, options, wrap) {
	    /* eslint no-eval: 0 */
	    try {
	      if (wrap !== false) {
	        str = '(function() {\nreturn ' + str.trim() + ';\n}());';
	      }
	      return eval(str) || {};
	    } catch (err) {
	      if (wrap !== false && /(unexpected|identifier)/i.test(err.message)) {
	        return parse(str, options, false);
	      }
	      throw new SyntaxError(err);
	    }
	  },
	  stringify: function () {
	    throw new Error('stringifying JavaScript is not supported');
	  }
	};
} (engines$2));

var utils$3 = {};

/*!
 * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var stripBomString = function (str) {
  if (typeof str === 'string' && str.charAt(0) === '\ufeff') {
    return str.slice(1);
  }
  return str;
};

(function (exports) {

	const stripBom = stripBomString;
	const typeOf = kindOf;
	exports.define = function (obj, key, val) {
	  Reflect.defineProperty(obj, key, {
	    enumerable: false,
	    configurable: true,
	    writable: true,
	    value: val
	  });
	};

	/**
	 * Returns true if `val` is a buffer
	 */

	exports.isBuffer = function (val) {
	  return typeOf(val) === 'buffer';
	};

	/**
	 * Returns true if `val` is an object
	 */

	exports.isObject = function (val) {
	  return typeOf(val) === 'object';
	};

	/**
	 * Cast `input` to a buffer
	 */

	exports.toBuffer = function (input) {
	  return typeof input === 'string' ? Buffer.from(input) : input;
	};

	/**
	 * Cast `val` to a string.
	 */

	exports.toString = function (input) {
	  if (exports.isBuffer(input)) return stripBom(String(input));
	  if (typeof input !== 'string') {
	    throw new TypeError('expected input to be a string or buffer');
	  }
	  return stripBom(input);
	};

	/**
	 * Cast `val` to an array.
	 */

	exports.arrayify = function (val) {
	  return val ? Array.isArray(val) ? val : [val] : [];
	};

	/**
	 * Returns true if `str` starts with `substr`.
	 */

	exports.startsWith = function (str, substr, len) {
	  if (typeof len !== 'number') len = substr.length;
	  return str.slice(0, len) === substr;
	};
} (utils$3));

const engines$1 = engines$2.exports;
const utils$2 = utils$3;
var defaults$4 = function (options) {
  const opts = Object.assign({}, options);

  // ensure that delimiters are an array
  opts.delimiters = utils$2.arrayify(opts.delims || opts.delimiters || '---');
  if (opts.delimiters.length === 1) {
    opts.delimiters.push(opts.delimiters[0]);
  }
  opts.language = (opts.language || opts.lang || 'yaml').toLowerCase();
  opts.engines = Object.assign({}, engines$1, opts.parsers, opts.engines);
  return opts;
};

var engine = function (name, options) {
  let engine = options.engines[name] || options.engines[aliase(name)];
  if (typeof engine === 'undefined') {
    throw new Error('gray-matter engine "' + name + '" is not registered');
  }
  if (typeof engine === 'function') {
    engine = {
      parse: engine
    };
  }
  return engine;
};
function aliase(name) {
  switch (name.toLowerCase()) {
    case 'js':
    case 'javascript':
      return 'javascript';
    case 'coffee':
    case 'coffeescript':
    case 'cson':
      return 'coffee';
    case 'yaml':
    case 'yml':
      return 'yaml';
    default:
      {
        return name;
      }
  }
}

const typeOf$1 = kindOf;
const getEngine$1 = engine;
const defaults$3 = defaults$4;
var stringify$4 = function (file, data, options) {
  if (data == null && options == null) {
    switch (typeOf$1(file)) {
      case 'object':
        data = file.data;
        options = {};
        break;
      case 'string':
        return file;
      default:
        {
          throw new TypeError('expected file to be a string or object');
        }
    }
  }
  const str = file.content;
  const opts = defaults$3(options);
  if (data == null) {
    if (!opts.data) return file;
    data = opts.data;
  }
  const language = file.language || opts.language;
  const engine = getEngine$1(language, opts);
  if (typeof engine.stringify !== 'function') {
    throw new TypeError('expected "' + language + '.stringify" to be a function');
  }
  data = Object.assign({}, file.data, data);
  const open = opts.delimiters[0];
  const close = opts.delimiters[1];
  const matter = engine.stringify(data, options).trim();
  let buf = '';
  if (matter !== '{}') {
    buf = newline(open) + newline(matter) + newline(close);
  }
  if (typeof file.excerpt === 'string' && file.excerpt !== '') {
    if (str.indexOf(file.excerpt.trim()) === -1) {
      buf += newline(file.excerpt) + newline(close);
    }
  }
  return buf + newline(str);
};
function newline(str) {
  return str.slice(-1) !== '\n' ? str + '\n' : str;
}

const defaults$2 = defaults$4;
var excerpt$1 = function (file, options) {
  const opts = defaults$2(options);
  if (file.data == null) {
    file.data = {};
  }
  if (typeof opts.excerpt === 'function') {
    return opts.excerpt(file, opts);
  }
  const sep = file.data.excerpt_separator || opts.excerpt_separator;
  if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {
    return file;
  }
  const delimiter = typeof opts.excerpt === 'string' ? opts.excerpt : sep || opts.delimiters[0];

  // if enabled, get the excerpt defined after front-matter
  const idx = file.content.indexOf(delimiter);
  if (idx !== -1) {
    file.excerpt = file.content.slice(0, idx);
  }
  return file;
};

const typeOf = kindOf;
const stringify$3 = stringify$4;
const utils$1 = utils$3;

/**
 * Normalize the given value to ensure an object is returned
 * with the expected properties.
 */

var toFile$1 = function (file) {
  if (typeOf(file) !== 'object') {
    file = {
      content: file
    };
  }
  if (typeOf(file.data) !== 'object') {
    file.data = {};
  }

  // if file was passed as an object, ensure that
  // "file.content" is set
  if (file.contents && file.content == null) {
    file.content = file.contents;
  }

  // set non-enumerable properties on the file object
  utils$1.define(file, 'orig', utils$1.toBuffer(file.content));
  utils$1.define(file, 'language', file.language || '');
  utils$1.define(file, 'matter', file.matter || '');
  utils$1.define(file, 'stringify', function (data, options) {
    if (options && options.language) {
      file.language = options.language;
    }
    return stringify$3(file, data, options);
  });

  // strip BOM and ensure that "file.content" is a string
  file.content = utils$1.toString(file.content);
  file.isEmpty = false;
  file.excerpt = '';
  return file;
};

const getEngine = engine;
const defaults$1 = defaults$4;
var parse$3 = function (language, str, options) {
  const opts = defaults$1(options);
  const engine = getEngine(language, opts);
  if (typeof engine.parse !== 'function') {
    throw new TypeError('expected "' + language + '.parse" to be a function');
  }
  return engine.parse(str, opts);
};

const fs = fs__default["default"];
const sections = sectionMatter;
const defaults = defaults$4;
const stringify$2 = stringify$4;
const excerpt = excerpt$1;
const engines = engines$2.exports;
const toFile = toFile$1;
const parse$2 = parse$3;
const utils = utils$3;

/**
 * Takes a string or object with `content` property, extracts
 * and parses front-matter from the string, then returns an object
 * with `data`, `content` and other [useful properties](#returned-object).
 *
 * ```js
 * const matter = require('gray-matter');
 * console.log(matter('---\ntitle: Home\n---\nOther stuff'));
 * //=> { data: { title: 'Home'}, content: 'Other stuff' }
 * ```
 * @param {Object|String} `input` String, or object with `content` string
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */

function matter(input, options) {
  if (input === '') {
    return {
      data: {},
      content: input,
      excerpt: '',
      orig: input
    };
  }
  let file = toFile(input);
  const cached = matter.cache[file.content];
  if (!options) {
    if (cached) {
      file = Object.assign({}, cached);
      file.orig = cached.orig;
      return file;
    }

    // only cache if there are no options passed. if we cache when options
    // are passed, we would need to also cache options values, which would
    // negate any performance benefits of caching
    matter.cache[file.content] = file;
  }
  return parseMatter(file, options);
}

/**
 * Parse front matter
 */

function parseMatter(file, options) {
  const opts = defaults(options);
  const open = opts.delimiters[0];
  const close = '\n' + opts.delimiters[1];
  let str = file.content;
  if (opts.language) {
    file.language = opts.language;
  }

  // get the length of the opening delimiter
  const openLen = open.length;
  if (!utils.startsWith(str, open, openLen)) {
    excerpt(file, opts);
    return file;
  }

  // if the next character after the opening delimiter is
  // a character from the delimiter, then it's not a front-
  // matter delimiter
  if (str.charAt(openLen) === open.slice(-1)) {
    return file;
  }

  // strip the opening delimiter
  str = str.slice(openLen);
  const len = str.length;

  // use the language defined after first delimiter, if it exists
  const language = matter.language(str, opts);
  if (language.name) {
    file.language = language.name;
    str = str.slice(language.raw.length);
  }

  // get the index of the closing delimiter
  let closeIndex = str.indexOf(close);
  if (closeIndex === -1) {
    closeIndex = len;
  }

  // get the raw front-matter block
  file.matter = str.slice(0, closeIndex);
  const block = file.matter.replace(/^\s*#[^\n]+/gm, '').trim();
  if (block === '') {
    file.isEmpty = true;
    file.empty = file.content;
    file.data = {};
  } else {
    // create file.data by parsing the raw file.matter block
    file.data = parse$2(file.language, file.matter, opts);
  }

  // update file.content
  if (closeIndex === len) {
    file.content = '';
  } else {
    file.content = str.slice(closeIndex + close.length);
    if (file.content[0] === '\r') {
      file.content = file.content.slice(1);
    }
    if (file.content[0] === '\n') {
      file.content = file.content.slice(1);
    }
  }
  excerpt(file, opts);
  if (opts.sections === true || typeof opts.section === 'function') {
    sections(file, opts.section);
  }
  return file;
}

/**
 * Expose engines
 */

matter.engines = engines;

/**
 * Stringify an object to YAML or the specified language, and
 * append it to the given string. By default, only YAML and JSON
 * can be stringified. See the [engines](#engines) section to learn
 * how to stringify other languages.
 *
 * ```js
 * console.log(matter.stringify('foo bar baz', {title: 'Home'}));
 * // results in:
 * // ---
 * // title: Home
 * // ---
 * // foo bar baz
 * ```
 * @param {String|Object} `file` The content string to append to stringified front-matter, or a file object with `file.content` string.
 * @param {Object} `data` Front matter to stringify.
 * @param {Object} `options` [Options](#options) to pass to gray-matter and [js-yaml].
 * @return {String} Returns a string created by wrapping stringified yaml with delimiters, and appending that to the given string.
 * @api public
 */

matter.stringify = function (file, data, options) {
  if (typeof file === 'string') file = matter(file, options);
  return stringify$2(file, data, options);
};

/**
 * Synchronously read a file from the file system and parse
 * front matter. Returns the same object as the [main function](#matter).
 *
 * ```js
 * const file = matter.read('./content/blog-post.md');
 * ```
 * @param {String} `filepath` file path of the file to read.
 * @param {Object} `options` [Options](#options) to pass to gray-matter.
 * @return {Object} Returns [an object](#returned-object) with `data` and `content`
 * @api public
 */

matter.read = function (filepath, options) {
  const str = fs.readFileSync(filepath, 'utf8');
  const file = matter(str, options);
  file.path = filepath;
  return file;
};

/**
 * Returns true if the given `string` has front matter.
 * @param  {String} `string`
 * @param  {Object} `options`
 * @return {Boolean} True if front matter exists.
 * @api public
 */

matter.test = function (str, options) {
  return utils.startsWith(str, defaults(options).delimiters[0]);
};

/**
 * Detect the language to use, if one is defined after the
 * first front-matter delimiter.
 * @param  {String} `string`
 * @param  {Object} `options`
 * @return {Object} Object with `raw` (actual language string), and `name`, the language with whitespace trimmed
 */

matter.language = function (str, options) {
  const opts = defaults(options);
  const open = opts.delimiters[0];
  if (matter.test(str)) {
    str = str.slice(open.length);
  }
  const language = str.slice(0, str.search(/\r?\n/));
  return {
    raw: language,
    name: language ? language.trim() : ''
  };
};

/**
 * Expose `matter`
 */

matter.cache = {};
matter.clearCache = function () {
  matter.cache = {};
};
var grayMatter = matter;

var toml = {};

var parse$1 = {exports: {}};

var tomlParser = {exports: {}};

const ParserEND = 0x110000;
class ParserError extends Error {
  /* istanbul ignore next */
  constructor(msg, filename, linenumber) {
    super('[ParserError] ' + msg, filename, linenumber);
    this.name = 'ParserError';
    this.code = 'ParserError';
    if (Error.captureStackTrace) Error.captureStackTrace(this, ParserError);
  }
}
class State {
  constructor(parser) {
    this.parser = parser;
    this.buf = '';
    this.returned = null;
    this.result = null;
    this.resultTable = null;
    this.resultArr = null;
  }
}
class Parser {
  constructor() {
    this.pos = 0;
    this.col = 0;
    this.line = 0;
    this.obj = {};
    this.ctx = this.obj;
    this.stack = [];
    this._buf = '';
    this.char = null;
    this.ii = 0;
    this.state = new State(this.parseStart);
  }
  parse(str) {
    /* istanbul ignore next */
    if (str.length === 0 || str.length == null) return;
    this._buf = String(str);
    this.ii = -1;
    this.char = -1;
    let getNext;
    while (getNext === false || this.nextChar()) {
      getNext = this.runOne();
    }
    this._buf = null;
  }
  nextChar() {
    if (this.char === 0x0A) {
      ++this.line;
      this.col = -1;
    }
    ++this.ii;
    this.char = this._buf.codePointAt(this.ii);
    ++this.pos;
    ++this.col;
    return this.haveBuffer();
  }
  haveBuffer() {
    return this.ii < this._buf.length;
  }
  runOne() {
    return this.state.parser.call(this, this.state.returned);
  }
  finish() {
    this.char = ParserEND;
    let last;
    do {
      last = this.state.parser;
      this.runOne();
    } while (this.state.parser !== last);
    this.ctx = null;
    this.state = null;
    this._buf = null;
    return this.obj;
  }
  next(fn) {
    /* istanbul ignore next */
    if (typeof fn !== 'function') throw new ParserError('Tried to set state to non-existent state: ' + JSON.stringify(fn));
    this.state.parser = fn;
  }
  goto(fn) {
    this.next(fn);
    return this.runOne();
  }
  call(fn, returnWith) {
    if (returnWith) this.next(returnWith);
    this.stack.push(this.state);
    this.state = new State(fn);
  }
  callNow(fn, returnWith) {
    this.call(fn, returnWith);
    return this.runOne();
  }
  return(value) {
    /* istanbul ignore next */
    if (this.stack.length === 0) throw this.error(new ParserError('Stack underflow'));
    if (value === undefined) value = this.state.buf;
    this.state = this.stack.pop();
    this.state.returned = value;
  }
  returnNow(value) {
    this.return(value);
    return this.runOne();
  }
  consume() {
    /* istanbul ignore next */
    if (this.char === ParserEND) throw this.error(new ParserError('Unexpected end-of-buffer'));
    this.state.buf += this._buf[this.ii];
  }
  error(err) {
    err.line = this.line;
    err.col = this.col;
    err.pos = this.pos;
    return err;
  }
  /* istanbul ignore next */
  parseStart() {
    throw new ParserError('Must declare a parseStart method');
  }
}
Parser.END = ParserEND;
Parser.Error = ParserError;
var parser = Parser;

var createDatetime = value => {
  const date = new Date(value);
  /* istanbul ignore if */
  if (isNaN(date)) {
    throw new TypeError('Invalid Datetime');
  } else {
    return date;
  }
};

var formatNum = (d, num) => {
  num = String(num);
  while (num.length < d) num = '0' + num;
  return num;
};

const f$2 = formatNum;
class FloatingDateTime extends Date {
  constructor(value) {
    super(value + 'Z');
    this.isFloating = true;
  }
  toISOString() {
    const date = `${this.getUTCFullYear()}-${f$2(2, this.getUTCMonth() + 1)}-${f$2(2, this.getUTCDate())}`;
    const time = `${f$2(2, this.getUTCHours())}:${f$2(2, this.getUTCMinutes())}:${f$2(2, this.getUTCSeconds())}.${f$2(3, this.getUTCMilliseconds())}`;
    return `${date}T${time}`;
  }
}
var createDatetimeFloat = value => {
  const date = new FloatingDateTime(value);
  /* istanbul ignore if */
  if (isNaN(date)) {
    throw new TypeError('Invalid Datetime');
  } else {
    return date;
  }
};

const f$1 = formatNum;
const DateTime$1 = commonjsGlobal.Date;
class Date$1 extends DateTime$1 {
  constructor(value) {
    super(value);
    this.isDate = true;
  }
  toISOString() {
    return `${this.getUTCFullYear()}-${f$1(2, this.getUTCMonth() + 1)}-${f$1(2, this.getUTCDate())}`;
  }
}
var createDate$1 = value => {
  const date = new Date$1(value);
  /* istanbul ignore if */
  if (isNaN(date)) {
    throw new TypeError('Invalid Datetime');
  } else {
    return date;
  }
};

const f = formatNum;
class Time extends Date {
  constructor(value) {
    super(`0000-01-01T${value}Z`);
    this.isTime = true;
  }
  toISOString() {
    return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
  }
}
var createTime$1 = value => {
  const date = new Time(value);
  /* istanbul ignore if */
  if (isNaN(date)) {
    throw new TypeError('Invalid Datetime');
  } else {
    return date;
  }
};

/* eslint-disable no-new-wrappers, no-eval, camelcase, operator-linebreak */
tomlParser.exports = makeParserClass(parser);
tomlParser.exports.makeParserClass = makeParserClass;
class TomlError extends Error {
  constructor(msg) {
    super(msg);
    this.name = 'TomlError';
    /* istanbul ignore next */
    if (Error.captureStackTrace) Error.captureStackTrace(this, TomlError);
    this.fromTOML = true;
    this.wrapped = null;
  }
}
TomlError.wrap = err => {
  const terr = new TomlError(err.message);
  terr.code = err.code;
  terr.wrapped = err;
  return terr;
};
tomlParser.exports.TomlError = TomlError;
const createDateTime = createDatetime;
const createDateTimeFloat = createDatetimeFloat;
const createDate = createDate$1;
const createTime = createTime$1;
const CTRL_I = 0x09;
const CTRL_J = 0x0A;
const CTRL_M = 0x0D;
const CTRL_CHAR_BOUNDARY = 0x1F; // the last non-character in the latin1 region of unicode, except DEL
const CHAR_SP = 0x20;
const CHAR_QUOT = 0x22;
const CHAR_NUM = 0x23;
const CHAR_APOS = 0x27;
const CHAR_PLUS = 0x2B;
const CHAR_COMMA = 0x2C;
const CHAR_HYPHEN = 0x2D;
const CHAR_PERIOD = 0x2E;
const CHAR_0 = 0x30;
const CHAR_1 = 0x31;
const CHAR_7 = 0x37;
const CHAR_9 = 0x39;
const CHAR_COLON = 0x3A;
const CHAR_EQUALS = 0x3D;
const CHAR_A = 0x41;
const CHAR_E = 0x45;
const CHAR_F = 0x46;
const CHAR_T = 0x54;
const CHAR_U = 0x55;
const CHAR_Z = 0x5A;
const CHAR_LOWBAR = 0x5F;
const CHAR_a = 0x61;
const CHAR_b = 0x62;
const CHAR_e = 0x65;
const CHAR_f = 0x66;
const CHAR_i = 0x69;
const CHAR_l = 0x6C;
const CHAR_n = 0x6E;
const CHAR_o = 0x6F;
const CHAR_r = 0x72;
const CHAR_s = 0x73;
const CHAR_t = 0x74;
const CHAR_u = 0x75;
const CHAR_x = 0x78;
const CHAR_z = 0x7A;
const CHAR_LCUB = 0x7B;
const CHAR_RCUB = 0x7D;
const CHAR_LSQB = 0x5B;
const CHAR_BSOL = 0x5C;
const CHAR_RSQB = 0x5D;
const CHAR_DEL = 0x7F;
const SURROGATE_FIRST = 0xD800;
const SURROGATE_LAST = 0xDFFF;
const escapes = {
  [CHAR_b]: '\u0008',
  [CHAR_t]: '\u0009',
  [CHAR_n]: '\u000A',
  [CHAR_f]: '\u000C',
  [CHAR_r]: '\u000D',
  [CHAR_QUOT]: '\u0022',
  [CHAR_BSOL]: '\u005C'
};
function isDigit(cp) {
  return cp >= CHAR_0 && cp <= CHAR_9;
}
function isHexit(cp) {
  return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;
}
function isBit(cp) {
  return cp === CHAR_1 || cp === CHAR_0;
}
function isOctit(cp) {
  return cp >= CHAR_0 && cp <= CHAR_7;
}
function isAlphaNumQuoteHyphen(cp) {
  return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
}
function isAlphaNumHyphen(cp) {
  return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
}
const _type = Symbol('type');
const _declared = Symbol('declared');
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const defineProperty = Object.defineProperty;
const descriptor = {
  configurable: true,
  enumerable: true,
  writable: true,
  value: undefined
};
function hasKey(obj, key) {
  if (hasOwnProperty$1.call(obj, key)) return true;
  if (key === '__proto__') defineProperty(obj, '__proto__', descriptor);
  return false;
}
const INLINE_TABLE = Symbol('inline-table');
function InlineTable() {
  return Object.defineProperties({}, {
    [_type]: {
      value: INLINE_TABLE
    }
  });
}
function isInlineTable(obj) {
  if (obj === null || typeof obj !== 'object') return false;
  return obj[_type] === INLINE_TABLE;
}
const TABLE = Symbol('table');
function Table() {
  return Object.defineProperties({}, {
    [_type]: {
      value: TABLE
    },
    [_declared]: {
      value: false,
      writable: true
    }
  });
}
function isTable(obj) {
  if (obj === null || typeof obj !== 'object') return false;
  return obj[_type] === TABLE;
}
const _contentType = Symbol('content-type');
const INLINE_LIST = Symbol('inline-list');
function InlineList(type) {
  return Object.defineProperties([], {
    [_type]: {
      value: INLINE_LIST
    },
    [_contentType]: {
      value: type
    }
  });
}
function isInlineList(obj) {
  if (obj === null || typeof obj !== 'object') return false;
  return obj[_type] === INLINE_LIST;
}
const LIST = Symbol('list');
function List() {
  return Object.defineProperties([], {
    [_type]: {
      value: LIST
    }
  });
}
function isList(obj) {
  if (obj === null || typeof obj !== 'object') return false;
  return obj[_type] === LIST;
}

// in an eval, to let bundlers not slurp in a util proxy
let _custom;
try {
  const utilInspect = eval("require('util').inspect");
  _custom = utilInspect.custom;
} catch (_) {
  /* eval require not available in transpiled bundle */
}
/* istanbul ignore next */
const _inspect = _custom || 'inspect';
class BoxedBigInt {
  constructor(value) {
    try {
      this.value = commonjsGlobal.BigInt.asIntN(64, value);
    } catch (_) {
      /* istanbul ignore next */
      this.value = null;
    }
    Object.defineProperty(this, _type, {
      value: INTEGER
    });
  }
  isNaN() {
    return this.value === null;
  }
  /* istanbul ignore next */
  toString() {
    return String(this.value);
  }
  /* istanbul ignore next */
  [_inspect]() {
    return `[BigInt: ${this.toString()}]}`;
  }
  valueOf() {
    return this.value;
  }
}
const INTEGER = Symbol('integer');
function Integer(value) {
  let num = Number(value);
  // -0 is a float thing, not an int thing
  if (Object.is(num, -0)) num = 0;
  /* istanbul ignore else */
  if (commonjsGlobal.BigInt && !Number.isSafeInteger(num)) {
    return new BoxedBigInt(value);
  } else {
    /* istanbul ignore next */
    return Object.defineProperties(new Number(num), {
      isNaN: {
        value: function () {
          return isNaN(this);
        }
      },
      [_type]: {
        value: INTEGER
      },
      [_inspect]: {
        value: () => `[Integer: ${value}]`
      }
    });
  }
}
function isInteger$1(obj) {
  if (obj === null || typeof obj !== 'object') return false;
  return obj[_type] === INTEGER;
}
const FLOAT = Symbol('float');
function Float(value) {
  /* istanbul ignore next */
  return Object.defineProperties(new Number(value), {
    [_type]: {
      value: FLOAT
    },
    [_inspect]: {
      value: () => `[Float: ${value}]`
    }
  });
}
function isFloat(obj) {
  if (obj === null || typeof obj !== 'object') return false;
  return obj[_type] === FLOAT;
}
function tomlType$1(value) {
  const type = typeof value;
  if (type === 'object') {
    /* istanbul ignore if */
    if (value === null) return 'null';
    if (value instanceof Date) return 'datetime';
    /* istanbul ignore else */
    if (_type in value) {
      switch (value[_type]) {
        case INLINE_TABLE:
          return 'inline-table';
        case INLINE_LIST:
          return 'inline-list';
        /* istanbul ignore next */
        case TABLE:
          return 'table';
        /* istanbul ignore next */
        case LIST:
          return 'list';
        case FLOAT:
          return 'float';
        case INTEGER:
          return 'integer';
      }
    }
  }
  return type;
}
function makeParserClass(Parser) {
  class TOMLParser extends Parser {
    constructor() {
      super();
      this.ctx = this.obj = Table();
    }

    /* MATCH HELPER */
    atEndOfWord() {
      return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
    }
    atEndOfLine() {
      return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;
    }
    parseStart() {
      if (this.char === Parser.END) {
        return null;
      } else if (this.char === CHAR_LSQB) {
        return this.call(this.parseTableOrList);
      } else if (this.char === CHAR_NUM) {
        return this.call(this.parseComment);
      } else if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
        return null;
      } else if (isAlphaNumQuoteHyphen(this.char)) {
        return this.callNow(this.parseAssignStatement);
      } else {
        throw this.error(new TomlError(`Unknown character "${this.char}"`));
      }
    }

    // HELPER, this strips any whitespace and comments to the end of the line
    // then RETURNS. Last state in a production.
    parseWhitespaceToEOL() {
      if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
        return null;
      } else if (this.char === CHAR_NUM) {
        return this.goto(this.parseComment);
      } else if (this.char === Parser.END || this.char === CTRL_J) {
        return this.return();
      } else {
        throw this.error(new TomlError('Unexpected character, expected only whitespace or comments till end of line'));
      }
    }

    /* ASSIGNMENT: key = value */
    parseAssignStatement() {
      return this.callNow(this.parseAssign, this.recordAssignStatement);
    }
    recordAssignStatement(kv) {
      let target = this.ctx;
      let finalKey = kv.key.pop();
      for (let kw of kv.key) {
        if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
          throw this.error(new TomlError("Can't redefine existing key"));
        }
        target = target[kw] = target[kw] || Table();
      }
      if (hasKey(target, finalKey)) {
        throw this.error(new TomlError("Can't redefine existing key"));
      }
      // unbox our numbers
      if (isInteger$1(kv.value) || isFloat(kv.value)) {
        target[finalKey] = kv.value.valueOf();
      } else {
        target[finalKey] = kv.value;
      }
      return this.goto(this.parseWhitespaceToEOL);
    }

    /* ASSSIGNMENT expression, key = value possibly inside an inline table */
    parseAssign() {
      return this.callNow(this.parseKeyword, this.recordAssignKeyword);
    }
    recordAssignKeyword(key) {
      if (this.state.resultTable) {
        this.state.resultTable.push(key);
      } else {
        this.state.resultTable = [key];
      }
      return this.goto(this.parseAssignKeywordPreDot);
    }
    parseAssignKeywordPreDot() {
      if (this.char === CHAR_PERIOD) {
        return this.next(this.parseAssignKeywordPostDot);
      } else if (this.char !== CHAR_SP && this.char !== CTRL_I) {
        return this.goto(this.parseAssignEqual);
      }
    }
    parseAssignKeywordPostDot() {
      if (this.char !== CHAR_SP && this.char !== CTRL_I) {
        return this.callNow(this.parseKeyword, this.recordAssignKeyword);
      }
    }
    parseAssignEqual() {
      if (this.char === CHAR_EQUALS) {
        return this.next(this.parseAssignPreValue);
      } else {
        throw this.error(new TomlError('Invalid character, expected "="'));
      }
    }
    parseAssignPreValue() {
      if (this.char === CHAR_SP || this.char === CTRL_I) {
        return null;
      } else {
        return this.callNow(this.parseValue, this.recordAssignValue);
      }
    }
    recordAssignValue(value) {
      return this.returnNow({
        key: this.state.resultTable,
        value: value
      });
    }

    /* COMMENTS: #...eol */
    parseComment() {
      do {
        if (this.char === Parser.END || this.char === CTRL_J) {
          return this.return();
        }
      } while (this.nextChar());
    }

    /* TABLES AND LISTS, [foo] and [[foo]] */
    parseTableOrList() {
      if (this.char === CHAR_LSQB) {
        this.next(this.parseList);
      } else {
        return this.goto(this.parseTable);
      }
    }

    /* TABLE [foo.bar.baz] */
    parseTable() {
      this.ctx = this.obj;
      return this.goto(this.parseTableNext);
    }
    parseTableNext() {
      if (this.char === CHAR_SP || this.char === CTRL_I) {
        return null;
      } else {
        return this.callNow(this.parseKeyword, this.parseTableMore);
      }
    }
    parseTableMore(keyword) {
      if (this.char === CHAR_SP || this.char === CTRL_I) {
        return null;
      } else if (this.char === CHAR_RSQB) {
        if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared])) {
          throw this.error(new TomlError("Can't redefine existing key"));
        } else {
          this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table();
          this.ctx[_declared] = true;
        }
        return this.next(this.parseWhitespaceToEOL);
      } else if (this.char === CHAR_PERIOD) {
        if (!hasKey(this.ctx, keyword)) {
          this.ctx = this.ctx[keyword] = Table();
        } else if (isTable(this.ctx[keyword])) {
          this.ctx = this.ctx[keyword];
        } else if (isList(this.ctx[keyword])) {
          this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
        } else {
          throw this.error(new TomlError("Can't redefine existing key"));
        }
        return this.next(this.parseTableNext);
      } else {
        throw this.error(new TomlError('Unexpected character, expected whitespace, . or ]'));
      }
    }

    /* LIST [[a.b.c]] */
    parseList() {
      this.ctx = this.obj;
      return this.goto(this.parseListNext);
    }
    parseListNext() {
      if (this.char === CHAR_SP || this.char === CTRL_I) {
        return null;
      } else {
        return this.callNow(this.parseKeyword, this.parseListMore);
      }
    }
    parseListMore(keyword) {
      if (this.char === CHAR_SP || this.char === CTRL_I) {
        return null;
      } else if (this.char === CHAR_RSQB) {
        if (!hasKey(this.ctx, keyword)) {
          this.ctx[keyword] = List();
        }
        if (isInlineList(this.ctx[keyword])) {
          throw this.error(new TomlError("Can't extend an inline array"));
        } else if (isList(this.ctx[keyword])) {
          const next = Table();
          this.ctx[keyword].push(next);
          this.ctx = next;
        } else {
          throw this.error(new TomlError("Can't redefine an existing key"));
        }
        return this.next(this.parseListEnd);
      } else if (this.char === CHAR_PERIOD) {
        if (!hasKey(this.ctx, keyword)) {
          this.ctx = this.ctx[keyword] = Table();
        } else if (isInlineList(this.ctx[keyword])) {
          throw this.error(new TomlError("Can't extend an inline array"));
        } else if (isInlineTable(this.ctx[keyword])) {
          throw this.error(new TomlError("Can't extend an inline table"));
        } else if (isList(this.ctx[keyword])) {
          this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
        } else if (isTable(this.ctx[keyword])) {
          this.ctx = this.ctx[keyword];
        } else {
          throw this.error(new TomlError("Can't redefine an existing key"));
        }
        return this.next(this.parseListNext);
      } else {
        throw this.error(new TomlError('Unexpected character, expected whitespace, . or ]'));
      }
    }
    parseListEnd(keyword) {
      if (this.char === CHAR_RSQB) {
        return this.next(this.parseWhitespaceToEOL);
      } else {
        throw this.error(new TomlError('Unexpected character, expected whitespace, . or ]'));
      }
    }

    /* VALUE string, number, boolean, inline list, inline object */
    parseValue() {
      if (this.char === Parser.END) {
        throw this.error(new TomlError('Key without value'));
      } else if (this.char === CHAR_QUOT) {
        return this.next(this.parseDoubleString);
      }
      if (this.char === CHAR_APOS) {
        return this.next(this.parseSingleString);
      } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
        return this.goto(this.parseNumberSign);
      } else if (this.char === CHAR_i) {
        return this.next(this.parseInf);
      } else if (this.char === CHAR_n) {
        return this.next(this.parseNan);
      } else if (isDigit(this.char)) {
        return this.goto(this.parseNumberOrDateTime);
      } else if (this.char === CHAR_t || this.char === CHAR_f) {
        return this.goto(this.parseBoolean);
      } else if (this.char === CHAR_LSQB) {
        return this.call(this.parseInlineList, this.recordValue);
      } else if (this.char === CHAR_LCUB) {
        return this.call(this.parseInlineTable, this.recordValue);
      } else {
        throw this.error(new TomlError('Unexpected character, expecting string, number, datetime, boolean, inline array or inline table'));
      }
    }
    recordValue(value) {
      return this.returnNow(value);
    }
    parseInf() {
      if (this.char === CHAR_n) {
        return this.next(this.parseInf2);
      } else {
        throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
      }
    }
    parseInf2() {
      if (this.char === CHAR_f) {
        if (this.state.buf === '-') {
          return this.return(-Infinity);
        } else {
          return this.return(Infinity);
        }
      } else {
        throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
      }
    }
    parseNan() {
      if (this.char === CHAR_a) {
        return this.next(this.parseNan2);
      } else {
        throw this.error(new TomlError('Unexpected character, expected "nan"'));
      }
    }
    parseNan2() {
      if (this.char === CHAR_n) {
        return this.return(NaN);
      } else {
        throw this.error(new TomlError('Unexpected character, expected "nan"'));
      }
    }

    /* KEYS, barewords or basic, literal, or dotted */
    parseKeyword() {
      if (this.char === CHAR_QUOT) {
        return this.next(this.parseBasicString);
      } else if (this.char === CHAR_APOS) {
        return this.next(this.parseLiteralString);
      } else {
        return this.goto(this.parseBareKey);
      }
    }

    /* KEYS: barewords */
    parseBareKey() {
      do {
        if (this.char === Parser.END) {
          throw this.error(new TomlError('Key ended without value'));
        } else if (isAlphaNumHyphen(this.char)) {
          this.consume();
        } else if (this.state.buf.length === 0) {
          throw this.error(new TomlError('Empty bare keys are not allowed'));
        } else {
          return this.returnNow();
        }
      } while (this.nextChar());
    }

    /* STRINGS, single quoted (literal) */
    parseSingleString() {
      if (this.char === CHAR_APOS) {
        return this.next(this.parseLiteralMultiStringMaybe);
      } else {
        return this.goto(this.parseLiteralString);
      }
    }
    parseLiteralString() {
      do {
        if (this.char === CHAR_APOS) {
          return this.return();
        } else if (this.atEndOfLine()) {
          throw this.error(new TomlError('Unterminated string'));
        } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {
          throw this.errorControlCharInString();
        } else {
          this.consume();
        }
      } while (this.nextChar());
    }
    parseLiteralMultiStringMaybe() {
      if (this.char === CHAR_APOS) {
        return this.next(this.parseLiteralMultiString);
      } else {
        return this.returnNow();
      }
    }
    parseLiteralMultiString() {
      if (this.char === CTRL_M) {
        return null;
      } else if (this.char === CTRL_J) {
        return this.next(this.parseLiteralMultiStringContent);
      } else {
        return this.goto(this.parseLiteralMultiStringContent);
      }
    }
    parseLiteralMultiStringContent() {
      do {
        if (this.char === CHAR_APOS) {
          return this.next(this.parseLiteralMultiEnd);
        } else if (this.char === Parser.END) {
          throw this.error(new TomlError('Unterminated multi-line string'));
        } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {
          throw this.errorControlCharInString();
        } else {
          this.consume();
        }
      } while (this.nextChar());
    }
    parseLiteralMultiEnd() {
      if (this.char === CHAR_APOS) {
        return this.next(this.parseLiteralMultiEnd2);
      } else {
        this.state.buf += "'";
        return this.goto(this.parseLiteralMultiStringContent);
      }
    }
    parseLiteralMultiEnd2() {
      if (this.char === CHAR_APOS) {
        return this.return();
      } else {
        this.state.buf += "''";
        return this.goto(this.parseLiteralMultiStringContent);
      }
    }

    /* STRINGS double quoted */
    parseDoubleString() {
      if (this.char === CHAR_QUOT) {
        return this.next(this.parseMultiStringMaybe);
      } else {
        return this.goto(this.parseBasicString);
      }
    }
    parseBasicString() {
      do {
        if (this.char === CHAR_BSOL) {
          return this.call(this.parseEscape, this.recordEscapeReplacement);
        } else if (this.char === CHAR_QUOT) {
          return this.return();
        } else if (this.atEndOfLine()) {
          throw this.error(new TomlError('Unterminated string'));
        } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {
          throw this.errorControlCharInString();
        } else {
          this.consume();
        }
      } while (this.nextChar());
    }
    recordEscapeReplacement(replacement) {
      this.state.buf += replacement;
      return this.goto(this.parseBasicString);
    }
    parseMultiStringMaybe() {
      if (this.char === CHAR_QUOT) {
        return this.next(this.parseMultiString);
      } else {
        return this.returnNow();
      }
    }
    parseMultiString() {
      if (this.char === CTRL_M) {
        return null;
      } else if (this.char === CTRL_J) {
        return this.next(this.parseMultiStringContent);
      } else {
        return this.goto(this.parseMultiStringContent);
      }
    }
    parseMultiStringContent() {
      do {
        if (this.char === CHAR_BSOL) {
          return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
        } else if (this.char === CHAR_QUOT) {
          return this.next(this.parseMultiEnd);
        } else if (this.char === Parser.END) {
          throw this.error(new TomlError('Unterminated multi-line string'));
        } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {
          throw this.errorControlCharInString();
        } else {
          this.consume();
        }
      } while (this.nextChar());
    }
    errorControlCharInString() {
      let displayCode = '\\u00';
      if (this.char < 16) {
        displayCode += '0';
      }
      displayCode += this.char.toString(16);
      return this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
    }
    recordMultiEscapeReplacement(replacement) {
      this.state.buf += replacement;
      return this.goto(this.parseMultiStringContent);
    }
    parseMultiEnd() {
      if (this.char === CHAR_QUOT) {
        return this.next(this.parseMultiEnd2);
      } else {
        this.state.buf += '"';
        return this.goto(this.parseMultiStringContent);
      }
    }
    parseMultiEnd2() {
      if (this.char === CHAR_QUOT) {
        return this.return();
      } else {
        this.state.buf += '""';
        return this.goto(this.parseMultiStringContent);
      }
    }
    parseMultiEscape() {
      if (this.char === CTRL_M || this.char === CTRL_J) {
        return this.next(this.parseMultiTrim);
      } else if (this.char === CHAR_SP || this.char === CTRL_I) {
        return this.next(this.parsePreMultiTrim);
      } else {
        return this.goto(this.parseEscape);
      }
    }
    parsePreMultiTrim() {
      if (this.char === CHAR_SP || this.char === CTRL_I) {
        return null;
      } else if (this.char === CTRL_M || this.char === CTRL_J) {
        return this.next(this.parseMultiTrim);
      } else {
        throw this.error(new TomlError("Can't escape whitespace"));
      }
    }
    parseMultiTrim() {
      // explicitly whitespace here, END should follow the same path as chars
      if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
        return null;
      } else {
        return this.returnNow();
      }
    }
    parseEscape() {
      if (this.char in escapes) {
        return this.return(escapes[this.char]);
      } else if (this.char === CHAR_u) {
        return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
      } else if (this.char === CHAR_U) {
        return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
      } else {
        throw this.error(new TomlError('Unknown escape character: ' + this.char));
      }
    }
    parseUnicodeReturn(char) {
      try {
        const codePoint = parseInt(char, 16);
        if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST) {
          throw this.error(new TomlError('Invalid unicode, character in range 0xD800 - 0xDFFF is reserved'));
        }
        return this.returnNow(String.fromCodePoint(codePoint));
      } catch (err) {
        throw this.error(TomlError.wrap(err));
      }
    }
    parseSmallUnicode() {
      if (!isHexit(this.char)) {
        throw this.error(new TomlError('Invalid character in unicode sequence, expected hex'));
      } else {
        this.consume();
        if (this.state.buf.length >= 4) return this.return();
      }
    }
    parseLargeUnicode() {
      if (!isHexit(this.char)) {
        throw this.error(new TomlError('Invalid character in unicode sequence, expected hex'));
      } else {
        this.consume();
        if (this.state.buf.length >= 8) return this.return();
      }
    }

    /* NUMBERS */
    parseNumberSign() {
      this.consume();
      return this.next(this.parseMaybeSignedInfOrNan);
    }
    parseMaybeSignedInfOrNan() {
      if (this.char === CHAR_i) {
        return this.next(this.parseInf);
      } else if (this.char === CHAR_n) {
        return this.next(this.parseNan);
      } else {
        return this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
      }
    }
    parseNumberIntegerStart() {
      if (this.char === CHAR_0) {
        this.consume();
        return this.next(this.parseNumberIntegerExponentOrDecimal);
      } else {
        return this.goto(this.parseNumberInteger);
      }
    }
    parseNumberIntegerExponentOrDecimal() {
      if (this.char === CHAR_PERIOD) {
        this.consume();
        return this.call(this.parseNoUnder, this.parseNumberFloat);
      } else if (this.char === CHAR_E || this.char === CHAR_e) {
        this.consume();
        return this.next(this.parseNumberExponentSign);
      } else {
        return this.returnNow(Integer(this.state.buf));
      }
    }
    parseNumberInteger() {
      if (isDigit(this.char)) {
        this.consume();
      } else if (this.char === CHAR_LOWBAR) {
        return this.call(this.parseNoUnder);
      } else if (this.char === CHAR_E || this.char === CHAR_e) {
        this.consume();
        return this.next(this.parseNumberExponentSign);
      } else if (this.char === CHAR_PERIOD) {
        this.consume();
        return this.call(this.parseNoUnder, this.parseNumberFloat);
      } else {
        const result = Integer(this.state.buf);
        /* istanbul ignore if */
        if (result.isNaN()) {
          throw this.error(new TomlError('Invalid number'));
        } else {
          return this.returnNow(result);
        }
      }
    }
    parseNoUnder() {
      if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e) {
        throw this.error(new TomlError('Unexpected character, expected digit'));
      } else if (this.atEndOfWord()) {
        throw this.error(new TomlError('Incomplete number'));
      }
      return this.returnNow();
    }
    parseNoUnderHexOctBinLiteral() {
      if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD) {
        throw this.error(new TomlError('Unexpected character, expected digit'));
      } else if (this.atEndOfWord()) {
        throw this.error(new TomlError('Incomplete number'));
      }
      return this.returnNow();
    }
    parseNumberFloat() {
      if (this.char === CHAR_LOWBAR) {
        return this.call(this.parseNoUnder, this.parseNumberFloat);
      } else if (isDigit(this.char)) {
        this.consume();
      } else if (this.char === CHAR_E || this.char === CHAR_e) {
        this.consume();
        return this.next(this.parseNumberExponentSign);
      } else {
        return this.returnNow(Float(this.state.buf));
      }
    }
    parseNumberExponentSign() {
      if (isDigit(this.char)) {
        return this.goto(this.parseNumberExponent);
      } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
        this.consume();
        this.call(this.parseNoUnder, this.parseNumberExponent);
      } else {
        throw this.error(new TomlError('Unexpected character, expected -, + or digit'));
      }
    }
    parseNumberExponent() {
      if (isDigit(this.char)) {
        this.consume();
      } else if (this.char === CHAR_LOWBAR) {
        return this.call(this.parseNoUnder);
      } else {
        return this.returnNow(Float(this.state.buf));
      }
    }

    /* NUMBERS or DATETIMES  */
    parseNumberOrDateTime() {
      if (this.char === CHAR_0) {
        this.consume();
        return this.next(this.parseNumberBaseOrDateTime);
      } else {
        return this.goto(this.parseNumberOrDateTimeOnly);
      }
    }
    parseNumberOrDateTimeOnly() {
      // note, if two zeros are in a row then it MUST be a date
      if (this.char === CHAR_LOWBAR) {
        return this.call(this.parseNoUnder, this.parseNumberInteger);
      } else if (isDigit(this.char)) {
        this.consume();
        if (this.state.buf.length > 4) this.next(this.parseNumberInteger);
      } else if (this.char === CHAR_E || this.char === CHAR_e) {
        this.consume();
        return this.next(this.parseNumberExponentSign);
      } else if (this.char === CHAR_PERIOD) {
        this.consume();
        return this.call(this.parseNoUnder, this.parseNumberFloat);
      } else if (this.char === CHAR_HYPHEN) {
        return this.goto(this.parseDateTime);
      } else if (this.char === CHAR_COLON) {
        return this.goto(this.parseOnlyTimeHour);
      } else {
        return this.returnNow(Integer(this.state.buf));
      }
    }
    parseDateTimeOnly() {
      if (this.state.buf.length < 4) {
        if (isDigit(this.char)) {
          return this.consume();
        } else if (this.char === CHAR_COLON) {
          return this.goto(this.parseOnlyTimeHour);
        } else {
          throw this.error(new TomlError('Expected digit while parsing year part of a date'));
        }
      } else {
        if (this.char === CHAR_HYPHEN) {
          return this.goto(this.parseDateTime);
        } else {
          throw this.error(new TomlError('Expected hyphen (-) while parsing year part of date'));
        }
      }
    }
    parseNumberBaseOrDateTime() {
      if (this.char === CHAR_b) {
        this.consume();
        return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerBin);
      } else if (this.char === CHAR_o) {
        this.consume();
        return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerOct);
      } else if (this.char === CHAR_x) {
        this.consume();
        return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerHex);
      } else if (this.char === CHAR_PERIOD) {
        return this.goto(this.parseNumberInteger);
      } else if (isDigit(this.char)) {
        return this.goto(this.parseDateTimeOnly);
      } else {
        return this.returnNow(Integer(this.state.buf));
      }
    }
    parseIntegerHex() {
      if (isHexit(this.char)) {
        this.consume();
      } else if (this.char === CHAR_LOWBAR) {
        return this.call(this.parseNoUnderHexOctBinLiteral);
      } else {
        const result = Integer(this.state.buf);
        /* istanbul ignore if */
        if (result.isNaN()) {
          throw this.error(new TomlError('Invalid number'));
        } else {
          return this.returnNow(result);
        }
      }
    }
    parseIntegerOct() {
      if (isOctit(this.char)) {
        this.consume();
      } else if (this.char === CHAR_LOWBAR) {
        return this.call(this.parseNoUnderHexOctBinLiteral);
      } else {
        const result = Integer(this.state.buf);
        /* istanbul ignore if */
        if (result.isNaN()) {
          throw this.error(new TomlError('Invalid number'));
        } else {
          return this.returnNow(result);
        }
      }
    }
    parseIntegerBin() {
      if (isBit(this.char)) {
        this.consume();
      } else if (this.char === CHAR_LOWBAR) {
        return this.call(this.parseNoUnderHexOctBinLiteral);
      } else {
        const result = Integer(this.state.buf);
        /* istanbul ignore if */
        if (result.isNaN()) {
          throw this.error(new TomlError('Invalid number'));
        } else {
          return this.returnNow(result);
        }
      }
    }

    /* DATETIME */
    parseDateTime() {
      // we enter here having just consumed the year and about to consume the hyphen
      if (this.state.buf.length < 4) {
        throw this.error(new TomlError('Years less than 1000 must be zero padded to four characters'));
      }
      this.state.result = this.state.buf;
      this.state.buf = '';
      return this.next(this.parseDateMonth);
    }
    parseDateMonth() {
      if (this.char === CHAR_HYPHEN) {
        if (this.state.buf.length < 2) {
          throw this.error(new TomlError('Months less than 10 must be zero padded to two characters'));
        }
        this.state.result += '-' + this.state.buf;
        this.state.buf = '';
        return this.next(this.parseDateDay);
      } else if (isDigit(this.char)) {
        this.consume();
      } else {
        throw this.error(new TomlError('Incomplete datetime'));
      }
    }
    parseDateDay() {
      if (this.char === CHAR_T || this.char === CHAR_SP) {
        if (this.state.buf.length < 2) {
          throw this.error(new TomlError('Days less than 10 must be zero padded to two characters'));
        }
        this.state.result += '-' + this.state.buf;
        this.state.buf = '';
        return this.next(this.parseStartTimeHour);
      } else if (this.atEndOfWord()) {
        return this.returnNow(createDate(this.state.result + '-' + this.state.buf));
      } else if (isDigit(this.char)) {
        this.consume();
      } else {
        throw this.error(new TomlError('Incomplete datetime'));
      }
    }
    parseStartTimeHour() {
      if (this.atEndOfWord()) {
        return this.returnNow(createDate(this.state.result));
      } else {
        return this.goto(this.parseTimeHour);
      }
    }
    parseTimeHour() {
      if (this.char === CHAR_COLON) {
        if (this.state.buf.length < 2) {
          throw this.error(new TomlError('Hours less than 10 must be zero padded to two characters'));
        }
        this.state.result += 'T' + this.state.buf;
        this.state.buf = '';
        return this.next(this.parseTimeMin);
      } else if (isDigit(this.char)) {
        this.consume();
      } else {
        throw this.error(new TomlError('Incomplete datetime'));
      }
    }
    parseTimeMin() {
      if (this.state.buf.length < 2 && isDigit(this.char)) {
        this.consume();
      } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
        this.state.result += ':' + this.state.buf;
        this.state.buf = '';
        return this.next(this.parseTimeSec);
      } else {
        throw this.error(new TomlError('Incomplete datetime'));
      }
    }
    parseTimeSec() {
      if (isDigit(this.char)) {
        this.consume();
        if (this.state.buf.length === 2) {
          this.state.result += ':' + this.state.buf;
          this.state.buf = '';
          return this.next(this.parseTimeZoneOrFraction);
        }
      } else {
        throw this.error(new TomlError('Incomplete datetime'));
      }
    }
    parseOnlyTimeHour() {
      /* istanbul ignore else */
      if (this.char === CHAR_COLON) {
        if (this.state.buf.length < 2) {
          throw this.error(new TomlError('Hours less than 10 must be zero padded to two characters'));
        }
        this.state.result = this.state.buf;
        this.state.buf = '';
        return this.next(this.parseOnlyTimeMin);
      } else {
        throw this.error(new TomlError('Incomplete time'));
      }
    }
    parseOnlyTimeMin() {
      if (this.state.buf.length < 2 && isDigit(this.char)) {
        this.consume();
      } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
        this.state.result += ':' + this.state.buf;
        this.state.buf = '';
        return this.next(this.parseOnlyTimeSec);
      } else {
        throw this.error(new TomlError('Incomplete time'));
      }
    }
    parseOnlyTimeSec() {
      if (isDigit(this.char)) {
        this.consume();
        if (this.state.buf.length === 2) {
          return this.next(this.parseOnlyTimeFractionMaybe);
        }
      } else {
        throw this.error(new TomlError('Incomplete time'));
      }
    }
    parseOnlyTimeFractionMaybe() {
      this.state.result += ':' + this.state.buf;
      if (this.char === CHAR_PERIOD) {
        this.state.buf = '';
        this.next(this.parseOnlyTimeFraction);
      } else {
        return this.return(createTime(this.state.result));
      }
    }
    parseOnlyTimeFraction() {
      if (isDigit(this.char)) {
        this.consume();
      } else if (this.atEndOfWord()) {
        if (this.state.buf.length === 0) throw this.error(new TomlError('Expected digit in milliseconds'));
        return this.returnNow(createTime(this.state.result + '.' + this.state.buf));
      } else {
        throw this.error(new TomlError('Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z'));
      }
    }
    parseTimeZoneOrFraction() {
      if (this.char === CHAR_PERIOD) {
        this.consume();
        this.next(this.parseDateTimeFraction);
      } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
        this.consume();
        this.next(this.parseTimeZoneHour);
      } else if (this.char === CHAR_Z) {
        this.consume();
        return this.return(createDateTime(this.state.result + this.state.buf));
      } else if (this.atEndOfWord()) {
        return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
      } else {
        throw this.error(new TomlError('Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z'));
      }
    }
    parseDateTimeFraction() {
      if (isDigit(this.char)) {
        this.consume();
      } else if (this.state.buf.length === 1) {
        throw this.error(new TomlError('Expected digit in milliseconds'));
      } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
        this.consume();
        this.next(this.parseTimeZoneHour);
      } else if (this.char === CHAR_Z) {
        this.consume();
        return this.return(createDateTime(this.state.result + this.state.buf));
      } else if (this.atEndOfWord()) {
        return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
      } else {
        throw this.error(new TomlError('Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z'));
      }
    }
    parseTimeZoneHour() {
      if (isDigit(this.char)) {
        this.consume();
        // FIXME: No more regexps
        if (/\d\d$/.test(this.state.buf)) return this.next(this.parseTimeZoneSep);
      } else {
        throw this.error(new TomlError('Unexpected character in datetime, expected digit'));
      }
    }
    parseTimeZoneSep() {
      if (this.char === CHAR_COLON) {
        this.consume();
        this.next(this.parseTimeZoneMin);
      } else {
        throw this.error(new TomlError('Unexpected character in datetime, expected colon'));
      }
    }
    parseTimeZoneMin() {
      if (isDigit(this.char)) {
        this.consume();
        if (/\d\d$/.test(this.state.buf)) return this.return(createDateTime(this.state.result + this.state.buf));
      } else {
        throw this.error(new TomlError('Unexpected character in datetime, expected digit'));
      }
    }

    /* BOOLEAN */
    parseBoolean() {
      /* istanbul ignore else */
      if (this.char === CHAR_t) {
        this.consume();
        return this.next(this.parseTrue_r);
      } else if (this.char === CHAR_f) {
        this.consume();
        return this.next(this.parseFalse_a);
      }
    }
    parseTrue_r() {
      if (this.char === CHAR_r) {
        this.consume();
        return this.next(this.parseTrue_u);
      } else {
        throw this.error(new TomlError('Invalid boolean, expected true or false'));
      }
    }
    parseTrue_u() {
      if (this.char === CHAR_u) {
        this.consume();
        return this.next(this.parseTrue_e);
      } else {
        throw this.error(new TomlError('Invalid boolean, expected true or false'));
      }
    }
    parseTrue_e() {
      if (this.char === CHAR_e) {
        return this.return(true);
      } else {
        throw this.error(new TomlError('Invalid boolean, expected true or false'));
      }
    }
    parseFalse_a() {
      if (this.char === CHAR_a) {
        this.consume();
        return this.next(this.parseFalse_l);
      } else {
        throw this.error(new TomlError('Invalid boolean, expected true or false'));
      }
    }
    parseFalse_l() {
      if (this.char === CHAR_l) {
        this.consume();
        return this.next(this.parseFalse_s);
      } else {
        throw this.error(new TomlError('Invalid boolean, expected true or false'));
      }
    }
    parseFalse_s() {
      if (this.char === CHAR_s) {
        this.consume();
        return this.next(this.parseFalse_e);
      } else {
        throw this.error(new TomlError('Invalid boolean, expected true or false'));
      }
    }
    parseFalse_e() {
      if (this.char === CHAR_e) {
        return this.return(false);
      } else {
        throw this.error(new TomlError('Invalid boolean, expected true or false'));
      }
    }

    /* INLINE LISTS */
    parseInlineList() {
      if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {
        return null;
      } else if (this.char === Parser.END) {
        throw this.error(new TomlError('Unterminated inline array'));
      } else if (this.char === CHAR_NUM) {
        return this.call(this.parseComment);
      } else if (this.char === CHAR_RSQB) {
        return this.return(this.state.resultArr || InlineList());
      } else {
        return this.callNow(this.parseValue, this.recordInlineListValue);
      }
    }
    recordInlineListValue(value) {
      if (this.state.resultArr) {
        const listType = this.state.resultArr[_contentType];
        const valueType = tomlType$1(value);
        if (listType !== valueType) {
          throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
        }
      } else {
        this.state.resultArr = InlineList(tomlType$1(value));
      }
      if (isFloat(value) || isInteger$1(value)) {
        // unbox now that we've verified they're ok
        this.state.resultArr.push(value.valueOf());
      } else {
        this.state.resultArr.push(value);
      }
      return this.goto(this.parseInlineListNext);
    }
    parseInlineListNext() {
      if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {
        return null;
      } else if (this.char === CHAR_NUM) {
        return this.call(this.parseComment);
      } else if (this.char === CHAR_COMMA) {
        return this.next(this.parseInlineList);
      } else if (this.char === CHAR_RSQB) {
        return this.goto(this.parseInlineList);
      } else {
        throw this.error(new TomlError('Invalid character, expected whitespace, comma (,) or close bracket (])'));
      }
    }

    /* INLINE TABLE */
    parseInlineTable() {
      if (this.char === CHAR_SP || this.char === CTRL_I) {
        return null;
      } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {
        throw this.error(new TomlError('Unterminated inline array'));
      } else if (this.char === CHAR_RCUB) {
        return this.return(this.state.resultTable || InlineTable());
      } else {
        if (!this.state.resultTable) this.state.resultTable = InlineTable();
        return this.callNow(this.parseAssign, this.recordInlineTableValue);
      }
    }
    recordInlineTableValue(kv) {
      let target = this.state.resultTable;
      let finalKey = kv.key.pop();
      for (let kw of kv.key) {
        if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
          throw this.error(new TomlError("Can't redefine existing key"));
        }
        target = target[kw] = target[kw] || Table();
      }
      if (hasKey(target, finalKey)) {
        throw this.error(new TomlError("Can't redefine existing key"));
      }
      if (isInteger$1(kv.value) || isFloat(kv.value)) {
        target[finalKey] = kv.value.valueOf();
      } else {
        target[finalKey] = kv.value;
      }
      return this.goto(this.parseInlineTableNext);
    }
    parseInlineTableNext() {
      if (this.char === CHAR_SP || this.char === CTRL_I) {
        return null;
      } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {
        throw this.error(new TomlError('Unterminated inline array'));
      } else if (this.char === CHAR_COMMA) {
        return this.next(this.parseInlineTable);
      } else if (this.char === CHAR_RCUB) {
        return this.goto(this.parseInlineTable);
      } else {
        throw this.error(new TomlError('Invalid character, expected whitespace, comma (,) or close bracket (])'));
      }
    }
  }
  return TOMLParser;
}

var parsePrettyError = prettyError$2;
function prettyError$2(err, buf) {
  /* istanbul ignore if */
  if (err.pos == null || err.line == null) return err;
  let msg = err.message;
  msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:\n`;

  /* istanbul ignore else */
  if (buf && buf.split) {
    const lines = buf.split(/\n/);
    const lineNumWidth = String(Math.min(lines.length, err.line + 3)).length;
    let linePadding = ' ';
    while (linePadding.length < lineNumWidth) linePadding += ' ';
    for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines.length, err.line + 2); ++ii) {
      let lineNum = String(ii + 1);
      if (lineNum.length < lineNumWidth) lineNum = ' ' + lineNum;
      if (err.line === ii) {
        msg += lineNum + '> ' + lines[ii] + '\n';
        msg += linePadding + '  ';
        for (let hh = 0; hh < err.col; ++hh) {
          msg += ' ';
        }
        msg += '^\n';
      } else {
        msg += lineNum + ': ' + lines[ii] + '\n';
      }
    }
  }
  err.message = msg + '\n';
  return err;
}

var parseString_1 = parseString;
const TOMLParser$2 = tomlParser.exports;
const prettyError$1 = parsePrettyError;
function parseString(str) {
  if (commonjsGlobal.Buffer && commonjsGlobal.Buffer.isBuffer(str)) {
    str = str.toString('utf8');
  }
  const parser = new TOMLParser$2();
  try {
    parser.parse(str);
    return parser.finish();
  } catch (err) {
    throw prettyError$1(err, str);
  }
}

var parseAsync_1 = parseAsync;
const TOMLParser$1 = tomlParser.exports;
const prettyError = parsePrettyError;
function parseAsync(str, opts) {
  if (!opts) opts = {};
  const index = 0;
  const blocksize = opts.blocksize || 40960;
  const parser = new TOMLParser$1();
  return new Promise((resolve, reject) => {
    setImmediate(parseAsyncNext, index, blocksize, resolve, reject);
  });
  function parseAsyncNext(index, blocksize, resolve, reject) {
    if (index >= str.length) {
      try {
        return resolve(parser.finish());
      } catch (err) {
        return reject(prettyError(err, str));
      }
    }
    try {
      parser.parse(str.slice(index, index + blocksize));
      setImmediate(parseAsyncNext, index + blocksize, blocksize, resolve, reject);
    } catch (err) {
      reject(prettyError(err, str));
    }
  }
}

var parseStream_1 = parseStream;
const stream = require$$0__default["default"];
const TOMLParser = tomlParser.exports;
function parseStream(stm) {
  if (stm) {
    return parseReadable(stm);
  } else {
    return parseTransform();
  }
}
function parseReadable(stm) {
  const parser = new TOMLParser();
  stm.setEncoding('utf8');
  return new Promise((resolve, reject) => {
    let readable;
    let ended = false;
    let errored = false;
    function finish() {
      ended = true;
      if (readable) return;
      try {
        resolve(parser.finish());
      } catch (err) {
        reject(err);
      }
    }
    function error(err) {
      errored = true;
      reject(err);
    }
    stm.once('end', finish);
    stm.once('error', error);
    readNext();
    function readNext() {
      readable = true;
      let data;
      while ((data = stm.read()) !== null) {
        try {
          parser.parse(data);
        } catch (err) {
          return error(err);
        }
      }
      readable = false;
      /* istanbul ignore if */
      if (ended) return finish();
      /* istanbul ignore if */
      if (errored) return;
      stm.once('readable', readNext);
    }
  });
}
function parseTransform() {
  const parser = new TOMLParser();
  return new stream.Transform({
    objectMode: true,
    transform(chunk, encoding, cb) {
      try {
        parser.parse(chunk.toString(encoding));
      } catch (err) {
        this.emit('error', err);
      }
      cb();
    },
    flush(cb) {
      try {
        this.push(parser.finish());
      } catch (err) {
        this.emit('error', err);
      }
      cb();
    }
  });
}

(function (module) {

	module.exports = parseString_1;
	module.exports.async = parseAsync_1;
	module.exports.stream = parseStream_1;
	module.exports.prettyError = parsePrettyError;
} (parse$1));

var stringify$1 = {exports: {}};

stringify$1.exports = stringify;
stringify$1.exports.value = stringifyInline;
function stringify(obj) {
  if (obj === null) throw typeError('null');
  if (obj === void 0) throw typeError('undefined');
  if (typeof obj !== 'object') throw typeError(typeof obj);
  if (typeof obj.toJSON === 'function') obj = obj.toJSON();
  if (obj == null) return null;
  const type = tomlType(obj);
  if (type !== 'table') throw typeError(type);
  return stringifyObject('', '', obj);
}
function typeError(type) {
  return new Error('Can only stringify objects, not ' + type);
}
function arrayOneTypeError() {
  return new Error("Array values can't have mixed types");
}
function getInlineKeys(obj) {
  return Object.keys(obj).filter(key => isInline(obj[key]));
}
function getComplexKeys(obj) {
  return Object.keys(obj).filter(key => !isInline(obj[key]));
}
function toJSON(obj) {
  let nobj = Array.isArray(obj) ? [] : Object.prototype.hasOwnProperty.call(obj, '__proto__') ? {
    ['__proto__']: undefined
  } : {};
  for (let prop of Object.keys(obj)) {
    if (obj[prop] && typeof obj[prop].toJSON === 'function' && !('toISOString' in obj[prop])) {
      nobj[prop] = obj[prop].toJSON();
    } else {
      nobj[prop] = obj[prop];
    }
  }
  return nobj;
}
function stringifyObject(prefix, indent, obj) {
  obj = toJSON(obj);
  var inlineKeys;
  var complexKeys;
  inlineKeys = getInlineKeys(obj);
  complexKeys = getComplexKeys(obj);
  var result = [];
  var inlineIndent = indent || '';
  inlineKeys.forEach(key => {
    var type = tomlType(obj[key]);
    if (type !== 'undefined' && type !== 'null') {
      result.push(inlineIndent + stringifyKey(key) + ' = ' + stringifyAnyInline(obj[key], true));
    }
  });
  if (result.length > 0) result.push('');
  var complexIndent = prefix && inlineKeys.length > 0 ? indent + '  ' : '';
  complexKeys.forEach(key => {
    result.push(stringifyComplex(prefix, complexIndent, key, obj[key]));
  });
  return result.join('\n');
}
function isInline(value) {
  switch (tomlType(value)) {
    case 'undefined':
    case 'null':
    case 'integer':
    case 'nan':
    case 'float':
    case 'boolean':
    case 'string':
    case 'datetime':
      return true;
    case 'array':
      return value.length === 0 || tomlType(value[0]) !== 'table';
    case 'table':
      return Object.keys(value).length === 0;
    /* istanbul ignore next */
    default:
      return false;
  }
}
function tomlType(value) {
  if (value === undefined) {
    return 'undefined';
  } else if (value === null) {
    return 'null';
    /* eslint-disable valid-typeof */
  } else if (typeof value === 'bigint' || Number.isInteger(value) && !Object.is(value, -0)) {
    return 'integer';
  } else if (typeof value === 'number') {
    return 'float';
  } else if (typeof value === 'boolean') {
    return 'boolean';
  } else if (typeof value === 'string') {
    return 'string';
  } else if ('toISOString' in value) {
    return isNaN(value) ? 'undefined' : 'datetime';
  } else if (Array.isArray(value)) {
    return 'array';
  } else {
    return 'table';
  }
}
function stringifyKey(key) {
  var keyStr = String(key);
  if (/^[-A-Za-z0-9_]+$/.test(keyStr)) {
    return keyStr;
  } else {
    return stringifyBasicString(keyStr);
  }
}
function stringifyBasicString(str) {
  return '"' + escapeString(str).replace(/"/g, '\\"') + '"';
}
function stringifyLiteralString(str) {
  return "'" + str + "'";
}
function numpad(num, str) {
  while (str.length < num) str = '0' + str;
  return str;
}
function escapeString(str) {
  return str.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r')
  /* eslint-disable no-control-regex */.replace(/([\u0000-\u001f\u007f])/, c => '\\u' + numpad(4, c.codePointAt(0).toString(16)));
  /* eslint-enable no-control-regex */
}

function stringifyMultilineString(str) {
  let escaped = str.split(/\n/).map(str => {
    return escapeString(str).replace(/"(?="")/g, '\\"');
  }).join('\n');
  if (escaped.slice(-1) === '"') escaped += '\\\n';
  return '"""\n' + escaped + '"""';
}
function stringifyAnyInline(value, multilineOk) {
  let type = tomlType(value);
  if (type === 'string') {
    if (multilineOk && /\n/.test(value)) {
      type = 'string-multiline';
    } else if (!/[\b\t\n\f\r']/.test(value) && /"/.test(value)) {
      type = 'string-literal';
    }
  }
  return stringifyInline(value, type);
}
function stringifyInline(value, type) {
  /* istanbul ignore if */
  if (!type) type = tomlType(value);
  switch (type) {
    case 'string-multiline':
      return stringifyMultilineString(value);
    case 'string':
      return stringifyBasicString(value);
    case 'string-literal':
      return stringifyLiteralString(value);
    case 'integer':
      return stringifyInteger(value);
    case 'float':
      return stringifyFloat(value);
    case 'boolean':
      return stringifyBoolean(value);
    case 'datetime':
      return stringifyDatetime(value);
    case 'array':
      return stringifyInlineArray(value.filter(_ => tomlType(_) !== 'null' && tomlType(_) !== 'undefined' && tomlType(_) !== 'nan'));
    case 'table':
      return stringifyInlineTable(value);
    /* istanbul ignore next */
    default:
      throw typeError(type);
  }
}
function stringifyInteger(value) {
  /* eslint-disable security/detect-unsafe-regex */
  return String(value).replace(/\B(?=(\d{3})+(?!\d))/g, '_');
}
function stringifyFloat(value) {
  if (value === Infinity) {
    return 'inf';
  } else if (value === -Infinity) {
    return '-inf';
  } else if (Object.is(value, NaN)) {
    return 'nan';
  } else if (Object.is(value, -0)) {
    return '-0.0';
  }
  var chunks = String(value).split('.');
  var int = chunks[0];
  var dec = chunks[1] || 0;
  return stringifyInteger(int) + '.' + dec;
}
function stringifyBoolean(value) {
  return String(value);
}
function stringifyDatetime(value) {
  return value.toISOString();
}
function isNumber$1(type) {
  return type === 'float' || type === 'integer';
}
function arrayType(values) {
  var contentType = tomlType(values[0]);
  if (values.every(_ => tomlType(_) === contentType)) return contentType;
  // mixed integer/float, emit as floats
  if (values.every(_ => isNumber$1(tomlType(_)))) return 'float';
  return 'mixed';
}
function validateArray(values) {
  const type = arrayType(values);
  if (type === 'mixed') {
    throw arrayOneTypeError();
  }
  return type;
}
function stringifyInlineArray(values) {
  values = toJSON(values);
  const type = validateArray(values);
  var result = '[';
  var stringified = values.map(_ => stringifyInline(_, type));
  if (stringified.join(', ').length > 60 || /\n/.test(stringified)) {
    result += '\n  ' + stringified.join(',\n  ') + '\n';
  } else {
    result += ' ' + stringified.join(', ') + (stringified.length > 0 ? ' ' : '');
  }
  return result + ']';
}
function stringifyInlineTable(value) {
  value = toJSON(value);
  var result = [];
  Object.keys(value).forEach(key => {
    result.push(stringifyKey(key) + ' = ' + stringifyAnyInline(value[key], false));
  });
  return '{ ' + result.join(', ') + (result.length > 0 ? ' ' : '') + '}';
}
function stringifyComplex(prefix, indent, key, value) {
  var valueType = tomlType(value);
  /* istanbul ignore else */
  if (valueType === 'array') {
    return stringifyArrayOfTables(prefix, indent, key, value);
  } else if (valueType === 'table') {
    return stringifyComplexTable(prefix, indent, key, value);
  } else {
    throw typeError(valueType);
  }
}
function stringifyArrayOfTables(prefix, indent, key, values) {
  values = toJSON(values);
  validateArray(values);
  var firstValueType = tomlType(values[0]);
  /* istanbul ignore if */
  if (firstValueType !== 'table') throw typeError(firstValueType);
  var fullKey = prefix + stringifyKey(key);
  var result = '';
  values.forEach(table => {
    if (result.length > 0) result += '\n';
    result += indent + '[[' + fullKey + ']]\n';
    result += stringifyObject(fullKey + '.', indent, table);
  });
  return result;
}
function stringifyComplexTable(prefix, indent, key, value) {
  var fullKey = prefix + stringifyKey(key);
  var result = '';
  if (getInlineKeys(value).length > 0) {
    result += indent + '[' + fullKey + ']\n';
  }
  return result + stringifyObject(fullKey + '.', indent, value);
}

toml.parse = parse$1.exports;
toml.stringify = stringify$1.exports;

// these aren't really private, but nor are they really useful to document

/**
 * @private
 */
class LuxonError extends Error {}

/**
 * @private
 */
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class ConflictingSpecificationError extends LuxonError {}

/**
 * @private
 */
class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
}

/**
 * @private
 */
class InvalidArgumentError extends LuxonError {}

/**
 * @private
 */
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}

/**
 * @private
 */

const n = "numeric",
  s = "short",
  l = "long";
const DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
const DATE_MED = {
  year: n,
  month: s,
  day: n
};
const DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
const DATE_FULL = {
  year: n,
  month: l,
  day: n
};
const DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
const TIME_SIMPLE = {
  hour: n,
  minute: n
};
const TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
const TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
const TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
const TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
const TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
const DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
const DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
const DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
const DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
const DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

/*
  This is just a junk drawer, containing anything used across multiple classes.
  Because Luxon is small(ish), this should stay small and we won't worry about splitting
  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.
*/

/**
 * @private
 */

// TYPES

function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}

// CAPABILITIES

function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}

// OBJECTS AND ARRAYS

function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return undefined;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// NUMBERS AND STRINGS

function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}

// x % n but takes the sign of n instead of x
function floorMod(x, n) {
  return x - n * Math.floor(x / n);
}
function padStart(input, n = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n, "0");
  } else {
    padded = ("" + input).padStart(n, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  // Return undefined (instead of 0) in these cases, where fraction is not set
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return undefined;
  } else {
    const f = parseFloat("0." + fraction) * 1000;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits,
    rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}

// DATE BASICS

function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1,
    modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}

// covert a calendar object to a local timestamp (epoch, but with the offset baked in)
function objToLocalTS(obj) {
  let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);

  // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  return +d;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7,
    last = weekYear - 1,
    p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > 60 ? 1900 + year : 2000 + year;
}

// PARSING

function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts),
    intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = {
    timeZoneName: offsetFormat,
    ...intlOpts
  };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(m => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}

// signedOffset('-5', '30') -> -330
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);

  // don't || this because we want to preserve -0
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0,
    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}

// COERCION

function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue)) throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === undefined || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset, format) {
  const hours = Math.trunc(Math.abs(offset / 60)),
    minutes = Math.trunc(Math.abs(offset % 60)),
    sign = offset >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;

/**
 * @private
 */

const monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
const monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const meridiems = ["AM", "PM"];
const erasLong = ["Before Christ", "Anno Domini"];
const erasShort = ["BC", "AD"];
const erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
    }
  }

  const isInPast = Object.is(count, -0) || count < 0,
    fmtValue = Math.abs(count),
    singular = fmtValue === 1,
    lilUnits = units[unit],
    fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

function stringifyTokens(splits, tokenToString) {
  let s = "";
  for (const token of splits) {
    if (token.literal) {
      s += token.val;
    } else {
      s += tokenToString(token.val);
    }
  }
  return s;
}
const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};

/**
 * @private
 */

class Formatter {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null,
      currentFull = "",
      bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed,
            val: currentFull
          });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({
            literal: false,
            val: currentFull
          });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({
        literal: bracketed,
        val: currentFull
      });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, {
      ...this.opts,
      ...opts
    });
    return df.format();
  }
  formatDateTime(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, {
      ...this.opts,
      ...opts
    });
    return df.format();
  }
  formatDateTimeParts(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, {
      ...this.opts,
      ...opts
    });
    return df.formatToParts();
  }
  resolvedOptions(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, {
      ...this.opts,
      ...opts
    });
    return df.resolvedOptions();
  }
  num(n, p = 0) {
    // we get some perf out of doing this here, annoyingly
    if (this.opts.forceSimple) {
      return padStart(n, p);
    }
    const opts = {
      ...this.opts
    };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en",
      useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
      string = (opts, extract) => this.loc.extract(dt, opts, extract),
      formatOffset = opts => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      },
      meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({
        hour: "numeric",
        hourCycle: "h12"
      }, "dayperiod"),
      month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
        month: length
      } : {
        month: length,
        day: "numeric"
      }, "month"),
      weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
        weekday: length
      } : {
        weekday: length,
        month: "long",
        day: "numeric"
      }, "weekday"),
      maybeMacro = token => {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      },
      era = length => knownEnglish ? eraForDateTime(dt, length) : string({
        era: length
      }, "era"),
      tokenToString = token => {
        // Where possible: http://cldr.unicode.org/translation/date-time-1/date-time#TOC-Standalone-vs.-Format-Styles
        switch (token) {
          // ms
          case "S":
            return this.num(dt.millisecond);
          case "u":
          // falls through
          case "SSS":
            return this.num(dt.millisecond, 3);
          // seconds
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          // fractional seconds
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          // minutes
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          // hours
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          // offset
          case "Z":
            // like +6
            return formatOffset({
              format: "narrow",
              allowZ: this.opts.allowZ
            });
          case "ZZ":
            // like +06:00
            return formatOffset({
              format: "short",
              allowZ: this.opts.allowZ
            });
          case "ZZZ":
            // like +0600
            return formatOffset({
              format: "techie",
              allowZ: this.opts.allowZ
            });
          case "ZZZZ":
            // like EST
            return dt.zone.offsetName(dt.ts, {
              format: "short",
              locale: this.loc.locale
            });
          case "ZZZZZ":
            // like Eastern Standard Time
            return dt.zone.offsetName(dt.ts, {
              format: "long",
              locale: this.loc.locale
            });
          // zone
          case "z":
            // like America/New_York
            return dt.zoneName;
          // meridiems
          case "a":
            return meridiem();
          // dates
          case "d":
            return useDateTimeFormatter ? string({
              day: "numeric"
            }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string({
              day: "2-digit"
            }, "day") : this.num(dt.day, 2);
          // weekdays - standalone
          case "c":
            // like 1
            return this.num(dt.weekday);
          case "ccc":
            // like 'Tues'
            return weekday("short", true);
          case "cccc":
            // like 'Tuesday'
            return weekday("long", true);
          case "ccccc":
            // like 'T'
            return weekday("narrow", true);
          // weekdays - format
          case "E":
            // like 1
            return this.num(dt.weekday);
          case "EEE":
            // like 'Tues'
            return weekday("short", false);
          case "EEEE":
            // like 'Tuesday'
            return weekday("long", false);
          case "EEEEE":
            // like 'T'
            return weekday("narrow", false);
          // months - standalone
          case "L":
            // like 1
            return useDateTimeFormatter ? string({
              month: "numeric",
              day: "numeric"
            }, "month") : this.num(dt.month);
          case "LL":
            // like 01, doesn't seem to work
            return useDateTimeFormatter ? string({
              month: "2-digit",
              day: "numeric"
            }, "month") : this.num(dt.month, 2);
          case "LLL":
            // like Jan
            return month("short", true);
          case "LLLL":
            // like January
            return month("long", true);
          case "LLLLL":
            // like J
            return month("narrow", true);
          // months - format
          case "M":
            // like 1
            return useDateTimeFormatter ? string({
              month: "numeric"
            }, "month") : this.num(dt.month);
          case "MM":
            // like 01
            return useDateTimeFormatter ? string({
              month: "2-digit"
            }, "month") : this.num(dt.month, 2);
          case "MMM":
            // like Jan
            return month("short", false);
          case "MMMM":
            // like January
            return month("long", false);
          case "MMMMM":
            // like J
            return month("narrow", false);
          // years
          case "y":
            // like 2014
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year);
          case "yy":
            // like 14
            return useDateTimeFormatter ? string({
              year: "2-digit"
            }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            // like 0012
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            // like 000012
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year, 6);
          // eras
          case "G":
            // like AD
            return era("short");
          case "GG":
            // like Anno Domini
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            // like 1
            return this.num(dt.quarter);
          case "qq":
            // like 01
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1000));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = token => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      },
      tokenToString = lildur => token => {
        const mapped = tokenToField(token);
        if (mapped) {
          return this.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      },
      tokens = Formatter.parseFormat(fmt),
      realTokens = tokens.reduce((found, {
        literal,
        val
      }) => literal ? found : found.concat(val), []),
      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter(t => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
}

class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}

/**
 * @interface
 */
class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }

  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }

  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }

  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}

let singleton$1 = null;

/**
 * Represents the local zone for this JavaScript environment.
 * @implements {Zone}
 */
class SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton$1 === null) {
      singleton$1 = new SystemZone();
    }
    return singleton$1;
  }

  /** @override **/
  get type() {
    return "system";
  }

  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, {
    format,
    locale
  }) {
    return parseZoneInfo(ts, format, locale);
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }

  /** @override **/
  get isValid() {
    return true;
  }
}

let dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""),
    parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted),
    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const {
      type,
      value
    } = formatted[i];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
let ianaZoneCache = {};
/**
 * A zone identified by an IANA identifier, like America/New_York
 * @implements {Zone}
 */
class IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }

  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }

  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s) {
    return this.isValidZone(s);
  }

  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", {
        timeZone: zone
      }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    /** @private **/
    this.zoneName = name;
    /** @private **/
    this.valid = IANAZone.isValidZone(name);
  }

  /** @override **/
  get type() {
    return "iana";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, {
    format,
    locale
  }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date)) return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }

    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return (asUTC - asTS) / (60 * 1000);
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }

  /** @override **/
  get isValid() {
    return this.valid;
  }
}

let singleton = null;

/**
 * A zone with a fixed offset (meaning no DST)
 * @implements {Zone}
 */
class FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton === null) {
      singleton = new FixedOffsetZone(0);
    }
    return singleton;
  }

  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset) {
    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
  }

  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s) {
    if (s) {
      const r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset) {
    super();
    /** @private **/
    this.fixed = offset;
  }

  /** @override **/
  get type() {
    return "fixed";
  }

  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }

  /** @override **/
  offsetName() {
    return this.name;
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }

  /** @override **/
  get isUniversal() {
    return true;
  }

  /** @override **/
  offset() {
    return this.fixed;
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }

  /** @override **/
  get isValid() {
    return true;
  }
}

/**
 * A zone that failed to parse. You should never need to instantiate this.
 * @implements {Zone}
 */
class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    /**  @private */
    this.zoneName = zoneName;
  }

  /** @override **/
  get type() {
    return "invalid";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName() {
    return null;
  }

  /** @override **/
  formatOffset() {
    return "";
  }

  /** @override **/
  offset() {
    return NaN;
  }

  /** @override **/
  equals() {
    return false;
  }

  /** @override **/
  get isValid() {
    return false;
  }
}

/**
 * @private
 */
function normalizeZone(input, defaultZone) {
  if (isUndefined(input) || input === null) {
    return defaultZone;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default") return defaultZone;else if (lowered === "local" || lowered === "system") return SystemZone.instance;else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    // This is dumb, but the instanceof check above doesn't seem to really work
    // so we're duck checking it
    return input;
  } else {
    return new InvalidZone(input);
  }
}

let now = () => Date.now(),
  defaultZone = "system",
  defaultLocale = null,
  defaultNumberingSystem = null,
  defaultOutputCalendar = null,
  throwOnInvalid;

/**
 * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
 */
class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }

  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n) {
    now = n;
  }

  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }

  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }

  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }

  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }

  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }

  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }

  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }

  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }

  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }

  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }

  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
}

// todo - remap caching

let intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
let intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
let intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
let intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const {
    base,
    ...cacheKeyOpts
  } = opts; // exclude `base` from the options
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
let sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  // I really want to avoid writing a BCP 47 parser
  // see, e.g. https://github.com/wooorm/bcp-47
  // Instead, we'll do this:

  // a) if the string has no -u extensions, just leave it alone
  // b) if it does, use Intl to resolve everything
  // c) if Intl fails, try again without the -u

  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    const smaller = localeStr.substring(0, uIndex);
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
    } catch (e) {
      options = getCachedDTF(smaller).resolvedOptions();
    }
    const {
      numberingSystem,
      calendar
    } = options;
    // return the smaller one so that we can append the calendar and numbering overrides to it
    return [smaller, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    localeStr += "-u";
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2016, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}

/**
 * @private
 */

class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const {
      padTo,
      floor,
      ...otherOpts
    } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = {
        useGrouping: false,
        ...opts
      };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      // to match the browser's numberformatter defaults
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
}

/**
 * @private
 */

class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;
    let z;
    if (dt.zone.isUniversal) {
      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.
      // That is why fixed-offset TZ is set to that unless it is:
      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.
      // 2. Unsupported by the browser:
      //    - some do not support Etc/
      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.
        // So we have to make do. Two cases:
        // 1. The format options tell us to show the zone. We can't do that, so the best
        // we can do is format the date in UTC.
        // 2. The format options don't tell us to show the zone. Then we can adjust them
        // the time and tell the formatter to show it to us in UTC, so that the time is right
        // and the bad zone doesn't show up.
        z = "UTC";
        if (opts.timeZoneName) {
          this.dt = dt;
        } else {
          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);
        }
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z = dt.zone.name;
    }
    const intlOpts = {
      ...this.opts
    };
    if (z) {
      intlOpts.timeZone = z;
    }
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}

/**
 * @private
 */
class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = {
      style: "long",
      ...opts
    };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
}

/**
 * @private
 */

class Locale {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }
  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    // the system locale is useful for human readable strings but annoying for parsing/formatting known formats
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({
    locale,
    numberingSystem,
    outputCalendar
  } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar);
  }
  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = {
      format: {},
      standalone: {}
    };
    this.monthsCache = {
      format: {},
      standalone: {}
    };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({
      ...alts,
      defaultToEN: true
    });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({
      ...alts,
      defaultToEN: false
    });
  }
  months(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, months, () => {
      const intl = format ? {
          month: length,
          day: "numeric"
        } : {
          month: length
        },
        formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths(dt => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, weekdays, () => {
      const intl = format ? {
          weekday: length,
          year: "numeric",
          month: "long",
          day: "numeric"
        } : {
          weekday: length
        },
        formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(dt => this.extract(dt, intl, "weekday"));
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems(defaultOK = true) {
    return listStuff(this, undefined, defaultOK, () => meridiems, () => {
      // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
      // for AM and PM. This is probably wrong, but it's makes parsing way easier.
      if (!this.meridiemCache) {
        const intl = {
          hour: "numeric",
          hourCycle: "h12"
        };
        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(dt => this.extract(dt, intl, "dayperiod"));
      }
      return this.meridiemCache;
    });
  }
  eras(length, defaultOK = true) {
    return listStuff(this, length, defaultOK, eras, () => {
      const intl = {
        era: length
      };

      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
      // to definitely enumerate them.
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(dt => this.extract(dt, intl, "era"));
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts),
      results = df.formatToParts(),
      matching = results.find(m => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
    // (in contrast, the rest of the condition is used heavily)
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
}

/*
 * This file handles parsing for well-specified formats. Here's how it works:
 * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
 * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
 * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
 * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
 * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
 * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
 */

function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return m => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
    const [val, zone, next] = ex(m, cursor);
    return [{
      ...mergedVals,
      ...val
    }, zone || mergedZone, next];
  }, [{}, null, 1]).slice(0, 2);
}
function parse(s, ...patterns) {
  if (s == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}

// ISO and SQL parsing
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
const isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
const isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
const extractISOOrdinalData = simpleParse("year", "ordinal");
const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/; // dumbed-down version of the ISO one
const sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
const sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match, pos, fallback) {
  const m = match[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match, cursor) {
  const item = {
    year: int(match, cursor),
    month: int(match, cursor + 1, 1),
    day: int(match, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match, cursor) {
  const item = {
    hours: int(match, cursor, 0),
    minutes: int(match, cursor + 1, 0),
    seconds: int(match, cursor + 2, 0),
    milliseconds: parseMillis(match[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match, cursor) {
  const local = !match[cursor] && !match[cursor + 1],
    fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),
    zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match, cursor) {
  const zone = match[cursor] ? IANAZone.create(match[cursor]) : null;
  return [{}, zone, cursor + 1];
}

// ISO time parsing

const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);

// ISO duration parsing

const isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match) {
  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match;
  const hasNegativePrefix = s[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== undefined && (force || num && hasNegativePrefix) ? -num : num;
  return [{
    years: maybeNegate(parseFloating(yearStr)),
    months: maybeNegate(parseFloating(monthStr)),
    weeks: maybeNegate(parseFloating(weekStr)),
    days: maybeNegate(parseFloating(dayStr)),
    hours: maybeNegate(parseFloating(hourStr)),
    minutes: maybeNegate(parseFloating(minuteStr)),
    seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
    milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
  }];
}

// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
// and not just that we're in -240 *right now*. But since I don't think these are used that often
// I'm just going to ignore that
const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}

// RFC 2822/5322
const rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset;
  if (obsOffset) {
    offset = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset = 0;
  } else {
    offset = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset)];
}
function preprocessRFC2822(s) {
  // Remove comments and folding whitespace and replace multiple-spaces with a single space
  return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}

// http date

const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
  rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
  ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
const extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
const extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
const extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
const extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);

/*
 * @private
 */

function parseISODate(s) {
  return parse(s, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
}
function parseRFC2822Date(s) {
  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s) {
  return parse(s, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
}
function parseISODuration(s) {
  return parse(s, [isoDuration, extractISODuration]);
}
const extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s) {
  return parse(s, [isoTimeOnly, extractISOTimeOnly]);
}
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
const extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(s) {
  return parse(s, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
}

const INVALID$2 = "Invalid Duration";

// unit conversion constants
const lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1000
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1000
    },
    hours: {
      minutes: 60,
      seconds: 60 * 60,
      milliseconds: 60 * 60 * 1000
    },
    minutes: {
      seconds: 60,
      milliseconds: 60 * 1000
    },
    seconds: {
      milliseconds: 1000
    }
  },
  casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1000
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  },
  daysInYearAccurate = 146097.0 / 400,
  daysInMonthAccurate = 146097.0 / 4800,
  accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };

// units ordered by size
const orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
const reverseUnits = orderedUnits$1.slice(0).reverse();

// clone really means "create another instance just like this one, but with these changes"
function clone$1(dur, alts, clear = false) {
  // deep merge for vals
  const conf = {
    values: clear ? alts.values : {
      ...dur.values,
      ...(alts.values || {})
    },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function antiTrunc(n) {
  return n < 0 ? Math.floor(n) : Math.ceil(n);
}

// NB: mutates parameters
function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit],
    raw = fromMap[fromUnit] / conv,
    sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),
    // ok, so this is wild, but see the matrix in the tests
    added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}

// NB: mutates parameters
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}

// Remove all properties with a value of 0 from an object
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}

/**
 * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.
 *
 * Here is a brief overview of commonly used methods and getters in Duration:
 *
 * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.
 * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.
 * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.
 * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.
 * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}
 *
 * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
 */
class Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }

    /**
     * @access private
     */
    this.values = config.values;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.matrix = matrix;
    /**
     * @access private
     */
    this.isLuxonDuration = true;
  }

  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return Duration.fromObject({
      milliseconds: count
    }, opts);
  }

  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }

  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
    }
  }

  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }

  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }

  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({
        invalid
      });
    }
  }

  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }

  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }

  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    // reverse-compat since 1.2; we always round down now, never up, and we do it by default
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
  }

  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    const l = orderedUnits$1.map(unit => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({
        style: "unit",
        unitDisplay: "long",
        ...opts,
        unit: unit.slice(0, -1)
      }).format(val);
    }).filter(n => n);
    return this.loc.listFormatter({
      type: "conjunction",
      style: opts.listStyle || "narrow",
      ...opts
    }).format(l);
  }

  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return {
      ...this.values
    };
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    // we could use the formatter, but this is an easier way to get the minimum string
    if (!this.isValid) return null;
    let s = "P";
    if (this.years !== 0) s += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s += this.weeks + "W";
    if (this.days !== 0) s += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s += "T";
    if (this.hours !== 0) s += this.hours + "H";
    if (this.minutes !== 0) s += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      // this will handle "floating point madness" by removing extra decimal places
      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken
      s += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
    if (s === "P") s += "T0S";
    return s;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 86400000) return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts
    };
    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }
    let str = value.toFormat(fmt);
    if (opts.includePrefix) {
      str = "T" + str;
    }
    return str;
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }

  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.as("milliseconds");
  }

  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration),
      result = {};
    for (const k of orderedUnits$1) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone$1(this, {
      values: result
    }, true);
  }

  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }

  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid) return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone$1(this, {
      values: result
    }, true);
  }

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }

  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) return this;
    const mixed = {
      ...this.values,
      ...normalizeObject(values, Duration.normalizeUnit)
    };
    return clone$1(this, {
      values: mixed
    });
  }

  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({
    locale,
    numberingSystem,
    conversionAccuracy,
    matrix
  } = {}) {
    const loc = this.loc.clone({
      locale,
      numberingSystem
    });
    const opts = {
      loc,
      matrix,
      conversionAccuracy
    };
    return clone$1(this, opts);
  }

  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }

  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone$1(this, {
      values: vals
    }, true);
  }

  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone$1(this, {
      values: vals
    }, true);
  }

  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map(u => Duration.normalizeUnit(u));
    const built = {},
      accumulated = {},
      vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits$1) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;

        // anything we haven't boiled down yet should get boiled to this unit
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }

        // plus anything that's already in this unit
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1000 - i * 1000) / 1000;

        // plus anything further down the chain that should be rolled up in to this
        for (const down in vals) {
          if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        }
        // otherwise, keep it in the wings to boil it later
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }

    // anything leftover becomes the decimal for the last unit
    // lastUnit must be defined since units is not empty
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    return clone$1(this, {
      values: built
    }, true).normalize();
  }

  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid) return this;
    return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
  }

  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone$1(this, {
      values: negated
    }, true);
  }

  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }

  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }

  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }

  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }

  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }

  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }

  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }

  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }

  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }

  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      // Consider 0 and undefined as equal
      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits$1) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
}

const INVALID$1 = "Invalid Interval";

// checks if the start is equal to or before the end
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
  } else {
    return null;
  }
}

/**
 * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
 *
 * Here is a brief overview of the most commonly used methods and getters in Interval:
 *
 * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.
 * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.
 * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.
 * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval.merge}, {@link Interval.xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.
 * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}
 * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.
 */
class Interval {
  /**
   * @private
   */
  constructor(config) {
    /**
     * @access private
     */
    this.s = config.start;
    /**
     * @access private
     */
    this.e = config.end;
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.isLuxonInterval = true;
  }

  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({
        invalid
      });
    }
  }

  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start),
      builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }

  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }

  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }

  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s, e] = (text || "").split("/", 2);
    if (s && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s, opts);
        startIsValid = start.isValid;
      } catch (e) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }

  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }

  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }

  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }

  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }

  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }

  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(unit = "milliseconds") {
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit),
      end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + 1;
  }

  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }

  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }

  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }

  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }

  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }

  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({
    start,
    end
  } = {}) {
    if (!this.isValid) return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }

  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes.map(friendlyDateTime).filter(d => this.contains(d)).sort(),
      results = [];
    let {
        s
      } = this,
      i = 0;
    while (s < this.e) {
      const added = sorted[i] || this.e,
        next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      i += 1;
    }
    return results;
  }

  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let {
        s
      } = this,
      idx = 1,
      next;
    const results = [];
    while (s < this.e) {
      const added = this.start.plus(dur.mapUnits(x => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      idx += 1;
    }
    return results;
  }

  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }

  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }

  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }

  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }

  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }

  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }

  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s = this.s > other.s ? this.s : other.s,
      e = this.e < other.e ? this.e : other.e;
    if (s >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s, e);
    }
  }

  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s = this.s < other.s ? this.s : other.s,
      e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s, e);
  }

  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(([sofar, current], item) => {
      if (!current) {
        return [sofar, item];
      } else if (current.overlaps(item) || current.abutsStart(item)) {
        return [sofar, current.union(item)];
      } else {
        return [sofar.concat([current]), item];
      }
    }, [[], null]);
    if (final) {
      found.push(final);
    }
    return found;
  }

  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null,
      currentCount = 0;
    const results = [],
      ends = intervals.map(i => [{
        time: i.s,
        type: "s"
      }, {
        time: i.e,
        type: "e"
      }]),
      flattened = Array.prototype.concat(...ends),
      arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }

  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map(i => this.intersection(i)).filter(i => i && !i.isEmpty());
  }

  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID$1;
    return `[${this.s.toISO()} – ${this.e.toISO()})`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }

  /**
   * Returns a string representation of this Interval formatted according to the specified format string.
   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime#toFormat} for details.
   * @param {Object} opts - options
   * @param {string} [opts.separator =  ' – '] - a separator to place between the start and end representations
   * @return {string}
   */
  toFormat(dateFormat, {
    separator = " – "
  } = {}) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }

  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }

  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}

/**
 * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
 */
class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({
      month: 12
    });
    return !zone.isUniversal && proto.offset !== proto.set({
      month: 6
    }).offset;
  }

  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }

  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }

  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(length = "long", {
    locale = null,
    numberingSystem = null,
    locObj = null,
    outputCalendar = "gregory"
  } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }

  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", {
    locale = null,
    numberingSystem = null,
    locObj = null,
    outputCalendar = "gregory"
  } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }

  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(length = "long", {
    locale = null,
    numberingSystem = null,
    locObj = null
  } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }

  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", {
    locale = null,
    numberingSystem = null,
    locObj = null
  } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }

  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({
    locale = null
  } = {}) {
    return Locale.create(locale).meridiems();
  }

  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", {
    locale = null
  } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }

  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return {
      relative: hasRelative()
    };
  }
}

function dayDiff(earlier, later) {
  const utcDayStart = dt => dt.toUTC(0, {
      keepLocalTime: true
    }).startOf("day").valueOf(),
    ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [["years", (a, b) => b.year - a.year], ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4], ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12], ["weeks", (a, b) => {
    const days = dayDiff(a, b);
    return (days - days % 7) / 7;
  }], ["days", dayDiff]];
  const results = {};
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      let delta = differ(cursor, later);
      highWater = cursor.plus({
        [unit]: delta
      });
      if (highWater > later) {
        cursor = cursor.plus({
          [unit]: delta - 1
        });
        delta -= 1;
      } else {
        cursor = highWater;
      }
      results[unit] = delta;
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff (earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(u => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0);
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({
        [lowestOrder]: 1
      });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

const numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({
  numberingSystem
}, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}

const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = i => i) {
  return {
    regex,
    deser: ([s]) => post(parseDigits(s))
  };
}
const NBSP = String.fromCharCode(160);
const spaceOrNBSP = `[ ${NBSP}]`;
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s) {
  // make dots optional and also make them literal
  // make space and non breakable space characters interchangeable
  return s.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s) {
  return s.replace(/\./g, "") // ignore dots that were made optional
  .replace(spaceOrNBSPRegExp, " ") // interchange space and nbsp
  .toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s]) => strings.findIndex(i => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return {
    regex,
    deser: ([, h, m]) => signedOffset(h, m),
    groups
  };
}
function simple(regex) {
  return {
    regex,
    deser: ([s]) => s
  };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc),
    two = digitRegex(loc, "{2}"),
    three = digitRegex(loc, "{3}"),
    four = digitRegex(loc, "{4}"),
    six = digitRegex(loc, "{6}"),
    oneOrTwo = digitRegex(loc, "{1,2}"),
    oneToThree = digitRegex(loc, "{1,3}"),
    oneToSix = digitRegex(loc, "{1,6}"),
    oneToNine = digitRegex(loc, "{1,9}"),
    twoToFour = digitRegex(loc, "{2,4}"),
    fourToSix = digitRegex(loc, "{4,6}"),
    literal = t => ({
      regex: RegExp(escapeToken(t.val)),
      deser: ([s]) => s,
      literal: true
    }),
    unitate = t => {
      if (token.literal) {
        return literal(t);
      }
      switch (t.val) {
        // era
        case "G":
          return oneOf(loc.eras("short", false), 0);
        case "GG":
          return oneOf(loc.eras("long", false), 0);
        // years
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        // months
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true, false), 1);
        case "MMMM":
          return oneOf(loc.months("long", true, false), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false, false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false, false), 1);
        // dates
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        // ordinals
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        // time
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        // meridiem
        case "a":
          return oneOf(loc.meridiems(), 0);
        // weekYear (k)
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        // weekNumber (W)
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        // weekdays
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false, false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false, false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true, false), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true, false), 1);
        // offset/zone
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
        // because we don't have any way to figure out what they are
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        default:
          return literal(t);
      }
    };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, locale, formatOpts) {
  const {
    type,
    value
  } = part;
  if (type === "literal") {
    return {
      literal: true,
      val: value
    };
  }
  const style = formatOpts[type];
  let val = partTypeStyleToTokenVal[type];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return undefined;
}
function buildRegex(units) {
  const re = units.map(u => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i],
          groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = token => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
let dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(undefined)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map(t => maybeExpandMacroToken(t, locale)));
}

/**
 * @private
 */

function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale),
    units = tokens.map(t => unitForToken(t, locale)),
    disqualifyingUnit = units.find(t => t.invalidReason);
  if (disqualifyingUnit) {
    return {
      input,
      tokens,
      invalidReason: disqualifyingUnit.invalidReason
    };
  } else {
    const [regexString, handlers] = buildRegex(units),
      regex = RegExp(regexString, "i"),
      [rawMatches, matches] = match(input, regex, handlers),
      [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, undefined];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
    }
    return {
      input,
      tokens,
      regex,
      rawMatches,
      matches,
      result,
      zone,
      specificOffset
    };
  }
}
function parseFromTokens(locale, input, format) {
  const {
    result,
    zone,
    specificOffset,
    invalidReason
  } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  return parts.map(p => tokenForPart(p, locale, formatOpts));
}

const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
  leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid("unit out of range", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder,
    month0 = table.findIndex(i => i < ordinal),
    day = ordinal - table[month0];
  return {
    month: month0 + 1,
    day
  };
}

/**
 * @private
 */

function gregorianToWeek(gregObj) {
  const {
      year,
      month,
      day
    } = gregObj,
    ordinal = computeOrdinal(year, month, day),
    weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal - weekday + 10) / 7),
    weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return {
    weekYear,
    weekNumber,
    weekday,
    ...timeObject(gregObj)
  };
}
function weekToGregorian(weekData) {
  const {
      weekYear,
      weekNumber,
      weekday
    } = weekData,
    weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
    yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
    year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const {
    month,
    day
  } = uncomputeOrdinal(year, ordinal);
  return {
    year,
    month,
    day,
    ...timeObject(weekData)
  };
}
function gregorianToOrdinal(gregData) {
  const {
    year,
    month,
    day
  } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return {
    year,
    ordinal,
    ...timeObject(gregData)
  };
}
function ordinalToGregorian(ordinalData) {
  const {
    year,
    ordinal
  } = ordinalData;
  const {
    month,
    day
  } = uncomputeOrdinal(year, ordinal);
  return {
    year,
    month,
    day,
    ...timeObject(ordinalData)
  };
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear),
    validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)),
    validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year),
    validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year),
    validMonth = integerBetween(obj.month, 1, 12),
    validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  const {
    hour,
    minute,
    second,
    millisecond
  } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0,
    validMinute = integerBetween(minute, 0, 59),
    validSecond = integerBetween(second, 0, 59),
    validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}

const INVALID = "Invalid DateTime";
const MAX_DATE = 8.64e15;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}

// we cache week data on the DT object and this intermediates the cache
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}

// clone really means, "make a new object with these modifications". all "setters" really use this
// to create a new object while only changing some of the properties
function clone(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({
    ...current,
    ...alts,
    old: current
  });
}

// find the right offset a given local time. The o input is our guess, which determines which
// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)
function fixOffset(localTS, o, tz) {
  // Our UTC time is just a guess because our offset is just a guess
  let utcGuess = localTS - o * 60 * 1000;

  // Test whether the zone matches the offset for this ts
  const o2 = tz.offset(utcGuess);

  // If so, offset didn't change and we're done
  if (o === o2) {
    return [utcGuess, o];
  }

  // If not, change the ts by the difference in the offset
  utcGuess -= (o2 - o) * 60 * 1000;

  // If that gives us the local time we want, we're done
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }

  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time
  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
}

// convert an epoch timestamp into a calendar object with the given offset
function tsToObj(ts, offset) {
  ts += offset * 60 * 1000;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}

// convert a calendar object to a epoch timestamp
function objToTS(obj, offset, zone) {
  return fixOffset(objToLocalTS(obj), offset, zone);
}

// create a new DT instance by adding a duration, adjusting for DSTs
function adjustTime(inst, dur) {
  const oPre = inst.o,
    year = inst.c.year + Math.trunc(dur.years),
    month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,
    c = {
      ...inst.c,
      year,
      month,
      day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    },
    millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"),
    localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    // that could have changed the offset by going over a DST, but we want to keep the ts the same
    o = inst.zone.offset(ts);
  }
  return {
    ts,
    o
  };
}

// helper useful in turning the results of parsing into real dates
// by handling the zone options
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const {
    setZone,
    zone
  } = opts;
  if (parsed && Object.keys(parsed).length !== 0) {
    const interpretationZone = parsedZone || zone,
      inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`));
  }
}

// if you want to output a technical format (e.g. RFC 2822), this helper
// helps handle the details
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0) c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}

// defaults for unspecified units in the supported calendars
const defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  },
  defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  },
  defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };

// Units in the supported calendars, sorted by bigness
const orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
  orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"],
  orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

// standardize case and plurality in units
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
}

// this is a dumbed down version of fromObject() that runs about 60% faster
// but doesn't do any validation, makes a bunch of assumptions about what units
// are present, and so on.
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone),
    loc = Locale.fromObject(opts),
    tsNow = Settings.now();
  let ts, o;

  // assume we have the higher-order units
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({
    ts,
    zone,
    loc,
    o
  });
}
function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round,
    format = (c, unit) => {
      c = roundTo(c, round || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c, unit);
    },
    differ = unit => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {},
    args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}

/**
 * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
 *
 * A DateTime comprises of:
 * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
 * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
 * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
 *
 * Here is a brief overview of the most commonly used functionality it provides:
 *
 * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}. To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}. To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.
 * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},
 * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.
 * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.
 * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.
 * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.
 * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.
 *
 * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
 */
class DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    /**
     * @access private
     */
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null,
      o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }

    /**
     * @access private
     */
    this._zone = zone;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.invalid = invalid;
    /**
     * @access private
     */
    this.weekData = null;
    /**
     * @access private
     */
    this.c = c;
    /**
     * @access private
     */
    this.o = o;
    /**
     * @access private
     */
    this.isLuxonDateTime = true;
  }

  // CONSTRUCT

  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }

  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond
    }, opts);
  }

  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond
    }, opts);
  }

  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts: ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }

  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }

  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1000,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }

  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(),
      offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow),
      normalized = normalizeObject(obj, normalizeUnit),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber,
      loc = Locale.fromObject(opts);

    // cases:
    // just a weekday -> this week's instance of that weekday, no worries
    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
    // (gregorian month or day) + ordinal -> error
    // otherwise just use weeks or ordinals or gregorian, depending on what's specified

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;

    // configure ourselves to deal with gregorian dates or week stuff
    let units,
      defaultValues,
      objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits;
      defaultValues = defaultUnitValues;
    }

    // set default values for missing stuff
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }

    // make sure the values we have are in range
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized),
      invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }

    // compute the actual time
    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized,
      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),
      inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });

    // gregorian data + weekday serves only to validate
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
    }
    return inst;
  }

  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }

  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }

  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }

  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const {
        locale = null,
        numberingSystem = null
      } = opts,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      }),
      [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }

  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }

  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }

  /**
   * Create an invalid DateTime.
   * @param {DateTime} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({
        invalid
      });
    }
  }

  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }

  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map(t => t ? t.val : null).join("");
  }

  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map(t => t.val).join("");
  }

  // INFO

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }

  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }

  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }

  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }

  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }

  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }

  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }

  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }

  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }

  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }

  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }

  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }

  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }

  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }

  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }

  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }

  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", {
      locObj: this.loc
    })[this.month - 1] : null;
  }

  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", {
      locObj: this.loc
    })[this.month - 1] : null;
  }

  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", {
      locObj: this.loc
    })[this.weekday - 1] : null;
  }

  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", {
      locObj: this.loc
    })[this.weekday - 1] : null;
  }

  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }

  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }

  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }

  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }

  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({
        month: 1,
        day: 1
      }).offset || this.offset > this.set({
        month: 5
      }).offset;
    }
  }

  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }

  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }

  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }

  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }

  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const {
      locale,
      numberingSystem,
      calendar
    } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
    return {
      locale,
      numberingSystem,
      outputCalendar: calendar
    };
  }

  // TRANSFORM

  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset), opts);
  }

  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }

  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, {
    keepLocalTime = false,
    keepCalendarTime = false
  } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone(this, {
        ts: newTS,
        zone
      });
    }
  }

  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({
    locale,
    numberingSystem,
    outputCalendar
  } = {}) {
    const loc = this.loc.clone({
      locale,
      numberingSystem,
      outputCalendar
    });
    return clone(this, {
      loc
    });
  }

  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({
      locale
    });
  }

  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid) return this;
    const normalized = normalizeObject(values, normalizeUnit),
      settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({
        ...gregorianToWeek(this.c),
        ...normalized
      });
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({
        ...gregorianToOrdinal(this.c),
        ...normalized
      });
    } else {
      mixed = {
        ...this.toObject(),
        ...normalized
      };

      // if we didn't set the day but we ended up on an overflow date,
      // use the last day of the right month
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone(this, {
      ts,
      o
    });
  }

  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return clone(this, adjustTime(this, dur));
  }

  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone(this, adjustTime(this, dur));
  }

  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit) {
    if (!this.isValid) return this;
    const o = {},
      normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      // falls through
      case "quarters":
      case "months":
        o.day = 1;
      // falls through
      case "weeks":
      case "days":
        o.hour = 0;
      // falls through
      case "hours":
        o.minute = 0;
      // falls through
      case "minutes":
        o.second = 0;
      // falls through
      case "seconds":
        o.millisecond = 0;
        break;
      // no default, invalid units throw in normalizeUnit()
    }

    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }

  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit) {
    return this.isValid ? this.plus({
      [unit]: 1
    }).startOf(unit).minus(1) : this;
  }

  // OUTPUT

  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
  }

  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
  }

  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
  }

  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({
    includeOffset = true,
    includeZone = false,
    includeOffsetSpace = true
  } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }

  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }

  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }

  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1000 : NaN;
  }

  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1000) : NaN;
  }

  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }

  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};
    const base = {
      ...this.c
    };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }

  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }

  // COMPARE

  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = {
      locale: this.locale,
      numberingSystem: this.numberingSystem,
      ...opts
    };
    const units = maybeArray(unit).map(Duration.normalizeUnit),
      otherIsLater = otherDateTime.valueOf() > this.valueOf(),
      earlier = otherIsLater ? this : otherDateTime,
      later = otherIsLater ? otherDateTime : this,
      diffed = diff(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }

  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }

  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }

  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit) {
    if (!this.isValid) return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, {
      keepLocalTime: true
    });
    return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
  }

  /**
   * Equality check
   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }

  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid) return null;
    const base = options.base || DateTime.fromObject({}, {
        zone: this.zone
      }),
      padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = undefined;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }

  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid) return null;
    return diffRelative(options.base || DateTime.fromObject({}, {
      zone: this.zone
    }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }

  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, i => i.valueOf(), Math.min);
  }

  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, i => i.valueOf(), Math.max);
  }

  // MISC

  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const {
        locale = null,
        numberingSystem = null
      } = options,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
    return explainFromTokens(localeToUse, text, fmt);
  }

  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }

  // FORMAT PRESETS

  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}

/**
 * @private
 */
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
  }
}

// utilities for navigating our next.js sites
const options = {
  engines: {
    toml: toml.parse.bind(toml)
  },
  language: "toml",
  delimiters: "+++"
};
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const directories = dir => {
  switch (dir) {
    case "/":
      return path.join(process.cwd(), "content");
    default:
      return path.join(process.cwd(), `content/${dir}`);
  }
};
const getPage = (path, lastModified = false) => {
  try {
    let fileContents = fs__default["default"].readFileSync(`${path}.md`, "utf8");
    if (fileContents) {
      const {
        data,
        content
      } = grayMatter(fileContents, options);
      if (lastModified) {
        try {
          const stats = fs__default["default"].statSync(`${path}.md`);
          data['lastModified'] = stats.mtime.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
        } catch (error) {
          console.error(error);
        }
      }
      return {
        data,
        content
      };
    }
  } catch {
    try {
      let fileContents = fs__default["default"].readFileSync(`${path}/_index.md`, "utf8");
      if (fileContents) {
        const {
          data,
          content
        } = grayMatter(fileContents, options);
        if (lastModified) {
          try {
            const stats = fs__default["default"].statSync(`${path}/_index.md`);
            data['lastModified'] = stats.mtime.toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'long',
              day: 'numeric'
            });
          } catch (error) {
            console.error(error);
          }
        }
        return {
          data,
          content
        };
      }
    } catch {
      console.error("no md file for slug");
    }
  }
};
function getPreviousPost(slug, fields = [], key, sort = "date") {
  let resultPost = null;
  getAllPosts(fields, key, sort).forEach((post, index, array) => {
    if (post.slug === slug) {
      if (typeof array[index + 1] !== "undefined") {
        resultPost = array[index + 1];
      }
    }
  });
  return resultPost;
}
function getNextPost(slug, fields = [], key, sort = "date") {
  let resultPost = null;
  getAllPosts(fields, key, sort).forEach((post, index, array) => {
    if (post.slug === slug) {
      if (typeof array[index - 1] !== "undefined") {
        resultPost = array[index - 1];
      }
    }
  });
  return resultPost;
}
function getAllPosts(fields = [], key, sort = "") {
  const slugs = getPostSlugs(key);
  const posts = slugs.map(slug => getPostBySlug(slug, fields, key))
  // sort posts by date in descending order
  .sort((post1, post2) => {
    if (sort === "date") {
      return DateTime.fromISO(post1.date) > DateTime.fromISO(post2.date) ? -1 : 1;
    } else if (sort === "weight") {
      return post1.weight > post2.weight ? -1 : 1;
    }
  });
  return posts;
}
function getPostBySlug(slug, fields = [], key) {
  const realSlug = slug.replace(/\.md$/, "");
  const fullPath = path.join(directories(key), `${realSlug}.md`);
  const fileContents = fs__default["default"].readFileSync(fullPath, "utf8");
  const {
    data,
    content
  } = grayMatter(fileContents, options);
  const items = {};

  // Ensure only the minimal needed data is exposed
  fields.forEach(field => {
    if (field === "slug") {
      items[field] = realSlug;
    }
    if (field === "content") {
      items[field] = content;
    }
    if (data[field]) {
      items[field] = data[field];
    }
  });
  return items;
}
function getPostSlugs(key) {
  const dir = fs__default["default"].existsSync(directories(key)) ? fs__default["default"].readdirSync(directories(key), {
    withFileTypes: true
  }) : [];
  return dir.filter(f => f.isFile() && f.name !== "_index.md").map(f => f.name);
}
function formatDate(dateTimeObject) {
  return dateTimeObject.toLocaleString(DateTime.DATE_FULL);
}
function formatTime(dateTimeObject) {
  const dt = dateTimeObject.toLocaleString(DateTime.TIME_SIMPLE);
  return dt.replace(/:00/g, "");
}
function formatTimeZone(dateTimeObject) {
  return dateTimeObject.offsetNameShort;
}
function generateDisplayDate(iso8601, zone = "America/Los_Angeles") {
  return DateTime.fromISO(iso8601, {
    zone
  });
}

// Takes an ISO 8601 date string
// Returns a time relative to user's current timezone
function generateRealtimeDate(iso8601) {
  return DateTime.fromISO(iso8601).setZone("system");
}

exports.BackgroundImage = BackgroundImage;
exports.Card = IndexCard;
exports.Container = Container;
exports.Footer = Footer$1;
exports.IntraNav = IntraNav;
exports.Markdown = Markdown;
exports.MenuTray = MenuTray;
exports.RenderTree = RenderTree;
exports.Search = Search;
exports.Section = Section;
exports.Sigil = Sigil;
exports.SingleColumn = SingleColumn;
exports.TableOfContents = TableOfContents;
exports.TwoUp = TwoUp;
exports.capitalize = capitalize;
exports.formatDate = formatDate;
exports.formatTime = formatTime;
exports.formatTimeZone = formatTimeZone;
exports.generateDisplayDate = generateDisplayDate;
exports.generateRealtimeDate = generateRealtimeDate;
exports.getAllPosts = getAllPosts;
exports.getNextPost = getNextPost;
exports.getPage = getPage;
exports.getPostBySlug = getPostBySlug;
exports.getPostSlugs = getPostSlugs;
exports.getPreviousPost = getPreviousPost;
